<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>堆的知识与利用（0day2）</title><meta name="description" content="Winter is coming"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/source/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="generator" content="Hexo 5.3.0"></head><body class="is-flex is-flex-direction-column"><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-mobile"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Fstark's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">堆的知识与利用（0day2）</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">堆的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A9%BA%E8%A1%A8"><span class="toc-text">1.空表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BF%AB%E8%A1%A8"><span class="toc-text">2.快表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A0%86%E5%9D%97%E5%88%86%E9%85%8D"><span class="toc-text">1.堆块分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E5%9D%97%E7%9A%84%E9%87%8A%E6%94%BE"><span class="toc-text">2.堆块的释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A0%86%E5%9D%97%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-text">3.堆块的合并</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0"><i class="tag post-item-tag">读书笔记</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">堆的知识与利用（0day2）</h1><time class="has-text-grey" datetime="2020-01-14T03:24:38.000Z">2020-01-14</time><article class="mt-2 post-content"><p>由于微软公司并没有完全公开其操作系统中堆管理的细节。因而到目前为止，对于 Windows 堆的了解主要是源于许多安全专家、技术爱好者的研究成果。并且基于堆的溢出攻击一度被认为是不太可能的。但是自从 Matt Conover 在CanSecWest 2004 黑客大会上发表了关于 Windows下堆溢出利用的演讲后，研究人员才逐渐开始把视线转移到基于堆的缓冲区溢出研究中来。</p>
<p>另外，值得提出的是，堆与栈是两种完全不同的内存表现形式。栈只有 POP和 PUSH 两种操作，管理机制相对比较简单。而堆在内存中的形式则比较凌乱，显得无序，并且使用后需要程序员自行释放内存，否则会造成内存泄漏。因而利用堆溢出的攻击也相对较难。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaw5g912c7j320f0rsqlh.jpg" alt="image-20200114160233870"></p>
<a id="more"></a>

<h2 id="堆的基础知识"><a href="#堆的基础知识" class="headerlink" title="堆的基础知识"></a>堆的基础知识</h2><p>序员在使用堆时只需要做三件事情：申请一定大小的内存，使用内存，释放内存。我们下面将站在实现一个堆管理机制的设计者角度，来看看怎样才能向程序员提供这样透明的操作。<br>对于堆管理系统来说，响应程序的内存使用申请就意味着要在“杂乱”的堆区中“辨别”出哪些内存是正在被使用的，哪些内存是空闲的，并最终“寻找”到一片“恰当”的空闲内存区域，以指针形式返回给程序。<br>（1）“杂乱”是指堆区经过反复的申请、释放操作之后，原本大片连续的空闲内存区可能呈现出大小不等且空闲块、占用块相间隔的凌乱状态。<br>（2）“辨别”是指堆管理程序必须能够正确地识别哪些内存区域是正在被程序使用的占用块，哪些区域是可以返回给当前请求的空闲块。<br>（3）“恰当”是指堆管理程序必须能够比较“经济”地分配空闲内存块。如果用户申请使用8个字节，而返回给用户一片512字节的连续内存区域并将其标记成占用状态，这将造成大量的内存浪费，以致出现明明有内存却无法满足申请请求的情况。</p>
<p>为了完成这些基本要求，必须设计一套高效的数据结构来配合算法。现代操作系统的堆数据结构一般包括堆块和堆表两类。<br><strong>堆块</strong>：出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个堆块头部的几个字节，用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息；块身是紧跟在块首后面的部分，也是最终分配给用户使用的数据区。<br>提示：<u>堆管理系统所返回的指针一般指向块身的起始位置，在程序中是感觉不到块首的存在的</u>。然而，连续地进行内存申请时，如果您够细心，<u>可能会发现返回的内存之间存在“空隙”，那就是块首！</u><br><strong>堆表</strong>：堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，包括堆块的位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。</p>
<p>堆的内存组织结构如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaw5n5u56rj315k0rs78m.jpg" alt="image-20200114160914791"></p>
<p>Windows中，<u>占用态的堆块被使用它的程序索引</u>，而<u>堆表只索引所有空闲态的堆块</u>。其中，最重要的堆表有两种：空闲双向链表Freelist（以下简称空表）和快速单向链表Lookaside（以下简称快表）。</p>
<h3 id="1-空表"><a href="#1-空表" class="headerlink" title="1.空表"></a>1.空表</h3><p>空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为128条。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaw5tqn8a1j31980u0e3z.jpg" alt="image-20200114161450223"></p>
<p>堆区一开始的堆表区中有一个128项的指针数组，被称做空表索引（Freelist array）。该数组的每一项包括两个指针，用于标识一条空表。<br>如图所示，空表索引的第二项（free[1]）标识了堆中所有大小为8字节的空闲堆块，之后每个索引项指示的空闲堆块递增8字节，例如，free[2]标识大小为16字节的空闲堆块，free[3]标识大小为24字节的空闲堆块，free[127]标识大小为1016字节的空闲堆块。因此有：<br>空闲堆块的大小＝索引项（ID）×8（字节）<br>把空闲堆块按照大小的不同链入不同的空表，可以方便堆管理系统高效检索指定大小的空闲堆块。需要注意的是，空表索引的第一项（free[0]）所标识的空表相对比较特殊。这条双向链表链入了所有大于等于1024字节的堆块（小于512KB）。这些堆块按照各自的大小在零号空表中升序地依次排列下去，您会在稍后发现这样组织的好处。</p>
<h3 id="2-快表"><a href="#2-快表" class="headerlink" title="2.快表"></a>2.快表</h3><p>快表是Windows用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并（其中的空闲块块首被设置为占用态，用来防止堆块合并）。<br>快表也有128条，组织结构与空表类似，只是其中的堆块按照单链表组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaw5z3brr4j30py0m7q5j.jpg" alt="image-20200114162043122"></p>
<p>堆中的操作可以分为堆块分配、堆块释放和堆块合并（Coalesce）三种。其中，“分配”和“释放”是在程序提交申请和执行的，而堆块合并则是由堆管理系统自动完成的。</p>
<h3 id="1-堆块分配"><a href="#1-堆块分配" class="headerlink" title="1.堆块分配"></a>1.堆块分配</h3><p>堆块分配可以分为三类：<u>快表分配、普通空表分配和零号空表（free[0]）分配</u>。<br>从快表中分配堆块比较简单，包括寻找到大小匹配的空闲堆块、将其状态修改为占用态、把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用。<br>普通空表分配时首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配，即最小的能够满足要求的空闲块。<br>零号空表中按照大小升序链着大小不同的空闲块，故在分配时先从free[0]反向查找最后一个块（即表中最大块），看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的空闲堆块进行分配（这就明白为什么零号空表要按照升序排列了）。<br>堆块分配中的“找零钱”现象：当空表中无法找到匹配的“最优”堆块时，一个稍大些的块会被用于分配。这种次优分配发生时，会先从大块中按请求的大小精确地“割”出一块进行分配，然后给剩下的部分重新标注块首，链入空表。这里体现的就是堆管理系统的“节约”原则：买东西的时候用最合适的钞票，如果没有，就要找零钱，决不会玩大方。<br>由于快表只有在精确匹配时才会分配，故不存在“找钱”现象。</p>
<h3 id="2-堆块的释放"><a href="#2-堆块的释放" class="headerlink" title="2.堆块的释放"></a>2.堆块的释放</h3><p>释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入堆表的末尾，分配的时候也先从堆表末尾拿。<br>另外需要强调，快表最多只有4项。</p>
<h3 id="3-堆块的合并"><a href="#3-堆块的合并" class="headerlink" title="3.堆块的合并"></a>3.堆块的合并</h3><p>经过反复的申请与释放操作，堆区很可能变得“千疮百孔”，产生很多内存碎片。为了合理有效地利用内存，堆管理系统还要能够进行堆块合并操作，如图所示。<br>当堆管理系统发现两个空闲堆块彼此相邻的时候，就会进行堆块合并操作。<br>堆块合并包括将两个块从空闲链表中“卸下”、合并堆块、调整合并后大块的块首信息（如大小等）、将新块重新链入空闲链表。</p>
<p>在具体进行堆块分配和释放时，根据操作内存大小的不同，Windows采取的策略也会有所不同。可以把内存块按照大小分为三类：<br>小块：SIZE&lt;1KB<br>大块：1KB≤SIZE&lt;512KB<br>巨块：SIZE≥512KB</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaw6e25csoj30wi0u04qp.jpg" alt="image-20200114163505782"></p>
<p>对应的分配和释放算法也有三类，我们可以通过下表来理解Windows的堆管理策略。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbch0sys86j317k0m8aen.jpg" alt="image-20200114163603753"></p>
<p>最后，再强调一下Windows堆管理的几个要点。<br>（1）快表中的空闲块被设置为占用态，故不会发生堆块合并操作。<br>（2）快表只有精确匹配时才会分配，不存在“搜索次优解”和“找零钱”现象。<br>（3）快表是单链表，操作比双链表简单，插入删除都少用很多指令。<br>（4）综上所述，快表很“快”，故在分配和释放时总是优先使用快表，失败时才用空表。<br>（5）快表只有4项，很容易被填满，因此空表也是被频繁使用的。<br>综上所述，Windows的堆管理策略兼顾了内存合理使用、分配效率等多方面的因素。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2020/02/02/Apache%20ActiveMQ%20Fileserver%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="Apache ActiveMQ Fileserver漏洞组合复现"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: Apache ActiveMQ Fileserver漏洞组合复现</span></a><a class="button is-default" href="/2019/12/25/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/" title="永恒之蓝（待完善）"><span class="has-text-weight-semibold">下一页: 永恒之蓝（待完善）</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="F-ZhaoYang/F-ZhaoYang.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/F-ZhaoYang"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Fstark 2021</span><span></span></p></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>